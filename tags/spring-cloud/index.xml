<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring Cloud on 无心技术簿</title>
    <link>https://www.wuxinvip.com/tags/spring-cloud/</link>
    <description>Recent content in Spring Cloud on 无心技术簿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 24 Mar 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.wuxinvip.com/tags/spring-cloud/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>EUREKA服务治理</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/eureka-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/eureka-1/</guid>
      <description>1、服务治理三个核心点、服务提供者、服务消费者、服务注册中心
结合Ribbon 服务治理图 服务治理时序图
服务提供者功能：
1、服务注册 2、服务同步 3、服务续约 4、..
服务注册： 服务提供者在启动时候通过rest请求 、将自己注册到Eureka Server上、同时携带自身服务的一些元数据信息、 Eureka Server接收到这个rest请求后 将这些元数据存储到一个双层结构Map中、其中第一层map 的key是服务名字、第二层key是具体服务实例名、 相关配置： eureka.client.register-with-eureka=true 【默认 true】 服务同步： 情景：两个相同的服务提供者实例、注册到了不同的服务注册中心、那么由于两个服务注册中心互相注册、服务注册中心会将服务注册信息发送给Eureka-server的其他机器、【还有一种说法是eureka-server 有信息服务功能、server与server之间 有消息同步、不确定这两种说法那个是真是的底层机制、后者是官方的说法、前者是 翟永超书里的说法、也就是说服务同步是由Eureka-server来完成的】 服务续约： 服务注册后、会维持一个心跳来维持服务不被剔除 相关配置： eureka: instance: status-page-url-path: /info //服务信息 health-check-url-path: /health //服务健康状态 lease-expiration-duration-in-seconds: 90 //服务失效时间 lease-renewal-interval-in-seconds: 30 //服务续约持续调用时间  服务消费者功能：
1、获取服务 2、服务调用 3、服务下线 4、..
获取服务： 服务消费者会发送一个rest请求获取一个服务列表、Eureka-server会发给client一个只读的服务列表、且该列表会30s刷新一次 相关配置： eureka: client: fetch-registry: true //默认为true 设为false则无法获取服务 registry-fetch-interval-seconds: 30 //服务清单刷新时间 服务调用： 集成Ribbon后、默认会使用轮询机制来调取服务实例信息 对于实例选择、在eureka中会有Region和Zone概念 一个Region会有很多Zone、每个服务都需要被注册到一个Zone中、所以每个client对应一个Region和一个Zone、服务调用时候会优先访问Zone下列表、没有在访问同一个Region不同Zone下的服务、 服务下线： 当服务实例jinx你给正常的关闭时、client会给server发送一个server、告知 &amp;quot;我要下线了&amp;quot;  服务注册中心功能：</description>
    </item>
    
    <item>
      <title>Feign服务调用</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/feign-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/feign-1/</guid>
      <description>为了服务之间的服务调用 基于Retrofit,
JAXRS-2.0,
andWebSocket.
开发的 客户端调用工具
更简单方便的调用服务信息
以下是官方简单介绍以及基本用法示例
github
interface Bank { @RequestLine(&amp;quot;POST /account/{id}&amp;quot;) Account getAccountInfo(@Param(&amp;quot;id&amp;quot;) String id); } @RequestMapping(value = &amp;quot;/test/&amp;quot;,method = RequestMethod.GET) RestResponse test(@RequestParam(&amp;quot;test&amp;quot;)Long test); /** * 带参调用方法 * @RequestLine(&amp;quot;POST /uc/login0&amp;quot;) * @Headers(&amp;quot;Content-type: application/json&amp;quot;) * String example0(@RequestParam(&amp;quot;id&amp;quot;) String id); * @RequestLine(&amp;quot;PUT /uc/login1&amp;quot;) * @Headers(&amp;quot;Content-type: application/json&amp;quot;) * String example1(@RequestBody UserVO userVO); * */  </description>
    </item>
    
    <item>
      <title>Hystrix</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/hystrix/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/hystrix/</guid>
      <description>原理
1、流程图 1、方法标注 @HystrixCommand注解 2、方法执行进入执行队列、方法执行、【图中标注 .toObservable()状态】 3、缓存是否可见【有 返回缓存数据；没有进入下一步判断】 4、断路器是否打开【未打开 直接判断信号量线程池是否拒绝 ；打开且触发断路进去fallback方法】 5、信号量线程池是否拒绝【未拒绝 创建线程池隔离舱执行业务逻辑 ；拒绝 执行fallback方法】 6、业务逻辑执行是否成功【成功 判断是否超时；未成功 执行fallback方法】 7、判断是否超时【超时 不返回 未超时返回数据】 8、fallback执行结果【成功 返回数据 ；失败 返回失败或者自行实现业务方法】 其中方法执行结果要返回断路器健康状态给断路器【也就是图中绿色4】  具体信息可见官方详细：
https://github.com/Netflix/Hystrix/wiki/How-it-Works</description>
    </item>
    
    <item>
      <title>Reactor Core</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/reactor-core/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/reactor-core/</guid>
      <description>本文从以下介绍下 Reactor （反应堆）
首先简单介绍Reactor 是什么东西、 其次解决什么问题、 领域应用、 原理、 优点和缺点、  1、简介 2、解决问题 ## 3、领域应用 ## 举个比较熟悉的例子 dubbo dubbo底层使用了netty线程模型 netty 中使用了reactor模式
那么什么是reactor模式？ ### Reactor三种模型 ### Netty线程模型 ### Netty结构 ### dubbo中使用的netty 4、Reactor 原理介绍 ## 4.1 Reactor模式结构 ### 4.2Reactor模式模块之间的交互 5、 Reactor优点 ## Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events 解耦、提升复用性、模块化、可移植性、事件驱动、细力度的并发控制等。 相比 传统的实现、即线程的切换、同步、数据的移动会引起性能问题。也就是说从性能的角度上，它最大的提升就是减少了性能的使用，即不需要每个Client对应一个线程
关于 减少使用线程使用 对性能提升的影响 可看这篇论文
SEDA: Staged Event-Driven Architecture - An Architecture for Well-Conditioned, Scalable Internet Service</description>
    </item>
    
    <item>
      <title>Ribbon</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/ribbon/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/ribbon/</guid>
      <description>官方wiki地址：https://github.com/Netflix/ribbon/wiki
功能简介： * 1、多重和可插入的负载平衡 * 2、与eureka服务整合 * 3、内置故障发现能力 * 4、云启用 * 5、与负载均衡器集成客户端 * 6、Archaius配置驱动客户端工厂
三个子项目：
 ribbon-core：包括负载均衡器和客户端接口定义、通用负载均衡器实现、客户端与负载均衡器和客户端工厂集成 ribbon-eureka：包含基于Eureka客户端的负载均衡器实现、这是用于服务注册和发现的liberary ribbon-httpclient：包含基于JSR-311的Rest客户端与服务均衡器集成的实现  配置 sample-client.properties
# Max number of retries on the same server (excluding the first try) sample-client.ribbon.MaxAutoRetries=1 # Max number of next servers to retry (excluding the first server) sample-client.ribbon.MaxAutoRetriesNextServer=1 # Whether all operations can be retried for this client sample-client.ribbon.OkToRetryOnAllOperations=true # Interval to refresh the server list from the source sample-client.</description>
    </item>
    
    <item>
      <title>cloud feign灵异事件</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud-exception/feign-exception-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud-exception/feign-exception-1/</guid>
      <description>报错 ： Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;dataSourceInitializerPostProcessor&#39;: Unsatisfied dependency expressed through field &#39;beanFactory&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;com.****.feign.UserCenterFeignService&#39;: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.cloud.netflix.feign.FeignClientFactoryBean] from ClassLoader [sun.misc.Launcher$AppClassLoader@61e4705b]  解决办法 加入依赖
原因未明 、创建项目时候导入了feign 使用@EnableFeignClients注解 也ok 不报错 我就以为 feign包导入了 结果不知道哪来的包来的这个注解 导致 灵异事件 ```` ![image.png](http://upload-images.jianshu.io/upload_images/6434888-55ccd9dddc1f19e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  严重怀疑是这个包里的
mmp 莫名其妙的好了 仿佛又回到从前 你对java 一无所知&amp;hellip;&amp;hellip; ```</description>
    </item>
    
    <item>
      <title>sleuth灵异事件</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud-exception/sleuth-exception-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud-exception/sleuth-exception-1/</guid>
      <description>分布式 服务跟踪系统
客户端发送ok server端 启动ok 但是就是没有数据
``` 灵异原因：可能是版本不一致
要保证 客户端 cloud version 和sleuth server cloud version 版本一致 修改方式：
```` </description>
    </item>
    
    <item>
      <title>spring Roo</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/spring-roo/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/spring-roo/</guid>
      <description>what？ 使用命令行形式构建项目
下载地址：https://projects.spring.io/spring-roo/#running-from-shell
快速搭建：
 mkdir hello cd hello roo.sh roo&amp;gt; project setup --topLevelPackage com.foo roo&amp;gt; jpa setup --provider HIBERNATE --database HYPERSONIC_IN_MEMORY roo&amp;gt; entity jpa --class ~.domain.Timer roo&amp;gt; field string --fieldName message --notNull roo&amp;gt; repository jpa --all roo&amp;gt; service --all roo&amp;gt; web mvc setup roo&amp;gt; web mvc view setup --type THYMELEAF roo&amp;gt; web mvc controller --all --responseType THYMELEAF roo&amp;gt; web mvc controller --all --pathPrefix /api roo&amp;gt; quit mvn spring-boot:run  </description>
    </item>
    
    <item>
      <title>spring cloud 总 架构图</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/spring-cloud-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/spring-cloud-1/</guid>
      <description>版权所有 转载 请表明出处
相关代码地址
纠正：
cli 是 结合grovy脚本 工程 consul 是服务注册中心 不过可以结合docker做更容易扩散的集群中心   总结下 ： 可以说 spring cloud 服务中 包括各种spring 基础服务也有了很多更新 有RPC 框架的 注册 netflix 有 关于配置的 远程仓库配置 config 有 关于消息 bus stream 有关于app的 for android (提供RestTemplate) 有关任务调度 的 task 有关于 shell 编程 有关于安全方面的 有关于系统拦截 zuul 等等。 那么看名字可以分为两种 1、Spring * --- spring 为了完善&amp;quot;应用&amp;quot;增加的功能机制 例如 spring security 、spring vault、等等 2、Spring Cloud * ---spring cloud * 是在 微服务中 为了&amp;quot;微服务系统&amp;quot;更方便的集成 对各个功能模块进行封装的结果、  </description>
    </item>
    
    <item>
      <title>spring cloud 族谱</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/spring-cloud-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/spring-cloud-2/</guid>
      <description>功能简介来自官网 整理人：无心
总结下 ： 可以说 spring cloud 服务中 包括各种spring 基础服务也有了很多更新 有RPC 框架的 注册 netflix 有 关于配置的 远程仓库配置 config 有 关于消息 bus stream 有关于app的 for android (提供RestTemplate) 有关任务调度 的 task 有关于 shell 编程 有关于安全方面的 有关于系统拦截 zuul 等等。 那么看名字可以分为两种 1、Spring * --- spring 为了完善&amp;quot;应用&amp;quot;增加的功能机制 例如 spring security 、spring vault、等等 2、Spring Cloud * ---spring cloud * 是在 微服务中 为了&amp;quot;微服务系统&amp;quot;更方便的集成 对各个功能模块进行封装的结果、  </description>
    </item>
    
    <item>
      <title>zuul</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/zuul/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/zuul/</guid>
      <description>zuul
是架设在整个springcloud微服务服务网中的门户模块 所有的外界访问请求 都要经过 这个模块 zuul结合eureka 可以做到动态服务代理
实现功能：
 1、身份验证和安全性-识别每个资源的身份验证要求并拒绝不满足的要求 2、洞察和检测-在边缘跟踪有意义的数据和统计数据、以便为我们提供准确的生产视图 3、动态路由-根据需要将请求动态路由到不同的后端集群 4、压力测试-逐渐增加到群集的流量，以衡量表现 5、加载Shedding-为每种类型的请求分配容量，并删除超出限制的请求 6、静态响应处理-直接边缘建立响应、而不是将他们转发到内部群集 7、多区域弹性-跨AWS区域的路由请求、以使我们的ELB使用多样化、并使我们的边缘更接近我们的成员  组件包含： zuul-core ：包含编译和执行过滤器的核心功能的库 zuul-simple-webapp ：它显示了如何用zuul-core 构建一个应用程序的简单例子 zuul-netflix ： 将其他NetflixOSS组件添加到Zuul的库 使用功能区来执行路由请求 zuul-netflix-webapp ：webapp 把zuul-core 和 zuul-netflix 组合成一个 易于使用的软件包  官方架构 </description>
    </item>
    
    <item>
      <title>容器已经关闭</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud-exception/exception-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud-exception/exception-1/</guid>
      <description>spring cloud task 启动报错 context has been closed already
解决办法 1.5.2 版本ok 2.0.0 报错容器已关闭 解决办法 #spring.cloud.task.closecontext_enabled=false  spring cloud Ribbon
解决办法
写到启动类就行
 spring boot &amp;lt;= 1.3 无需定义 spring boot &amp;gt;= 1.4 springboot不在维护 需要自己定义RestTempalte @Bean public RestTemplate restTemplate (RestTemplateBuilder builder){ //Do any additional configuration here return builder.build(); }  </description>
    </item>
    
  </channel>
</rss>