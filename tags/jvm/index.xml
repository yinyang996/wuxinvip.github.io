<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jvm on 无心技术簿</title>
    <link>http://wuxinvip.github.io/tags/jvm/</link>
    <description>Recent content in Jvm on 无心技术簿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 24 Mar 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://wuxinvip.github.io/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>jvm内存一条线路</title>
      <link>http://wuxinvip.github.io/blog/jdk/jvm-total/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/jdk/jvm-total/</guid>
      <description>入手从collection开始
集合常用 arrayList 底层数据结构 object[] 数组特点 内存连续 数据挨个存放 那么删除中间一个时候 后面的数据会挨个往前挪移 因为地址可知 查询节点数据 较快 通过下标获取 应对业务场景 插入后查询修改数据 如果执行删除操作会造成资源浪费 需要时间重新规划数组结构 linkedList 底层数据结构链表 链表特点 内存不连续 代码 node first、 last； object；存放前后节点hash值【待查询】 然后跟节点对象 该链表实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。 应对业务场景 插入后 可能会删除某项数据 以作数据调整 hashMap 内存结构是hash散列 【我理解为 散着放的列表】 内存特点 hash值分桶存储【其实就一一小块内存】 当hash值冲突 会在该桶内维护一个链表 警告：暂时不晓得这个桶有多大 所以尽量避免hash冲突 万一桶满了是不是要重新规划内存 造成资源浪费？ linkedHashMap 内存特点 与hashMap一致 不同点 linkedHashMap 额外维护了一个双重链表来记录数据插入的顺序性 那么相比较hashMap 多了一个链表要维护 性能要有所下降 【业务需要 没办法】 treeMap 内存结构 红黑二叉树 内存特点：位置 对于二叉树还没搞明白 只晓得父红子黑【还不知道对不对】  说到数据内存 就要讲讲内存结构
jvm内存分为五大块【程序计数器、虚拟机栈、本地方法栈、方法区、堆】 从线程是否共享分起： 线程共享：堆、方法区/非线程共享：程序计数器、虚拟机栈、本地方法栈 简单说下存储信息 1、程序计数器 用于存放下一条指令所在单元的地址的地方 【c与java的交界点用以存放执行指针】 2、虚拟机栈 【为java方法提供服务】 3、本地方法栈【为jvm提供使用native方法服务】 4、方法区 【存储类常量、静态变量等信息】 5、堆 【存放对象实例、对象成员变量】 对于一个obj： 类引用--stack中 类成员变量--Heap中【回收主要地方】 类静态变量、常量--Method Area中 类方法--以帧栈形式保存到栈中  那么内存存储规划完 就得看看 内存的回收机制</description>
    </item>
    
    <item>
      <title>jvm内存回收</title>
      <link>http://wuxinvip.github.io/blog/jdk/jvm-memory-recovery/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/jdk/jvm-memory-recovery/</guid>
      <description>回收区域：堆【主要区域】、方法区【回收废弃常量、无用类】
无用类定义： 1、jvm中不存在该实例 2、加载该类classLoader已被回收 3、任何地方都不存在引用
回收算法： 1、标记清除 2、标记整理 3、复制 4、分代收集
回收器： 单线程 1、serial 2、serial old 多线程 1、parNew 2、parallel scavenge 3、parallel old 4、cms 5、G1
回收新生代 serial、parNew、parallel scavenge
回收老年代 cms、serial old、parallel old
分代收集 G1
serial 最老、也是默认回收算法、单线程 缺点：暂定所有用户进程来回收垃圾、每一小时有五分钟不能给用户提供服务 优点: 简单高效 适合场景、clent模式
ParNew serial多线程版本 场景：参考serial 多核处理器
Parallel scavenge 1、复制算法 2、目标、回收达到一个可控的吞吐量【吞吐量=运行代码时间/（运行代码时间+GC时间）】 3、吞吐量优先收集器
serial old 1、单线程、标记整理算法 2、serial 老版本 3、jdk1.5之前配合Parallel scavenge、cms后备预案
parallel old 1、Parallel scavenge老版本 2、标记整理算法 3、注重吞吐量以及CPU资源敏感场景、使用Parallel scavenge ++ parallel old 4、吞吐量优先
CMS 1、标记清除 2、目标：最短回收停顿时间 3、四个步骤：初始标记、并发标记、重新标记、并发清除
G1 1、1.</description>
    </item>
    
    <item>
      <title>jvm内存结构</title>
      <link>http://wuxinvip.github.io/blog/jdk/jvm-memory-structure/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/jdk/jvm-memory-structure/</guid>
      <description>jvm内存 一条线 线程共享 线程不共线【也叫非线程共享】
线程共享： 堆【Heap】、 方法区【method area】 非线程共享： 程序计数器、虚拟机栈、本地方法栈
方法区还包含 运行时常量池【类常量数据】 异常： jvm中定义两种异常 StackOverflow、outofmemory 一种是栈溢出 一种是内存溢出 官方定义栈溢出：线程请求深度大于虚拟机允许深度、抛出StackOverflow 官方定义内存溢出：java内存扩展、当虚拟机申请不到足够的内存、抛出outofmemory  jvm堆 细分：新生代、老年代【分代收集算法】 再细分：Eden、From Survivor、To Survivor空间 再内存分配黑可以分出多个线程私有的分配缓冲区 存放内容：对象实例、细致的划分只是为了更好的回收 堆是回收主要区域
jvm方法区 1、线程共享 2、存储已被虚拟机加载、类信息、常量、静态变量、即时编译器编译后的代码数据
jvm运行时常量池 1、方法区一部分 2、存放编译期生成各种字面量和符号引用、
直接内存 1、不属于jvm运行时数据取一部分 再五大板块外、 2、jdk1.4中 引入NIO、引用了一种基于通道（channel）与缓冲区（Buffer）的IO方式、它可以使用Native函数库直接分配对外内存、然后通过一个存储再java堆中的DirectByteBuffer对象来作为这一块内存引用、来进行操作、避免了java堆和native堆中来回复制数据 3、该内存受限于 操作系统和物理内存
虚拟机栈 1、虚拟机执行java程序使用栈
本地方法栈 1、执行native方法使用栈
程序计数器 1、与c交界点、一个线程一个程序计数器、内存耗费较小、记录执行指针</description>
    </item>
    
  </channel>
</rss>