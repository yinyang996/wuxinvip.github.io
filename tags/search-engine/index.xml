<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Search Engine on 无心技术簿</title>
    <link>https://wuxinvip.github.io/tags/search-engine/</link>
    <description>Recent content in Search Engine on 无心技术簿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 May 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wuxinvip.github.io/tags/search-engine/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>elasticsearch-bean-setting</title>
      <link>https://wuxinvip.github.io/blog/search-engine/elasticsearch-bean-setting/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/search-engine/elasticsearch-bean-setting/</guid>
      <description>#分片数 index.number_of_shards #副本数 index.number_of_replicas #是否设为影子副本（暂未研究） index.shadow_replicas #是否设为可分享文件系统（暂未研究） index.shard_filesystem #是否自动扩展副本（暂未研究） index.auto_expand_replicas #暂未研究 index.blocks.read_only #暂未研究 index.blocks.read #暂未研究 index.blocks.write #暂未研究 index.blocks.metadata #创建该index用到的Elasticsearch版本 index.version.created index.version.created_string #更新该index用到的Elasticsearch版本 index.verison.upgraded index.version.upgraded_string #该index支持的最小lucene版本 index.version.minimum_compatible #该index建立日期 index.creating_data index.creating_data_string #该index的优先级 index.priority #该index的uuid，唯一标识 index.uuid #该index各索引的routing规则，采用何种Hash方式，默认使用Murmur3，还有一种普通的Hash算法 index.legacy.routing.hash.type #routing计算是否使用type，内部计算shard id的方法已经废弃，建议不使用，不设置，默认false即可 index.legacy.routing.use_type #该index的数据存储路径 index.data_path #暂未研究 #index.shared_filesystem.recover_on_any_node  </description>
    </item>
    
    <item>
      <title>elasticsearch-xmind</title>
      <link>https://wuxinvip.github.io/blog/search-engine/elasticsearch-xmind/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/search-engine/elasticsearch-xmind/</guid>
      <description></description>
    </item>
    
    <item>
      <title>nutch简介</title>
      <link>https://wuxinvip.github.io/blog/search-engine/nutch-1/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/search-engine/nutch-1/</guid>
      <description>简介 发展</description>
    </item>
    
    <item>
      <title>spring-data-es源码</title>
      <link>https://wuxinvip.github.io/blog/spring-cloud/spring-data-es-1/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/spring-cloud/spring-data-es-1/</guid>
      <description>spring-data-common 对接口进行了定义 spring-data-es 对服务进行实现 封装es客户端 学到的更多的是代码的书写吧 各种服务封装 学会了自己封装一个服务给业务部门调用  </description>
    </item>
    
    <item>
      <title>elasticsearch-config</title>
      <link>https://wuxinvip.github.io/blog/search-engine/elasticsearch-config/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/search-engine/elasticsearch-config/</guid>
      <description># ---------------------------------- Cluster ----------------------------------- # # 为群集使用描述性名称: # #cluster.name: my-application # # ------------------------------------ Node ------------------------------------ # #为节点使用描述性名称: # #node.name: node-1 # # 向节点添加自定义属性: # #node.attr.rack: r1 # # ----------------------------------- Paths ------------------------------------ # # 路径到目录存储数据的位置 (用逗号分隔多个位置): # #path.data: /path/to/data # # 日志文件的路径: # #path.logs: /path/to/logs # # ----------------------------------- Memory ----------------------------------- # # 启动时锁定内存: # #bootstrap.memory_lock: true # #确保堆大小设置为大约一半的可用内存在系统上, 并且允许进程的所有者使用此限制。 # # 当系统交换内存时, Elasticsearch 执行得很差。 # # ---------------------------------- Network ----------------------------------- # # 将绑定地址设置为特定 IP (IPv4 或 IPv6): # #network.</description>
    </item>
    
    <item>
      <title>elasticsearch内部存储执行机制</title>
      <link>https://wuxinvip.github.io/blog/search-engine/elasticsearch-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/search-engine/elasticsearch-1/</guid>
      <description>新建、索引和删除单个文档
以下是在主副分片和任何副本分片上面成功新建，索引和删除文档所需要的步骤顺序：
 客户端向 Node 1 发送新建、索引或者删除请求。 节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。 Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。  在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。
取回单个文档 以下是从主分片或者副本分片检索文档的步骤顺序：
1、客户端向 Node 1 发送获取请求 2、节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 Node 2 3、Node 2 将文档返回给 Node 1 ，然后将文档返回给客户端。
在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡
局部更新文档 以下是部分更新一个文档的步骤：
 客户端向 Node 1 发送更新请求。 它将请求转发到主分片所在的 Node 3 。 Node 3 从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃。 如果 Node 3 成功地更新文档，它将新版本的文档并行转发到 Node 1 和 Node 2 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， Node 3 向协调节点也返回成功，协调节点向客户端返回成功。  update API 还接受在 新建、索引和删除文档 章节中介绍的 routing 、 replication 、 consistency 和 timeout 参数。</description>
    </item>
    
  </channel>
</rss>