<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mysql on 无心技术簿</title>
    <link>https://wuxinvip.github.io/tags/mysql/</link>
    <description>Recent content in Mysql on 无心技术簿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 29 Jun 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wuxinvip.github.io/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MySQL经典架构</title>
      <link>https://wuxinvip.github.io/blog/mysql/mysql-solution/</link>
      <pubDate>Fri, 29 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/mysql/mysql-solution/</guid>
      <description>mysql主从复制
此种架构，一般初创企业比较常用，也便于后面步步的扩展
  此架构特点：
 1、成本低，布署快速、方便 2、读写分离 3、还能通过及时增加从库来减少读库压力 4、主库单点故障 5、数据一致性问题（同步延迟造成）  MySQL+MMM架构
通过 DRBD 基于 block 块的复制模式，快速进行双主故障切换，很大程度上解决主库单点故障问题
  此架构特点：
 1、高可用软件可使用 Heartbeat, 全面负责 VIP、数据与 DRBD 服务的管理 2、主故障后可自动快速切换，并且从库仍然能通过 VIP 与新主库进行数据同步 3、从库也支持读写分离，可使用中间件或程序实现  MySQL+DRDB架构
MHA 目前在 Mysql 高可用方案中应该也是比较成熟和常见的方案，它由日本人开发出来，在 mysql 故障切换过程中，MHA 能做到快速自动切换操作，而且还能最大限度保持数据的一致性
  此架构特点：
 1、安装布署简单，不影响现有架构 2、自动监控和故障转移 3、保障数据一致性 4、故障切换方式可使用手动或自动多向选择 5、适应范围大（适用任何存储引擎）  MySQL+MHA架构
MMM 即 Master-Master Replication Manager for MySQL（mysql 主主复制管理器），是关于 mysql 主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件（在任何时候只有一个节点可以被写入），这个套件也能基于标准的主从配置的任意数量的从服务器进行读负载均衡，所以你可以用它来在一组居于复制的服务器启动虚拟 ip，除此之外，它还有实现数据备份、节点之间重新同步功能的脚本。 MySQL 本身没有提供 replication failover 的解决方案，通过 MMM 方案能实现服务器的故障转移，从而实现 mysql 的高可用。</description>
    </item>
    
    <item>
      <title>mysql 索引</title>
      <link>https://wuxinvip.github.io/blog/mysql/mysql-indexes/</link>
      <pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/mysql/mysql-indexes/</guid>
      <description>mysql 索引
单列索引 1、普通索引--允许null和重复--优点就是查询快 2、唯一索引--允许null 但是不可重复 3、主键索引--不允许null 不可重复 组合索引 1、联合索引【组合索引】 多个字段创建一个索引健、只有最左边的索引被用到 联合索引才能被用到 索引最多包含16列 全文索引 1、全文索引 MyISAM 引擎独有 只能用在 char varchar text使用 检索文字关键字 空间索引 1、空间索引 针对空间数据类型的字段所建立的索引 MyISAM 引擎独有 空间引擎所在列 not null 支持数据类型 geometry、point、linestring、polygon 创建索引使用 spatial 关键字 纠正： MyISAM并InnoDB 支持空间类型的R-tree索引。 其他存储引擎使用B树来索引空间类型（除了 ARCHIVE不支持空间类型索引）。 所有的索引 必须合适业务使用在创建 对于更新频繁 检索较少的不得加除了主键索引之外的任何索引 徒增insert 和 update delete 消耗  B树和散列索引的比较 了解B树和散列数据结构可以帮助预测不同的查询在使用索引中的这些数据结构的不同存储引擎上的性能。
特别是用于MEMORY允许您选择B树或散列索引的存储引擎。 B树 区分大小 【小于 大于 大于等于 小于等于】 hash树 确定值【等于】
检索索引是否有效 explain</description>
    </item>
    
    <item>
      <title>MYSQL版本选择</title>
      <link>https://wuxinvip.github.io/blog/mysql/mysql-version-selected/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/mysql/mysql-version-selected/</guid>
      <description>学习阿里mysql笔记
mysql 历史过程中产生了三个版本
Percona Server : 有领先的MYSQL咨询公司 Percona公司发布
Maria DB : MYSQL最早创始人 重新做的一个版本
MYSQL : Oracle公司收购的版本
关于mysql存储引擎：MyISAM、InnoDB、XtraDB
最早、最原始的存储引擎MyISAM、缺点不支持事务、优点 读写性能要好 InnoDB 支持了事务、并把数据操作记录到日志、安全性较好、读写性能也有很大提高、稍低MyISAM(mysql 5.5之后默认存储引擎选取了InnoDB) XtraDB 是InnoDB增强版本、被设计用来更新计算机硬件系统性能、同时还包含了一些高性能环境下新特性。  Percona Server发展到10.X版本、最接近mysql企业版本 最主要特性、提供了存储引擎 XtraDB、还提供PXC高可用解决方案、还有percona-tookit等DBA管理工具箱、 【据使用经验 这个版本性能非常非常高的 推荐排名第一位】 MariaDB 目标、取代现在mysql、oracle的mysql闭源危机 使用完全兼容mysql。 优点支持脚本初始化、与最初mysql代码改动最大、成熟度较低 支持新工具、新功能在不断完善、、 【第二推荐】 MYSQL ：官方版本、使用量最多、后续趋势会被其他两种取代、 性能方面、在企业版本会增加一些新功能、但是收费 【第三推荐、对性能要求不高、稳定版本】  InnoDB :支持事务 、行级锁、外键</description>
    </item>
    
    <item>
      <title>MySQL常用命令</title>
      <link>https://wuxinvip.github.io/blog/mysql/mysql-shell/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/mysql/mysql-shell/</guid>
      <description>mysql -u root -p use user; drop database user; use mysql select Host,User,authentication_string from mysql.user; grant all privileges on *.* to &#39;root&#39;@&#39;115.171.60.75&#39;identified by &#39;root&#39; with grant option; all insert update ... *.* : 数据库.表名 root : 用户名 115.170.*.* : 远程访问ip地址 刷新配置 flush privileges; delete from mysql.user where user=root and host = 115.171.60.75;  安装 原装地址：http://www.cnblogs.com/5201351/p/4912614.html
卸载mriadb包 [root@5201351 ~]# rpm -qa|grep mariadb mariadb-libs-5.5.41-2.el7_0.x86_64 [root@5201351 ~]# rpm -e mariadb-libs-5.5.41-2.el7_0.x86_64 --nodeps 安装 mysql 安装包 https://dev.</description>
    </item>
    
    <item>
      <title>mysql-care点</title>
      <link>https://wuxinvip.github.io/blog/mysql/mysql-care-point/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/mysql/mysql-care-point/</guid>
      <description> 查询缓存从 Mysql5.7.20开始已经弃用、并在MySQL8.0中删除  </description>
    </item>
    
    <item>
      <title>mysql存储过程</title>
      <link>https://wuxinvip.github.io/blog/mysql/mysql-stored-procedure/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/mysql/mysql-stored-procedure/</guid>
      <description>DELIMIT ; CREATE DROP (); DELIMIT //  为什么使用存储过程 有过统计:一个事务提交放到service层 大概一秒能处理500个(好像是2ms一个.算上网络延迟) 而使用mysql存储过程 一秒钟大概能处理2000个事物
阿里编码规范有讲不适用存储过程.维护起来很困难.但是该用还得用.像秒杀.</description>
    </item>
    
    <item>
      <title>mysql最大连接数</title>
      <link>https://wuxinvip.github.io/blog/mysql/mysql-max-connects/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/mysql/mysql-max-connects/</guid>
      <description>linux默认1000 window 默认2000
还要根据文件系统 性能 来调节 mysql连接数</description>
    </item>
    
    <item>
      <title>数据库设计三大范式</title>
      <link>https://wuxinvip.github.io/blog/mysql/mysql-design-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/mysql/mysql-design-1/</guid>
      <description>1．第一范式(确保每列保持原子性)
2．第二范式(确保表中的每列都和主键相关)
3．第三范式(确保每列都和主键列直接相关,而不是间接相关)
一、第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。
第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。
上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。
二、第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。
订单信息表
这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。
而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。
这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。
三、第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。
比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。
这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。
转载地址</description>
    </item>
    
  </channel>
</rss>