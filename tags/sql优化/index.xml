<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sql优化 on 无心技术簿</title>
    <link>http://wuxinvip.github.io/tags/sql%E4%BC%98%E5%8C%96/</link>
    <description>Recent content in Sql优化 on 无心技术簿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 24 Mar 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://wuxinvip.github.io/tags/sql%E4%BC%98%E5%8C%96/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SQL优化【InnoDB-表优化】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-innodb/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-innodb/</guid>
      <description>innodb表优化
8.5.1优化InnoDB表的存储布局
一旦数据达到稳定的大小，或者增长表增加了几十或几百兆字节，请考虑使用该OPTIMIZE TABLE语句来重新组织表并压缩任何浪费的空间。 重新组织的表需要更少的磁盘I / O来执行全表扫描。 当其他技术（如改进索引使用或调整应用程序代码）不切实际时，这是一种直接技术，可以提高性能。 OPTIMIZE TABLE复制表格的数据部分并重建索引。 好处来自改进索引内数据的打包，并减少表空间和磁盘内的碎片。 好处取决于每个表中的数据。 您可能会发现某些人有显着的收益，而不是其他人，或者收益会随着时间的推移而下降，直到您再次优化表。 如果表很大或者重建的索引不适合缓冲池，则此操作可能会很慢。 向表中添加大量数据后的第一次运行通常比后期运行慢得多。 在中InnoDB，有一个很长的PRIMARY KEY（无论是一个长的值的单个列，还是多个形成一个长复合值的列）浪费了大量的磁盘空间。 一行中的主键值在所有指向同一行的二级索引记录中都是重复的。 （请参见第14.8.2.1节“集群索引和二级索引”。 ）AUTO_INCREMENT如果主键很长，或者索引长VARCHAR列的前缀而不是整列，则创建一个列作为主键。 使用VARCHAR数据类型而不是CHAR存储可变长度的字符串或具有多个NULL值的列 。 甲 列总是占据字符来存储数据，即使该字符串是较短，或者其值 。 较小的表适合缓冲池，并减少磁盘I / O。 CHAR(N)NNULL 使用COMPACT行格式（默认InnoDB格式）和可变长度字符集（如 utf8或）时sjis， 列占用可变数量的空间，但仍至少为字节。 CHAR(N)N 对于大的表或者包含大量重复的文本或数字数据的表，请考虑使用 COMPRESSED行格式。 将数据带入缓冲池或执行全表扫描需要较少的磁盘I / O。 在做出永久性决定之前，请测量使用行格式COMPRESSED与 您可以实现的压缩量 COMPACT。  8.5.2优化InnoDB事务管理
要优化InnoDB事务处理，请在事务功能的性能开销和服务器的工作负载之间找到理想的平衡点。 例如，如果应用程序每秒提交数千次，则应用程序可能会遇到性能问题，如果应用程序每2-3小时提交一次，则会出现不同的性能问题。 默认的MySQL设置AUTOCOMMIT=1 可能会对繁忙的数据库服务器造成性能限制。 在可行的情况下，在进行所有更改后，通过发布SET AUTOCOMMIT=0或START TRANSACTION声明将几个相关的数据更改操作包括到单个事务中 ，然后包含 COMMIT声明。 InnoDB如果该事务对数据库进行了修改，则必须在每次事务提交时将日志刷新到磁盘。 当每次更改之后都进行提交（与默认的自动提交设置一样）时，存储设备的I / O吞吐量会对每秒潜在操作的数量设置上限。 或者，对于仅由单个SELECT语句组成的事务，开启AUTOCOMMIT有助于 InnoDB识别只读事务并优化它们。 有关要求，请参见 第8.5.3节“优化InnoDB只读事务”。 避免在插入，更新或删除大量行后执行回滚。 如果一个大事务正在降低服务器的性能，那么回滚会导致问题变得更糟，可能需要几次才能执行原始数据更改操作。 杀死数据库进程无济于事，因为在服务器启动时会再次开始回滚。 为了尽量减少发生此问题的机会： 增加缓冲池的大小， 以便可以缓存所有数据更改更改，而不是立即写入磁盘。 设置 innodb_change_buffering=all 以便更新和删除操作在插入之外进行缓冲。 考虑COMMIT在大数据更改操作期间定期发布语句，可能会将单个删除或更新分为多个在较少数量的行上操作的语句。 为避免出现失控回滚，请增加缓冲池，以便回滚变为受CPU限制且运行速度很快，或者innodb_force_recovery=3按照第14.</description>
    </item>
    
    <item>
      <title>SQL优化【MyISAM-表优化】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-myisam/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-myisam/</guid>
      <description>8.6.1优化MyISAM查询
加快查询MyISAM表的一些常规提示 ： 为了帮助MySQL更好地优化查询，请使用 ANALYZE TABLE或运行 myisamchk -在载入数据之后对其进行分析。 这会更新每个索引部分的值，以指示具有相同值的平均行数。 （对于唯一索引，这总是1.）当你基于非常量表达式连接两个表时， MySQL使用它来决定选择哪个索引。 您可以通过使用和检查值来检查表格分析的结果 。 myisamchk --description --verbose显示索引分布信息。 SHOW INDEX FROM tbl_nameCardinality 要根据索引对索引和数据进行排序，请使用 myisamchk --sort-index --sort-records = 1 （假设您要对索引1进行排序）。 如果您有一个唯一索引，您希望根据索引按顺序读取所有行，则这是一种更快查询的好方法。 第一次以这种方式排列大表时，可能需要很长时间。 尽量避免SELECT 对MyISAM经常更新的表进行复杂的查询，以避免由于读者和作者之间的争用而发生的表锁定问题。 MyISAM支持并发插入：如果一个表在数据文件中间没有空闲块，那么可以INSERT在其他线程从表中读取数据的同时将新行插入到它中。 如果能做到这一点很重要，请考虑以避免删除行的方式使用表。 另一种可能性是OPTIMIZE TABLE在删除了很多行之后运行对表进行碎片整理。 这种行为是通过设置concurrent_insert变量来改变的 。 您可以强制添加新行（因此允许并发插入），即使在已删除行的表中也是如此。 请参见第8.11.3节“并发插入”。 对于MyISAM频繁更改的表，尽量避免所有变长列（VARCHAR， BLOB，和 TEXT）。 如果该表甚至包含单个可变长度列，该表使用动态行格式。 请参阅第15章，备用存储引擎。 仅仅因为行变大，将表分割成不同的表通常是没有用的。 在访问行时，最大的性能影响是找到行的第一个字节所需的磁盘查找。 找到数据后，大多数现代磁盘可以为大多数应用程序快速读取整行。 分割表格的唯一情况是，如果它是一个MyISAM使用动态行格式的 表格，您可以更改为固定的行大小，或者您经常需要扫描表格但不需要大多数列。 请参阅第15章，备用存储引擎。 如果您通常按顺序检索行， 请使用它 。 在对表格进行大量更改后使用此选项，您可能会获得更高的性能。 ALTER TABLE ... ORDER BY expr1, expr2, ...expr1, expr2, ... 如果您经常需要根据来自很多行的信息计算结果（如计数），则最好引入一个新表并实时更新计数器。 以下表单的更新速度非常快： UPDATE tbl_nameSET count_col= count_col+1 WHERE key_col= constant; 当你使用MySQL存储引擎时，这是非常重要的，例如MyISAM只有表级锁定（多个读者使用单个编写器）。 这也为大多数数据库系统提供了更好的性能，因为在这种情况下行锁管理器不太容易。 OPTIMIZE TABLE 定期 使用以避免使用动态格式MyISAM表进行分段 。 请参见 第15.</description>
    </item>
    
    <item>
      <title>SQL优化【SQL索引】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-indexes/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-indexes/</guid>
      <description>提高操作性能的最佳方法 SELECT是在查询中测试的一列或多列上创建索引。 索引条目就像指向表行的指针，允许查询快速确定哪些行与WHERE子句中的条件匹配，并检索这些行的其他列值。 所有的MySQL数据类型都可以被索引。
尽管为查询中使用的每个可能的列创建索引是很诱人的，但不必要的索引会浪费空间并浪费时间让MySQL确定要使用的索引。 索引还会增加插入，更新和删除的成本，因为每个索引都必须更新。 您必须找到适当的平衡，才能使用最佳索引集实现快速查询。
8.3.1 MySQL如何使用索引
索引用于快速查找具有特定列值的行。 如果没有索引，MySQL必须从第一行开始，然后读取整个表以查找相关行。 表格越大，成本越高。 如果表中有相关​​列的索引，MySQL可以快速确定在数据文件中间寻找的位置，而无需查看所有数据。 这比按顺序读取每一行要快得多。 大多数MySQL索引（PRIMARY KEY， UNIQUE，INDEX和 FULLTEXT）存储在 B树。 例外：空间数据类型的索引使用R树; MEMORY 表还支持散列索引 ; 索引InnoDB使用倒排列表FULLTEXT。 一般来说，索引的使用将在下面的讨论中描述。 第8.3.8节“B树和散列索引的比较”MEMORY中描述了特定于散列索引的特性（如表中所用 ） 。 MySQL使用这些操作的索引： WHERE快速 查找与子句匹配的行。 考虑排除行。 如果在多个索引之间有选择，MySQL通常使用找到最少行数的索引（最具 选择性的索引）。 如果表具有多列索引，则优化器可以使用该索引的任何最左边的前缀来查找行。 例如，如果你有一个三列索引上 (col1, col2, col3)，你有索引的搜索功能(col1)， (col1, col2)以及(col1, col2, col3)。 有关更多信息，请参见 第8.3.5节“多列索引”。 在执行连接时从其他表中检索行。 如果它们被声明为相同的类型和大小，MySQL可以更有效地在列上使用索引。 在这种情况下， VARCHAR与 CHAR被认为是相同的，如果它们被声明为相同的大小。 例如， VARCHAR(10)和 CHAR(10)大小相同，但 VARCHAR(10)与 CHAR(15)不是。 为了比较非二进制字符串列，两列应使用相同的字符集。 例如，将utf8列与 latin1列进行比较将排除索引的使用。 比较不同的列（例如，比较字符串列与时间或数字列）可能会阻止使用索引，如果无法直接比较值而不进行转换。 对于给定的值，如1 在数值列，它可能比较等于在字符串列，例如任何数量的值 &#39;1&#39;，&#39; 1&#39;， &#39;00001&#39;，或&#39;01.e1&#39;。 这排除了字符串列的任何索引的使用。 查找特定索引列的值MIN()或 MAX()值key_col。 这由预处理器进行了优化，该预处理器检查您是否使用 索引中之前发生的所有关键部件。 在这种情况下，MySQL会为每个表达式或 单个表达式执行单键查找，并用常量替换它。 如果所有表达式都被常量替换，则查询立即返回。 例如： WHERE key_part_N = constantkey_colMIN()MAX() SELECT MIN（key_part2），MAX（key_part2） FROM tbl_nameWHERE key_part1= 10; 如果排序或分组是在可用索引的最左侧前缀（例如，）上完成，则对表排序或分组 。 如果所有关键部件都紧随其后，则按相反的顺序读取钥匙。 请参见 第8.</description>
    </item>
    
    <item>
      <title>SQL优化【SQL语句】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-sentence/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-sentence/</guid>
      <description>1、select语句
1、删除无效括号【为了增加运算速度牺牲的可读性、mysql会做类似优化】 2、持续折叠 3、恒定条件去除【为了更好的逻辑可读性重复字段=固定值】 4、及时检测无效常量表达式 5、关于havingwhere 、如果不与group by、或者count、min、等聚合函数一起使用、尽量不要使用 6、where 表达式尽量简单、便于快速建立where评估表 7、查询其他表之前首先查询所有常量表 【 SELECT * FROM t WHERE primary_key=1; SELECT * FROM t1,t2 WHERE t1.primary_key=1 AND t2.primary_key=t1.id; 】  2、范围优化 对于两种索引结构使用不同的范围条件【hash索引、B树索引】 ==========mmp 太难了 没办法写下去 只能贴图了 以后慢慢品鉴</description>
    </item>
    
    <item>
      <title>SQL优化【总方向】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-total/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-total/</guid>
      <description>老生常谈 SQL 优化 而且一百度一堆，却没有一个令人满意的
秉承官方文档 原则 【MYSQL第八章 SQL优化】
优化方向： SQL查询and存储
sql语句 sql索引 sql数据库结构 sql表【InnoDb表、MyISAM表、Memory表】  缓存
查询优化器 缓冲和高速缓冲区  锁
优化锁定操作  MYSQL服务器
系统因素-并发量 磁盘IO 内存使用 网络使用  检查
检查线程信息  </description>
    </item>
    
    <item>
      <title>SQL优化【数据结构】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-data-structure/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-data-structure/</guid>
      <description>在作为数据库设计师的角色中，寻找组织模式，表和列的最有效方式。 与调整应用程序代码时一样，您可以最大限度地减少I / O，将相关项目集中在一起，并提前进行计划， 以便随着数据量的增加性能保持在较高水平 从高效的数据库设计开始， 团队成员可以更轻松地编写高性能的应用程序代码，并使数据库可以随应用程序的演变和重写而持续下去。
8.4.1优化数据大小
设计您的表格以尽量减少磁盘空间。 这可以通过减少写入和读取磁盘的数据量来实现巨大的改进。 在查询执行期间，较小的表格通常需要较少的主存储器，而其内容正在被主动处理。 表数据的任何空间减少也会导致可以更快处理的更小的索引。 MySQL支持许多不同的存储引擎（表格类型）和行格式。 对于每个表格，您可以决定使用哪种存储和索引方法。 为您的应用程序选择适当的表格格式可以为您带来巨大的性能提升。 请参阅 第14章InnoDB存储引擎和 第15章备用存储引擎。 通过使用此处列出的技术，您可以获得更好的表格性能并最小化存储空间： 表列 行格式 索引 加盟 正常化 表列 尽可能使用最有效（最小）的数据类型。 MySQL有很多专门的类型可以节省磁盘空间和内存。 例如，如果可能的话，使用较小的整数类型来获得较小的表格。 MEDIUMINT通常是一个更好的选择，INT因为一 MEDIUMINT列使用的空间减少了25％。 NOT NULL如果可能的话， 声明列。 通过更好地使用索引并消除测试每个值是否存在开销，它使SQL操作更快NULL。 您还可以节省一些存储空间，每列一位。 如果您真的需要NULL表格中的值，请使用它们。 只需避免允许NULL每列中的值的默认设置 。 行格式 InnoDB表格DYNAMIC默认使用行格式创建 。 要在a 或语句中明确使用除了DYNAMIC，配置 innodb_default_row_format或指定ROW_FORMAT选项以外的行格式。 CREATE TABLEALTER TABLE 行格式的紧凑系列，其中包括 COMPACT，DYNAMIC和COMPRESSED，以减少某些操作的CPU使用为代价来减少行存储空间。 如果您的工作负载是受缓存命中率和磁盘速度限制的典型负载，则可能会更快。 如果这是一个受CPU速度限制的罕见情况，则可能会变慢。 紧凑的行格式系列还可以CHAR在使用诸如utf8mb3或的可变长度字符集时优化 列存储 utf8mb4。 使用ROW_FORMAT=REDUNDANT， 占用字符集的最大字节长度×。 许多语言主要使用单字节字符编写 ，因此固定的存储长度通常会浪费空间。 使用紧凑的行格式系列，可在to 范围内分配可变数量的存储空间 CHAR(N)Nutf8InnoDBNN×通过去除尾部空格来为这些列设置字符集的最大字节长度。 最小存储长度为 N字节，便于在典型情况下进行就地更新。 有关更多信息，请参见 第14.8.1.2节“InnoDB表的物理行结构”。 要通过以压缩形式存储表数据来进一步减少空间，请ROW_FORMAT=COMPRESSED在创建InnoDB表时 指定 ，或在现有表上运行 myisampack命令 MyISAM。 （InnoDB压缩表是可读可写的，而MyISAM压缩表是只读的。 ） 对于MyISAM表中，如果没有任何可变长度列（VARCHAR， TEXT，或 BLOB列），一个固定大小的行格式被使用。 这会更快，但可能会浪费一些空间。 请参见第15.</description>
    </item>
    
    <item>
      <title>SQL优化【服务器优化】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-system/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-system/</guid>
      <description>本节讨论数据库服务器的优化技术，主要处理系统配置而不是调整SQL语句。 本节中的信息适用于想要确保他们管理的服务器的性能和可扩展性的DBA; 对于构建包括设置数据库的安装脚本的开发人员; 以及那些希望最大限度提高自身生产力的开发，测试等人员自己运行MySQL。
8.12.1系统因素
一些系统级因素可能会以主要方式影响性能： 如果有足够的RAM，则可以删除所有交换设备。 某些操作系统在某些情况下使用交换设备，即使您拥有可用内存。 避免对MyISAM表格进行外部锁定 。 默认值是禁用外部锁定。 在 --external-locking和 --skip-external-locking 选项明确地启用和禁用外部锁定。 只要您只运行一台服务器，禁用外部锁定不会影响MySQL的功能。 请记住在运行myisamchk之前取下服务器（或者锁定并冲洗相关的表格） 。 在某些系统中，强制禁用外部锁定是因为它无法工作。 唯一不能禁用外部锁定的情况是在 同一数据上运行多个MySQL 服务器（而不是客户端），或者如果您运行 myisamchk检查（而不是修复）表而不告知服务器先刷新和锁定表。 请注意 ，除了使用NDB群集时，通常不建议使用多个MySQL服务器同时访问相同的数据。 该LOCK TABLES和 UNLOCK TABLES语句使用内部锁定，所以你可以使用他们，即使外部锁定被禁用。  8.12.2优化磁盘I / O
本节介绍如何在您将更多更快的存储硬件投入数据库服务器时配置存储设备。 有关优化 InnoDB配置以提高I / O性能的信息，请参见第8.5.8节“优化InnoDB磁盘I / O”。 磁盘寻求是一个巨大的性能瓶颈。 当数据量开始变得如此之大以至于不能有效缓存时，这个问题就会变得更加明显。 对于您可以随意访问数据的大型数据库，您可以确保至少需要一次磁盘查找以及一些磁盘写入操作。 为了尽量减少这个问题，请使用低寻道时间的磁盘。 通过将文件符号链接到不同的磁盘或剥离磁盘来增加可用磁盘主轴的数量（从而减少查找开销）： 使用符号链接 这意味着，对于MyISAM表，您可以将索引文件和数据文件从其在数据目录中的常用位置符号链接到另一个磁盘（也可以是条带化的）。 这使得查找和读取时间更好，假设磁盘也不用于其他目的。 参见 第8.12.3节“使用符号链接”。 符号链接不支持与InnoDB表一起使用 。 但是，可以将InnoDB数据和日志文件放置在不同的物理磁盘上。 有关更多信息，请参见第8.5.8节“优化InnoDB磁盘I / O”。 条带化 条带化意味着您有许多磁盘，并将第一个磁盘块，第二个磁盘上的第二个磁盘N块和（）磁盘上的第 - 个磁盘块，依此类推。 这意味着如果您的正常数据大小小于条带大小（或完全对齐），则可以获得更好的性能。 分条非常依赖操作系统和条带大小，因此可以用不同的条带大小对应用程序进行基准测试。 参见第8.13.2节“使用自己的基准”。 N MOD number_of_disks 对于分拆的速度差是 非常依赖的参数。 根据您设置条带参数和磁盘数量的方式，您可能会得到数量级差异。 您必须选择针对随机或顺序访问进行优化。 为了保证可靠性，您可能需要使用RAID 0 + 1（分条加镜像），但在这种情况下，您需要2个 N驱动器来保存 N数据驱动器。 如果你有钱，这可能是最好的选择。 但是，您可能还需要投资一些卷管理软件来有效处理它。 一个好的选择是根据数据类型的重要性来改变RAID级别。 例如，存储可在RAID 0磁盘上重新生成的半重要数据，但存储真正重要的数据，例如主机信息和日志记录在RAID 0 + 1或RAID N磁盘上。 N由于更新奇偶校验位所需的时间，如果您有很多写操作，则RAID 可能会成为问题。 您还可以设置数据库使用的文件系统的参数： 如果您不需要知道上次访问文件的时间（这在数据库服务器上并不真正有用），则可以使用该-o noatime 选项安装文件系统。 这会跳过对文件系统inode中最后一次访问时间的更新，从而避免一些磁盘搜索。 在许多操作系统上，可以通过将该-o async选项挂载来将文件系统设置为异步更新。 如果您的计算机相当稳定，这应该可以提供更好的性能而不会牺牲太多的可靠性。 （这个标志在Linux上默认打开。 ） 在MySQL中使用NFS 建议在考虑使用NFS与MySQL时谨慎。 潜在问题因操作系统和NFS版本而异，其中包括： 放置在NFS卷上的MySQL数据和日志文件被锁定并无法使用。 例如，如果多个MySQL实例访问相同的数据目录，或由于停电等原因导致MySQL不正确关闭，则可能会出现锁定问题。 NFS版本4通过引入基于咨询和基于租约的锁定来解决潜在的锁定问题。 但是，不建议在MySQL实例中共享数据目录。 由于收到的消息乱序或网络流量丢失而​​导致数据不一致。 要避免此问题，请使用TCP hard和 intr安装选项。 最大文件大小限制。 NFS版本2客户端只能访问文件的最低2GB（带符号32位偏移量）。 NFS版本3客户端支持较大的文件（最多64位偏移量）。 支持的最大文件大小还取决于NFS服务器的本地文件系统。 在专业SAN环境或其他存储系统中使用NFS往往比在这种环境之外使用NFS提供更高的可靠性。 但是，SAN环境中的NFS可能比直接连接或总线连接的非循环存储要慢。 如果您选择使用NFS，建议使用NFS版本4或更高版本，与在部署到生产环境之前彻底测试NFS设置一样。  8.</description>
    </item>
    
    <item>
      <title>SQL优化【查询器优化·一】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-selector-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-selector-1/</guid>
      <description>8.8.1使用EXPLAIN优化查询
该EXPLAIN语句提供有关MySQL如何执行语句的信息： EXPLAIN作品有 SELECT， DELETE， INSERT， REPLACE，和 UPDATE语句。 当EXPLAIN与可解释的语句一起使用时，MySQL会显示来自优化器的关于语句执行计划的信息。 也就是说，MySQL解释了它将如何处理该语句，包括有关表如何连接以及按何种顺序的信息。 有关使用 EXPLAIN获取执行计划信息的信息，请参见第8.8.2节“EXPLAIN输出格式”。 当EXPLAIN与 可解释的语句一起使用时，它显示在命名连接中执行的语句的执行计划。 请参见第8.8.4节“获取命名连接的执行计划信息”。 FOR CONNECTION connection_id 对于SELECT语句， EXPLAIN产生可以使用显示的附加执行计划信息 SHOW WARNINGS。 请参见 第8.8.3节“扩展EXPLAIN输出格式”。 EXPLAIN对于检查涉及分区表的查询很有用。 请参见 第22.3.5节“获取有关分区的信息”。 该FORMAT选项可用于选择输出格式。 TRADITIONAL以表格格式显示输出。 如果没有FORMAT选项，这是默认值 。 JSON格式以JSON格式显示信息。 在帮助下EXPLAIN，您可以看到应该在哪里添加索引，以便通过使用索引查找行来更快地执行语句。 您还可以 EXPLAIN用来检查优化程序是否以最佳顺序加入表。 为了给优化器提示使用与SELECT语句中命名表的顺序相对应的连接顺序 ，请使用SELECT STRAIGHT_JOIN而不是仅仅开始语句SELECT。 （请参见 第13.2.9节“SELECT语法”。）但是， STRAIGHT_JOIN可能会阻止使用索引，因为它会禁用半连接转换。 看到 第8.2.2.1节“使用半连接转换优化子查询，派生表和视图引用”。 优化器跟踪有时可以提供与之相辅相成的信息EXPLAIN。 但是，优化器跟踪格式和内容在版本之间可能会发生变化。 有关详细信息，请参阅 MySQL内部：跟踪优化器。 如果您在确定索引时没有使用索引时遇到问题，请运行ANALYZE TABLE以更新表格统计信息（如键的基数），这些索引可能会影响优化程序的选择。 请参见 第13.7.2.1节“ANALYZE TABLE语法”。 注意 EXPLAIN也可以用于获取有关表中列的信息。 是和的 同义词。 有关更多信息，请参见第13.8.1节“DESCRIBE语法”和 第13.7.5.5节“SHOW COLUMNS语法”。 EXPLAIN tbl_nameDESCRIBE tbl_nameSHOW COLUMNS FROM tbl_name  8.8.2 EXPLAIN输出格式
该EXPLAIN语句提供有关MySQL如何执行语句的信息。 EXPLAIN作品有 SELECT， DELETE， INSERT， REPLACE，和 UPDATE语句。 EXPLAIN为SELECT语句中使用的每个表返回一行信息 。 它按照MySQL在处理语句时读取它们的顺序列出输出中的表。 MySQL使用嵌套循环连接方法解析所有连接。 这意味着MySQL从第一个表中读取一行，然后在第二个表，第三个表等中找到匹配的行。 处理完所有表后，MySQL将通过表列表输出所选列和回溯，直到找到有更多匹配行的表。 下一行从该表中读取，并且该过程继续下一个表。 EXPLAIN输出包括分区信息。 另外，对于SELECT 语句，EXPLAIN生成扩展信息，可以按照SHOW WARNINGS以下 方式显示 EXPLAIN（参见 第8.</description>
    </item>
    
    <item>
      <title>SQL优化【查询器优化·二】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-selector-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-selector-2/</guid>
      <description>8.9.1控制查询计划评估
查询优化器的任务是查找执行SQL查询的最佳计划。 由于“ 好 ”和“ 坏 ”之间的表现差异计划可以是数量级（即秒数与数小时甚至数天）， 大多数查询优化器（包括MySQL的查询优化器）在所有可能的查询评估计划中执行或多或少的穷举搜索优化计划。 对于连接查询，由MySQL优化器调查的可能计划的数量随着查询中引用的表的数量呈指数增长。 对于少量表格（通常小于7到10），这不是问题。 但是，当提交更大的查询时，查询优化花费的时间可能很容易成为服务器性能的主要瓶颈。 用于查询优化的更灵活的方法使用户能够控制优化器在搜索最优查询评估计划时的详尽程度。 总体思路是，优化程序调查的计划越少，编译查询花费的时间就越少。 另一方面，因为优化器跳过了一些计划，所以可能会错过找到最佳计划。 优化程序相对于其计算的计划数量的行为可以使用两个系统变量进行控制： 该optimizer_prune_level 变量告诉优化器根据每个表访问的行数的估计值跳过某些计划。 我们的经验表明，这种“ 受过教育的猜测 ”很少会错过最佳计划，并且可能大大减少查询编译时间。 这就是为什么这个选项optimizer_prune_level=1默认是on（）。 但是，如果您认为优化器错过了更好的查询计划，则可以关闭此选项（optimizer_prune_level=0）与查询编译可能花费更长时间的风险有关。 请注意，即使使用这种启发式，优化器仍然会探索大致指数级的计划。 这个optimizer_search_depth 变量告诉优化器应该看看每个不完整计划的“ 未来 ”有多远，以评估它是否应该进一步扩展。 较小的值 optimizer_search_depth可能会导致查询编译时间缩短几个数量级。 例如，如果optimizer_search_depth接近查询中的表的数量，具有12,13或更多表的查询可能很容易需要数小时甚至数天来编译 。 同时，如果编译一下 optimizer_search_depth 等于3或4，优化器可以在不到一分钟的时间内编译相同的查询。 如果您不确定合理的值是什么 optimizer_search_depth，则可以将此变量设置为0，以通知优化器自动确定该值。  8.9.2优化器提示
控制优化器策略的一种方法是设置 optimizer_switch系统变量（参见第8.9.3节“可切换优化”）。 对此变量的更改影响所有后续查询的执行; 为了对另一个查询产生不同的影响，有必要optimizer_switch在每个查询之前进行更改 。 另一种控制优化器的方式是使用优化器提示，它可以在单个语句中指定。 由于优化器提示适用于每个语句的基础上，因此它们提供了对语句执行计划的更好的控制，而不是使用的方式 optimizer_switch。 例如，您可以在语句中为一个表启用优化，并禁用针对其他表的优化。 语句中的提示优先于 optimizer_switch标志。 例子： SELECT / * + NO_RANGE_OPTIMIZATION（t3 PRIMARY，f2_idx）* / f1 FROM t3 where f1&amp;gt; 30 AND f1 &amp;lt;33; SELECT / * + BKA（t1）NO_BKA（t2）* / *从t1 INNER JOIN t2 WHERE .</description>
    </item>
    
    <item>
      <title>SQL优化【线程信息检查】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-thread/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-thread/</guid>
      <description>8.14.1线程命令值 8.14.2一般线程状态 8.14.3查询缓存线程状态 8.14.4复制主线程状态 8.14.5复制从站I / O线程状态 8.14.6复制从属SQL线程状态 8.14.7复制从站连接线程状态 8.14.8 NDB集群线程状态 8.14.9事件调度程序线程状态
当您试图确定MySQL服务器正在做什么时，检查进程列表会很有帮助，进程列表是当前在服务器中执行的线程集。可从以下来源获取流程列表信息：
该SHOW [FULL] PROCESSLIST语句： 第13.7.5.29，“SHOW PROCESSLIST语法”
该SHOW PROFILE语句： 第13.7.5.31，“显示配置文件语法”
该INFORMATION_SCHEMA PROCESSLIST表： 第24.17，“该INFORMATION_SCHEMA PROCESSLIST表”
在中mysqladmin processlist的命令： 第4.5.2节“ 中mysqladmin -客户端管理MySQL服务器”
性能模式threads 表，阶段表和锁定表： 第25.11.16节“性能模式杂项表”， 第25.11.5节“性能模式阶段事件表”， 第25.11.12节“性能模式锁定表”。
该sys架构 processlist视图，呈现从性能架构信息 threads表中更方便的格式：第26.4.3.22，“ProcessList中和X $ PROCESSLIST意见”
该sys架构 session视图，其中介绍有关用户会话的信息（如 sys架构 processlist视图，但是过滤掉后台进程）： 第26.4.3.33，“会议和X $会话视图”
访问threads不需要互斥锁，对服务器性能的影响最小。 INFORMATION_SCHEMA.PROCESSLIST并且SHOW PROCESSLIST因为它们需要互斥锁而 产生负面的性能影响。 threads还显示有关后台线程的信息，有哪些 INFORMATION_SCHEMA.PROCESSLIST， SHOW PROCESSLIST有时没有。这意味着threads可以用来监视其他线程信息源不能的活动。
您始终可以查看有关自己的线程的信息。要查看有关正在为其他帐户执行的线程的信息，您必须具有该PROCESS权限。
每个进程列表条目包含几条信息：
Id 是与线程关联的客户端的连接标识符。
User并Host指明与该线程关联的帐户。
db是线程的默认数据库，或者NULL如果没有选择。
Command并State 指出线程正在做什么。
大多数州对应于非常快速的操作。如果一个线程停留在给定状态很多秒，则可能存在需要调查的问题。
Time表示线程处于当前状态的时间。在某些情况下，线程的当前时间概念可能会改变：线程可以改变时间。对于正在处理来自主站的事件的从站上运行的线程，线程时间设置为在事件中找到的时间，因此反映了主站而不是从站的当前时间。 SET TIMESTAMP = value
Info包含线程正在执行的语句的文本，或者NULL它是否正在执行。默认情况下，此值仅包含语句的前100个字符。要查看完整的语句，请使用 SHOW FULL PROCESSLIST。</description>
    </item>
    
    <item>
      <title>SQL优化【绩效衡量】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-performance-measurement/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-performance-measurement/</guid>
      <description>8.13.1测量表达式和函数的速度 8.13.2使用您自己的基准 8.13.3使用performance_schema测量绩效 要衡量绩效，请考虑以下因素：
无论您是在安静系统上测量单个操作的速度，还是在一段时间内如何操作一组操作（ “ 工作负载 ”）。通过简单的测试，您通常可以测试更改一个方面（配置设置，表上的索引集，查询中的SQL子句）如何影响性能。基准测试通常是长时间运行和精心设计的性能测试，其结果可能决定硬件和存储配置等高级选择，或者升级到新MySQL版本的时间。
对于基准测试，有时您必须模拟繁重的数据库工作负载才能获得准确的图像。
表现可能会因许多不同的因素而有所不同，因为几个百分点的差异可能不是决定性的胜利。在不同的环境中进行测试时，结果可能会发生相反的变化。
某些MySQL功能根据工作负载提供帮助或无法帮助提高性能。为了完整性，请始终在打开和关闭这些功能的情况下测试性能。尝试与每个工作负载的两个最重要的功能是 MySQL查询缓存，以及 适应性的散列索引的InnoDB表。
本节从单个开发人员可以执行的简单和直接测量技术发展到需要额外专业知识来执行和解释结果的更复杂测量技术。
8.13.1测量表达式和函数的速度 要测量特定MySQL表达式或函数的速度，请BENCHMARK()使用mysql客户端程序调用该函数。它的语法是 。返回值始终为零，但mysql 打印一行显示语句执行的时间。例如： BENCHMARK(loop_count,expression)
MySQL的&amp;gt; SELECT BENCHMARK(1000000,1+1); + &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; + | 基准（1000000,1 + 1）| + &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; + | 0 | + &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; + 1排（0.32秒） 该结果在Pentium II 400MHz系统上获得。它表明MySQL可以在0.32秒内在该系统上执行1,000,000个简单的加法表达式。
内置的MySQL函数通常是高度优化的，但可能有一些例外。 BENCHMARK()是一个很好的工具，可以找出某些功能是否是您的查询的问题。
8.13.2使用您自己的基准 对您的应用程序和数据库进行基准测试，以找出瓶颈所在。在修复一个瓶颈（或者用“ 虚拟 ”模块替换它）之后，您可以继续识别下一个瓶颈。即使您的应用程序的整体性能目前是可接受的，您至少应该为每个瓶颈制定计划，并决定如果有一天您真的需要额外的性能，如何解决它。
免费的基准测试套件是开源数据库基准测试，可从http://osdb.sourceforge.net/获得。
仅在系统负载很重时才会出现问题。我们有许多客户在生产（已测试）系统并遇到负载问题时与我们联系。在大多数情况下，性能问题可能是由于基本数据库设计问题（例如，高负载下的表扫描不好）或操作系统或库的问题。大多数情况下，如果系统尚未投入生产，这些问题将更容易解决。
为了避免这样的问题，在最糟糕的负载下对整个应用程序进行基准测试：
该mysqlslap程序可以是用于模拟由多个客户端同时发出查询产生的高负载有帮助的。请参见第4.5.9节“ mysqlslap - 加载仿真客户端”。
您还可以尝试使用基准测试程序包，例如SysBench和DBT2，可在 https://launchpad.net/sysbench和 http://osdldbt.sourceforge.net/#dbt2获得。
这些程序或软件包可以使系统瘫痪，因此请务必仅在开发系统上使用它们。</description>
    </item>
    
    <item>
      <title>SQL优化【缓存优化】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-cached/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-cached/</guid>
      <description>8.10.1 InnoDB缓冲池优化 8.10.2 MyISAM密钥缓存 8.10.3 MySQL查询缓存 8.10.4准备好的语句和存储程序的缓存 MySQL使用几种策略来缓存内存缓冲区中的信息以提高性能。
8.10.1 InnoDB缓冲池优化 InnoDB维护一个称为缓冲池的存储区域， 用于缓存内存中的数据和索引。知道InnoDB缓冲池如何 工作，并利用它来将频繁访问的数据保存在内存中，是MySQL调优的一个重要方面。
有关InnoDB缓冲池内部工作原理的说明， LRU替换算法的概述以及常规配置信息，请参见第14.6.3.1节“InnoDB缓冲池”。
有关其他InnoDB缓冲池配置和调整信息，请参阅以下部分：
第14.6.3.5节“配置InnoDB缓冲池预取（预读）”
第14.6.3.6节“配置InnoDB缓冲池刷新”
第14.6.3.4节“使缓冲池扫描抗性”
第14.6.3.3节“配置多个缓冲池实例”
第14.6.3.8节“保存和恢复缓冲池状态”
第14.6.3.7节“微调InnoDB缓冲池刷新”
第14.6.3.2节“配置InnoDB缓冲池大小”
8.10.2 MyISAM密钥缓存 8.10.2.1共享密钥缓存访问 8.10.2.2多个密钥缓存 8.10.2.3中点插入策略 8.10.2.4索引预加载 8.10.2.5密钥缓存块大小 8.10.2.6重构密钥缓存 为了最小化磁盘I / O，MyISAM存储引擎利用许多数据库管理系统使用的策略。它采用缓存机制将最常访问的表块保存在内存中：
对于索引块，维护称为密钥缓存（或 密钥缓冲区）的特殊结构 。该结构包含许多块缓冲区，其中放置了最常用的索引块。
对于数据块，MySQL不使用特殊缓存。相反，它依赖于本机操作系统文件系统缓存。
本节首先介绍MyISAM密钥缓存的基本操作 。然后讨论了可以提高密钥缓存性能并使您能够更好地控制缓存操作的功能：
多个会话可以同时访问缓存。
您可以设置多个密​​钥缓存并将表索引分配给特定缓存。
要控制密钥缓存的大小，请使用 key_buffer_size系统变量。如果将此变量设置为零，则不使用密钥缓存。如果key_buffer_size值太小而无法分配最小数量的块缓冲区，则不使用密钥缓存 （8）。
当密钥缓存不可操作时，仅使用操作系统提供的本机文件系统缓冲来访问索引文件。（换句话说，使用与表数据块相同的策略访问表索引块。）
索引块是对MyISAM索引文件的连续访问单元 。通常，索引块的大小等于索引B树的节点大小。（索引在磁盘上使用B树数据结构表示。树底部的节点是叶节点。叶节点上方的节点是非叶节点。）
密钥缓存结构中的所有块缓冲区大小相同。该大小可以等于，大于或小于表索引块的大小。通常这两个值中的一个是另一个的倍数。
当必须访问来自任何表索引块的数据时，服务器首先检查它是否在密钥缓存的某个块缓冲区中可用。如果是，则服务器访问密钥缓存中的数据而不是磁盘上的数据。也就是说，它从缓存读取或写入其中而不是读取或写入磁盘。否则，服务器选择包含不同表索引块（或块）的高速缓存块缓冲区，并用必需的表索引块的副本替换那里的数据。只要新索引块位于缓存中，就可以访问索引数据。
如果发生了选择替换的块已被修改，则该块被认为是“ 脏的。“在这种情况下，在被替换之前，其内容被刷新到它所来自的表索引。
通常服务器遵循LRU（最近最少使用）策略：当选择要替换的块时，它选择最近最少使用的索引块。为了使这个选择更容易，密钥缓存模块将所有使用的块维护在按使用时间排序的特殊列表（LRU链）中。访问块时，它是最近使用的块，位于列表的末尾。当需要替换块时，列表开头的块是最近最少使用的块，并成为第一个驱逐的候选块。
该InnoDB存储引擎还采用LRU算法来管理它的缓冲池。请参见 第14.6.3.1节“InnoDB缓冲池”。
8.10.2.1共享密钥缓存访问 线程可以同时访问密钥缓存缓冲区，但要符合以下条件：
多个会话可以访问未更新的缓冲区。
正在更新的缓冲区会导致需要使用它的会话等待更新完成。
多个会话可以发起导致高速缓存块替换的请求，只要它们不相互干扰（即，只要它们需要不同的索引块，从而导致不同的高速缓存块被替换）。
对密钥缓存的共享访问使服务器能够显着提高吞吐量。
8.10.2.2多个密钥缓存 对密钥缓存的共享访问可提高性能，但不会完全消除会话之间的争用。他们仍在竞争管理对密钥缓存缓冲区的访问的控制结构。为了进一步减少密钥缓存访问争用，MySQL还提供了多个密钥缓存。此功能使您可以将不同的表索引分配给不同的密钥缓存。
在存在多个密钥缓存的情况下，服务器必须知道在处理给定MyISAM表的查询时要使用哪个缓存 。默认情况下，所有 MyISAM表索引都缓存在默认密钥缓存中。要将表索引分配给特定的键缓存，请使用该CACHE INDEX 语句（请参见第13.7.6.2节“CACHE INDEX语法”）。例如，下面的语句从表中分配指标 t1，t2以及 t3名为键缓存 hot_cache：</description>
    </item>
    
    <item>
      <title>SQL优化【锁优化】</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-lock/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-lock/</guid>
      <description>MySQL使用锁管理对表内容的争用 ：
内部锁定在MySQL服务器内部执行，以管理多个线程对表内容的争用。 这种类型的锁定是内部的，因为它完全由服务器执行，并且不涉及其他程序。 参见 第8.11.1节“内部锁定方法”。
当服务器和其他程序锁定MyISAM表文件以相互协调哪个程序可以访问表时，发生外部锁定。 参见第8.11.5节“外部锁定”。
8.11.1内部锁定方法
本节讨论内部锁定; 即在MySQL服务器本身内执行锁定以管理多个会话对表内容的争用。 这种类型的锁定是内部的，因为它完全由服务器执行，并且不涉及其他程序。 对于其他程序在MySQL文件上执行的锁定，请参见第8.11.5节“外部锁定”。 行级锁定 表级锁定 选择锁定类型 行级锁定 MySQL使用行级锁定为InnoDB表，以支持由多个会话并发写入权限，使其适用于多用户，高并发，和OLTP应用程序。 为了避免在单个表上执行多个并发写入操作时发生死锁， InnoDB通过SELECT ... FOR UPDATE为每组预计要修改的行发布语句，即使数据更改语句稍后在事务中发生，也可以在事务启动时获取必要的锁。 如果交易修改或锁定多个表，请在每个交易中以相同的顺序发布适用的报表。 死锁会影响性能而不是表示严重的错误，因为它会 InnoDB自动 检测 死锁条件并回滚其中一个受影响的事务。 在高并发系统上，当大量线程等待相同的锁时，死锁检测会导致速度下降。 有时候，innodb_lock_wait_timeout 当死锁发生时，禁用死锁检测并依赖事务回滚的设置可能更有效 。 使用innodb_deadlock_detect 配置选项可以禁用死锁检测 。 行级锁定的优点： 当不同的会话访问不同的行时，更少的锁冲突。 回滚更少。 可能长时间锁定一行。 表级锁定 MySQL使用表级锁的MyISAM， MEMORY和MERGE 表，只允许一个会话更新一次这些表。 这种锁定级别使得这些存储引擎更适合于只读，主要读取或单用户应用程序。 这些存储引擎通过始终在查询开始时一次请求所有需要的锁，并始终以相同的顺序锁定表来避免 死锁。 权衡是这种策略降低了并发性; 其他要修改表的会话必须等到当前数据更改语句结束。 表级锁定的优点： 所需的内存相对较少（行锁定需要锁定每行或一组行的内存） 在大部分表格上使用时都很快，因为只涉及一个锁。 如果您经常GROUP BY 对大部分数据执行操作，或者必须频繁扫描整个表，则速度很快。 MySQL授予表写入锁定如下： 如果表上没有锁，请在其上写入锁。 否则，将锁定请求放入写入锁定队列中。 MySQL授予表读取锁定如下： 如果表上没有写入锁，请在其上放置一个读取锁。 否则，将锁定请求放入读锁定队列中。 表格更新优先于表格检索。 因此，当释放一个锁时，该锁可用于写入锁定队列中的请求，然后可用于读取锁定队列中的请求。 这确保了即使桌子上有大量活动时，表格的更新也不会“ 饿死 ”SELECT。 但是，如果有多个表的更新，则 SELECT语句会等待，直到没有更新。 有关更改读取和写入优先级的信息，请参见第8.11.2节“表锁定问题”。 您可以通过检查Table_locks_immediate和 Table_locks_waited状态变量来分析系统上的表锁争用 ，这些变量分别表示可以立即授予表锁请求的次数和需要等待的数量： MySQL的&amp;gt; SHOW STATUS LIKE &#39;Table%&#39;; + ----------------------- + --------- + | 变量名| 值| + ----------------------- + --------- + | Table_locks_immediate | 1151552 | | Table_locks_waited | 15324 | + ----------------------- + --------- + 性能模式锁定表还提供锁定信息。 请参见 第25.</description>
    </item>
    
    <item>
      <title>常见MYSQL调优策略</title>
      <link>http://wuxinvip.github.io/blog/mysql/optimization-sql-total-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/mysql/optimization-sql-total-2/</guid>
      <description>调优层次：硬件层、磁盘IO、文件系统层、
硬件层
修改服务器BIOS设置 1.选择Performance Per Watt Optimized(DAPC)模式 、发挥cpu最大性能 2.Memory Frequency(内存频率)选择 Maximum Performance (最佳性能) 3.内存设置菜单中，启用Node Interleaving 避免NUMA问题  磁盘IO
1.使用SSD磁盘(瞬时写入非常高、还可以避免很多技术问题) 2.如果是磁盘阵列存储，建议阵列卡同时配备CACHE及BBU模块，可以明显提升IOPS。 3.raid级别尽量选择raid10.而不是raid5(双io方式、也能提高安全性等等)  文件系统层
1.使用deadline/noop这两种I/O调度器。千万别用cfq 2.使用xfs文件系统、千万别用ext3、ext4勉强可用、但是事务量很大一定要用xfs 3.文件系统mount参数中增加：noatime，nodiratime，nobarrier几个选项(nobarrier是xfs文件系统特有的)  内核参数优化
1.修改vm.swappiness参数，降低swap使用率，RHEL7/centos7以上则慎重设置为0，可能引发OOM(物理内存使用到了90%之后才去修改、设为5-10就可以) 2.调整vm.dirty_background_ratio(脏数据量占内存量百分比、超过后将脏数据刷到磁盘、最大值（阻塞写）10%)、vm.dirty ratio(标准值（非阻塞写）5%) 内核参数、以确保能持续将脏数据刷新到磁盘，避免瞬I/O写，产生等待。 3.调整net.ipv4.tcp_tw_recycle、net.ipv4.tcp_tw_reuse都设置为1、减少Time_wait,提高TCP效率  MYSQL参数优化建议</description>
    </item>
    
  </channel>
</rss>