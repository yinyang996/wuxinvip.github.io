
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>无心技术簿  | SQL优化【查询器优化·二】</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">

    
    <meta name="sogou_site_verification" content="OYyzP0Cdur"/>
    
    <meta name="baidu_union_verify" content="809cdfb6c64fa651335f2075e055a2e6">
    
    <meta name="baidu-site-verification" content="Vm6jkM9VW0" />
    
    
      
    <link href='/dist/css/app.8e831b6359bad500b66d8214096381de.css' rel='stylesheet' type="text/css" data-turbolinks-track="reload" />
      
    <link href='/dist/css/search.css' rel='stylesheet' type="text/css" data-turbolinks-track="reload" />
      
    

    
      
    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />


    

    

    

    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-8547276212175642",
            enable_page_level_ads: true
        });
    </script>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  


  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
        <div class="flex-l justify-between items-center center" >
          <a href="https://wuxinvip.github.io/" style="font-family:kaiti"class="f3 fw2 hover-white no-underline white-90 dib">
            无心技术簿
          </a>
          
          <div class="flex-3 items-end">
            
              <ul class="flex-l justify-between items-center center">
                <li class="list f5 f5-ns fw4 dib pr3">
                <a class="hover-white no-underline white-90" href="/blog/" title="咖啡系列">
                  咖啡系列
                </a>
                </li>
                <li class="list f5 f5-ns fw4 dib pr3">
                  <a class="hover-white no-underline white-90" href="http://search.wuxinvip.com/" title="万站灯火家">
                    万站灯火家
                  </a>
                </li>
              </ul>
            
          </div>
        </div>
    
    <div class="webdesigntuts-workshop"><input id="aa-search-input"  type="search" placeholder="搜索..." name="search" autocomplete="off"></div>

<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("SC89XM72DY", "576959787929fc9893d43b70124b49cd");
    var index = client.initIndex('wuxinvip');
    autocomplete('#aa-search-input',
        { hint: false}, {
            source: autocomplete.sources.hits(index, {hitsPerPage: 8}),
            displayKey: 'name',
            templates: {
                suggestion: function(suggestion) {
                    console.log(suggestion);
                    return '<span  class="webdesigntuts-span">' +
                        '<a class="webdesigntuts-a" href="/' + suggestion.uri + '">' +
                        suggestion.title + '</a></span><br/>';
                }
            }
        });
</script>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <article class="flex-l flex-wrap justify-between mw10 center">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        咖啡系列
      </p>
      <h1 class="f1 athelas mb1">SQL优化【查询器优化·二】</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2018-03-24T00:00:00Z">March 24, 2018</time>
    </header>

    <main class="nested-copy-line-height lh-copy serif f5 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p><img src="https://upload-images.jianshu.io/upload_images/6434888-6fd8630f76bf000c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" /></p>

<p>8.9.1控制查询计划评估</p>

<pre><code>查询优化器的任务是查找执行SQL查询的最佳计划。
由于“ 好 ”和“ 坏 ”之间的表现差异计划可以是数量级（即秒数与数小时甚至数天），
    大多数查询优化器（包括MySQL的查询优化器）在所有可能的查询评估计划中执行或多或少的穷举搜索优化计划。
    对于连接查询，由MySQL优化器调查的可能计划的数量随着查询中引用的表的数量呈指数增长。
    对于少量表格（通常小于7到10），这不是问题。
    但是，当提交更大的查询时，查询优化花费的时间可能很容易成为服务器性能的主要瓶颈。


用于查询优化的更灵活的方法使用户能够控制优化器在搜索最优查询评估计划时的详尽程度。
总体思路是，优化程序调查的计划越少，编译查询花费的时间就越少。
另一方面，因为优化器跳过了一些计划，所以可能会错过找到最佳计划。


优化程序相对于其计算的计划数量的行为可以使用两个系统变量进行控制：

该optimizer_prune_level 变量告诉优化器根据每个表访问的行数的估计值跳过某些计划。
我们的经验表明，这种“ 受过教育的猜测 ”很少会错过最佳计划，并且可能大大减少查询编译时间。
这就是为什么这个选项optimizer_prune_level=1默认是on（）。
但是，如果您认为优化器错过了更好的查询计划，则可以关闭此选项（optimizer_prune_level=0）与查询编译可能花费更长时间的风险有关。
请注意，即使使用这种启发式，优化器仍然会探索大致指数级的计划。


这个optimizer_search_depth 变量告诉优化器应该看看每个不完整计划的“ 未来 ”有多远，以评估它是否应该进一步扩展。
较小的值 optimizer_search_depth可能会导致查询编译时间缩短几个数量级。
例如，如果optimizer_search_depth接近查询中的表的数量，具有12,13或更多表的查询可能很容易需要数小时甚至数天来编译 。
同时，如果编译一下 optimizer_search_depth 等于3或4，优化器可以在不到一分钟的时间内编译相同的查询。
如果您不确定合理的值是什么 optimizer_search_depth，则可以将此变量设置为0，以通知优化器自动确定该值。

</code></pre>

<p>8.9.2优化器提示</p>

<pre><code>控制优化器策略的一种方法是设置 optimizer_switch系统变量（参见第8.9.3节“可切换优化”）。
对此变量的更改影响所有后续查询的执行; 为了对另一个查询产生不同的影响，有必要optimizer_switch在每个查询之前进行更改 。


另一种控制优化器的方式是使用优化器提示，它可以在单个语句中指定。
由于优化器提示适用于每个语句的基础上，因此它们提供了对语句执行计划的更好的控制，而不是使用的方式 optimizer_switch。
例如，您可以在语句中为一个表启用优化，并禁用针对其他表的优化。
语句中的提示优先于 optimizer_switch标志。


例子：

SELECT / * + NO_RANGE_OPTIMIZATION（t3 PRIMARY，f2_idx）* / f1
  FROM t3 where f1&gt; 30 AND f1 &lt;33;
SELECT / * + BKA（t1）NO_BKA（t2）* / *从t1 INNER JOIN t2 WHERE ...;
SELECT / * + NO_ICP（t1，t2）* / * FROM t1 INNER JOIN t2 WHERE ...;
SELECT / * + SEMIJOIN（FIRSTMATCH，LOOSESCAN）* / * FROM t1 ...;
EXPLAIN SELECT / * + NO_ICP（t1）* / * FROM t1 WHERE ...;
注意
默认情况下 ，mysql客户端从发送到服务器的SQL语句（包括优化器提示）中删除注释，直到MySQL 5.7.7更改为将优化器提示传递给服务器。
为了确保如果您使用旧版本的mysql客户端与理解优化器提示的服务器版本，优化器提示不会被剥离，请使用 该 选项调用 mysql--comments。


此处介绍的优化器提示与第8.9.4节“索引提示”中介绍的索引提示有所不同。
优化器和索引提示可以单独使用或一起使用。


优化器提示概述

优化器提示语法

表级优化器提示

索引级优化器提示

子查询优化器提示

语句执行时间优化器提示

用于命名查询块的优化器提示

优化器提示概述
优化器提示适用于不同的范围级别：

全局：提示影响整个陈述

查询块：提示影响语句中的特定查询块

表级别：提示影响查询块中的特定表

索引级别：提示影响表格中的特定索引

下表总结了可用的优化器提示，它们影响的优化器策略以及它们所应用的范围。
更多细节在后面给出。


表8.2可用的优化器提示

提示名称    描述  适用范围
BKA， NO_BKA 影响批量键访问连接处理 查询块，表
BNL， NO_BNL 影响块嵌套循环连接处理 查询块，表
MAX_EXECUTION_TIME  限制语句执行时间    全球
MRR， NO_MRR 影响多范围读取优化   表，索引
NO_ICP  影响索引条件下推优化  表，索引
NO_RANGE_OPTIMIZATION   影响范围优化  表，索引
QB_NAME 将名称分配给查询块   查询块
SEMIJOIN， NO_SEMIJOIN   影响半连接策略 查询块
SUBQUERY    影响物化， IN至- EXISTS 子查询配置的对策探讨    查询块

禁用优化可防止优化器使用它。
启用优化意味着如果优化程序适用于语句执行，则可以自由使用策略，而不是优化程序必须使用它。


优化器提示语法
如第9.6节“注释语法”中所述，MySQL支持SQL语句中的 注释。
优化器提示必须在/*+ ... */注释中指定。
也就是说，优化器提示使用/* ... */ C样式注释语法的变体，并+在/*注释打开序列后面加上一个字符。
例子：

/ * + BKA（t1）* /
/ * + BNL（t1，t2）* /
/ * + NO_RANGE_OPTIMIZATION（t4 PRIMARY）* /
/ * + QB_NAME（qb2）* /
在+ 字符后面允许使用空格。


分析器的初始关键字后承认优化提示意见SELECT， UPDATE， INSERT， REPLACE，和 DELETE语句。
在这些情况下允许提示：

在查询和数据更改语句的开始处：

SELECT / * + ... * / ...
INSERT / * + ... * / ...
REPLACE / * + ... * / ...
UPDATE / * + ... * / ...
删除/ * + ... * / ...
在查询块的开始处：

（SELECT / * + ... * / ...）
（SELECT ...）UNION（SELECT / * + ... * / ...）
（SELECT / * + ... * / ...）UNION（SELECT / * + ... * / ...）
UPDATE ... WHERE x IN（SELECT / * + ... * / ...）
INSERT ... SELECT / * + ... * / ...
在由...开头的暗示性陈述中 EXPLAIN。
例如：

EXPLAIN SELECT / * + ... * / ...
EXPLAIN UPDATE ... WHERE x IN（SELECT / * + ... * / ...）
这意味着您可以使用它 EXPLAIN来查看优化器提示如何影响执行计划。
SHOW WARNINGS之后立即使用 EXPLAIN，看看如何使用提示。
EXPLAIN 以下SHOW WARNINGS显示的扩展输出指示使用了哪些提示。
不显示忽略的提示。


提示注释可能包含多个提示，但查询块不能包含多个提示注释。
这是有效的：

SELECT / * + BNL（t1）BKA（t2）* / ...
但这是无效的：

SELECT / * + BNL（t1）* / / * BKA（t2）* / ...
当提示注释包含多个提示时，存在重复和冲突的可能性。
以下一般准则适用。
对于特定的提示类型，可能会应用其他规则，如提示说明中所述。


重复提示：对于一个提示，如/*+ MRR(idx1) MRR(idx1) */MySQL使用第一个提示并发出关于重复提示的警告。


冲突提示：对于一个提示，如/*+ MRR(idx1) NO_MRR(idx1) */MySQL使用第一个提示并发出关于第二个冲突提示的警告。


查询块名称是标识符，并遵循关于哪些名称有效以及如何引用它们的通用规则（请参见 第9.2节“模式对象名称”）。


提示名称，查询块名称和策略名称不区分大小写。
对表和索引名称的引用遵循通常的标识符区分大小写规则（请参见 第9.2.2节“标识符区分大小写”）。


表级优化器提示
表级提示影响使用块嵌套循环（BNL）和（BKA）成批键访问的加入处理算法（参见 第8.2.1.11，“块嵌套循环和成批键访问联接”）。
这些提示类型适用于特定表或查询块中的所有表。


表级提示的语法：

hint_name（[@ query_block_name] [ tbl_name[，tbl_name] ...]）
 hint_name（[ tbl_name@ query_block_name[，tbl_name@ query_block_name] ...]）
语法引用了这些术语：

hint_name：这些提示名称是允许的：

BKA，NO_BKA：为指定的表启用或禁用BKA。


BNL，NO_BNL：启用或禁用指定表的BNL。


注意
要使用BNL或BKA提示为外连接的任何内部表启用连接缓冲，必须为外连接的所有内部表启用连接缓冲。


tbl_name：声明中使用的表的名称。
该提示适用于它命名的所有表。
如果提示不命名表，它将应用于它发生的查询块的所有表。


如果表有别名，提示必须引用别名，而不是表名。


提示中的表名称不能用模式名称限定。


query_block_name：提示适用的查询块。
如果提示不包含前导 ，则该提示将应用于其发生的查询块。
对于 语法，该提示适用于指定查询块中的指定表。
要为查询块分配名称，请参阅 命名查询块的优化器提示。
 @query_block_nametbl_name@query_block_name

例子：

SELECT / * + NO_BKA（t1，t2）* / t1。
* FROM t1 INNER JOIN t2 INNER JOIN t3;
SELECT / * + NO_BNL（）BKA（t1）* / t1。
* FROM t1 INNER JOIN t2 INNER JOIN t3;
表级提示适用于从前面的表中接收记录的表，而不是发送者表。
考虑这个说法：

SELECT / * + BNL（t2）* / FROM t1，t2;
如果优化器选择t1 首先进行处理，则会在开始读取之前 t2通过缓冲行来 应用块嵌套循环连接 。
如果优化器选择首先处理，则提示不起作用，因为是发送者表。
 t1t2t2t2

索引级优化器提示
索引级提示会影响优化程序对特定表或索引使用的索引处理策略。
这些提示类型影响使用索引条件下推（ICP），多范围读取（MRR）和范围优化（请参见 第8.2.1节“优化SELECT语句”）。


索引级提示的语法：

hint_name（[@ query_block_name] tbl_name[ index_name[，index_name] ...]）
 hint_name（tbl_name@ query_block_name[ index_name[，index_name] ...]）
语法引用了这些术语：

hint_name：这些提示名称是允许的：

MRR，NO_MRR：启用或禁用指定表或索引的MRR。
MRR提示仅适用于 表格InnoDB和 MyISAM表格。


NO_ICP：为指定的表或索引禁用ICP。
默认情况下，ICP是一个候选优化策略，所以没有启用它的提示。


NO_RANGE_OPTIMIZATION：禁用指定表或索引的索引范围访问。
此提示还会禁用索引合并和索引扫描以查找表或索引。
默认情况下，范围访问是一个候选优化策略，所以没有启用它的提示。


当范围数可能很高并且范围优化需要许多资源时，这个提示可能是有用的。


tbl_name：提示适用的表格

index_name：指定表中索引的名称。
该提示适用于它命名的所有索引。
如果提示不命名索引，则它适用于表中的所有索引。


要引用主键，请使用该名称 PRIMARY。
要查看表格的索引名称，请使用SHOW INDEX。


query_block_name：提示适用的查询块。
如果提示不包含前导 ，则该提示将应用于其发生的查询块。
对于 语法，该提示适用于指定查询块中的指定表。
要为查询块分配名称，请参阅 命名查询块的优化器提示。
 @query_block_nametbl_name@query_block_name

例子：

SELECT / * + MRR（t1）* / * FROM t1 WHERE f2 &lt;= 3 AND 3 &lt;= f3;
SELECT / * + NO_RANGE_OPTIMIZATION（t3 PRIMARY，f2_idx）* / f1
  FROM t3 where f1&gt; 30 AND f1 &lt;33;
INSERT INTO t3（f1，f2，f3）
  （SELECT / * + NO_ICP（t2）* / t2.f1，t2.f2，t2.f3 FROM t1，t2
   WHERE t1.f1 = t2.f1 AND t2.f2 BETWEEN t1.f1
   AND t1.f2 AND t2.f2 + 1&gt; = t1.f1 + 1）;
子查询优化器提示
子查询提示影响是否使用半连接的转换和半连接策略允许，而当半联接未使用，是否使用子查询物化或 IN至- EXISTS 变换。
有关这些优化的更多信息，请参见第8.2.2节“优化子查询，派生表和视图引用”。


影响半连接策略的提示语法：

hint_name（[@ query_block_name] [ strategy[，strategy] ...]）
语法引用了这些术语：

hint_name：这些提示名称是允许的：

SEMIJOIN， NO_SEMIJOIN：启用或禁用指定的半连接策略。


strategy：启用或禁用半连接策略。
这些策略名允许：DUPSWEEDOUT， FIRSTMATCH， LOOSESCAN， MATERIALIZATION。


对于SEMIJOIN提示，如果未命名策略，则根据optimizer_switch系统变量启用的策略，尽可能使用半连接 。
如果战略被命名但不适用于该声明，DUPSWEEDOUT则会被使用。


对于NO_SEMIJOIN提示，如果没有策略被命名，则不使用半连接。
如果策略被命名为排除声明的所有适用策略，DUPSWEEDOUT则使用该策略 。


如果一个子查询嵌套在另一个子查询中，并且两者都合并到外部查询的半连接中，则最内层查询的任何半连接策略规范都将被忽略。
 SEMIJOIN并且NO_SEMIJOIN 仍然可以使用提示来启用或禁用此类嵌套子查询的半连接转换。


如果DUPSWEEDOUT被禁用，则有时优化器可能会生成一个远离最佳状态的查询计划。
这发生在贪婪搜索期间的启发式修剪，可以通过设置来避免 optimizer_prune_level=0。


例子：

SELECT / * + NO_SEMIJOIN（@ subq1 FIRSTMATCH，LOOSESCAN）* / *从t2
  WHERE t2.a IN（SELECT / * + QB_NAME（subq1）* / a FROM t3）;
SELECT / * + SEMIJOIN（@ subq1 MATERIALIZATION，DUPSWEEDOUT）* / *从t2开始
  WHERE t2.a IN（SELECT / * + QB_NAME（subq1）* / a FROM t3）;
影响是否使用子查询实现或IN-to- EXISTS 转换的提示语法 ：

SUBQUERY（[@ query_block_name] strategy）
提示名称总是SUBQUERY。


对于SUBQUERY提示，这些 strategy值是允许的： INTOEXISTS， MATERIALIZATION。


例子：

SELECT id，IN（SELECT / * + SUBQUERY（MATERIALIZATION）* / a FROM t1）FROM t2;
SELECT * FROM t2 WHERE t2.a IN（SELECT / * + SUBQUERY（INTOEXISTS）* / a FROM t1）;
对于半连接和SUBQUERY提示，前导 指定提示适用的查询块。
如果提示不包含前导 ，则该提示将应用于其发生的查询块。
要为查询块分配名称，请参阅 命名查询块的优化器提示。
 @query_block_name@query_block_name

如果提示注释包含多个子查询提示，则使用第一个。
如果还有其他类型的提示，则会发出警告。
其他类型的提示被默默忽略。


语句执行时间优化器提示
该MAX_EXECUTION_TIME提示仅适用于SELECT语句。
它N在语句允许在服务器终止之前执行多长时间内放置一个限制（以毫秒为单位的超时值）：

MAX_EXECUTION_TIME（N）
超时时间为1秒（1000毫秒）的示例：

SELECT / * + MAX_EXECUTION_TIME（1000）* / *从t1 INNER JOIN t2 WHERE ...
该 提示设置了毫秒的语句执行超时 。
如果此选项不存在或为0，则由系统变量建立的语句超时 适用。
 MAX_EXECUTION_TIME(N)NNmax_execution_time

该MAX_EXECUTION_TIME提示适用如下：

对于具有多个SELECT 关键字的语句（例如具有子查询的联合或语句） MAX_EXECUTION_TIME适用于整个语句，并且必须出现在第一个语句之后 SELECT。


它适用于只读 SELECT语句。
不是只读的语句是那些调用一个存储函数，将数据修改为副作用的语句。


它不适用于SELECT 存储程序中的语句，并且被忽略。


用于命名查询块的优化器提示
表级别，索引级别和子查询优化器提示允许将特定查询块命名为其参数语法的一部分。
要创建这些名称，请使用 QB_NAME提示，它为其发生的查询块分配一个名称：

QB_NAME（name）
QB_NAME提示可以用来清楚地明确哪些查询块适用于其他提示。
它们还允许在单个提示注释中指定所有非查询块名称提示，以便于理解复杂语句。
考虑以下声明：

选择 ...
  FROM（SELECT ...
  FROM（SELECT ... FROM ...））...
QB_NAME 提示为语句中的查询块分配名称：

SELECT / * + QB_NAME（qb1）* / ...
  FROM（SELECT / * + QB_NAME（qb2）* / ...
  FROM（SELECT / * + QB_NAME（qb3）* / ... FROM ...））...
然后其他提示可以使用这些名称来引用适当的查询块：

SELECT / * + QB_NAME（qb1）MRR（@ qb1 t1）BKA（@ qb2）NO_MRR（@ qb3t1 idx1，id2）* / ...
  FROM（SELECT / * + QB_NAME（qb2）* / ...
  FROM（SELECT / * + QB_NAME（qb3）* / ... FROM ...））...
其结果如下所示：

MRR(@qb1 t1)适用t1于查询块中的 表格 qb1。


BKA(@qb2)适用于查询块 qb2。


NO_MRR(@qb3 t1 idx1, id2)适用于索引idx1和 查询块idx2中的表格。
 t1qb3

查询块名称是标识符，并遵循关于哪些名称有效以及如何引用它们的通用规则（请参见 第9.2节“模式对象名称”）。
例如，包含空格的查询块名称必须用引号引起来，这可以使用反引号来完成：

SELECT / * + BKA（@`my hint name`）* / ...
  FROM（SELECT / * + QB_NAME（`my hint name`）* / ...）...
如果ANSI_QUOTES启用了SQL模式，则也可以在双引号内引用查询块名称：

SELECT / * + BKA（@“my hint name”）* / ...
  FROM（SELECT / * + QB_NAME（“my hint name”）* / ...）...

</code></pre>

<p>8.9.3可切换优化</p>

<pre><code>
该optimizer_switch系统变量能够在优化行为的控制。
它的值是一组标志，每个标志都有一个值on 或off表示相应的优化器行为是启用还是禁用。
该变量具有全局和会话值，并且可以在运行时更改。
全局默认值可以在服务器启动时设置。


要查看当前的优化器标志集，请选择变量值：

MySQL的&gt; SELECT @@optimizer_switch\G
*************************** 1. row ******************** *******
@@ optimizer_switch：index_merge = on，index_merge_union = on，
                    index_merge_sort_union =开，
                    index_merge_intersection =开，
                    engine_condition_pushdown =开，
                    index_condition_pushdown =开，
                    MRR =开，上mrr_cost_based =，
                    block_nested_loop =开，batched_key_access =关，
                    物化=开，半连接=上，loosescan =开，
                    firstmatch =开，duplicateweedout =开，
                    subquery_materialization_cost_based =开，
                    use_index_extensions =开，
                    condition_fanout_filter =开，derived_merge =上
要更改值 optimizer_switch，请分配一个由逗号分隔的一个或多个命令列表组成的值：

SET [GLOBAL | SESSION] optimizer_switch =' command[，command] ...';
每个command值应具有下表中显示的一种形式。


命令语法    含义
default 将每个优化重置为默认值
opt_name=default    将指定的优化设置为其默认值
opt_name=off    禁用命名优化
opt_name=on 启用指定的优化
该值中的命令顺序无关紧要，但该default命令如果存在则首先执行。
一个设置opt_name标志 default设置它取的 on或者off是它的默认值。
opt_name 不允许多次指定给定的值并导致错误。
值中的任何错误都会导致分配失败，并显示错误，并使值 optimizer_switch保持不变。


以下列表描述了opt_name按优化策略分组的允许 标志名称：

批量键访问标志

batched_key_access（默认 off）

控制BKA连接算法的使用。


为了batched_key_access在设置时有任何效果on，该 mrr标志也必须是 on。
目前，MRR的成本估算过于悲观。
因此，也有必要对 mrr_cost_based要 off用于要使用的BKA。


有关更多信息，请参见 第8.2.1.11节“块嵌套循环和批处理键访问联接”。


块嵌套循环标志

block_nested_loop（默认 on）

控制使用BNL连接算法。


有关更多信息，请参见 第8.2.1.11节“块嵌套循环和批处理键访问联接”。


条件过滤标志

condition_fanout_filter（默认 on）

控制条件过滤的使用。


派生表合并标志

derived_merge（默认 on）

控制派生表和视图到外部查询块的合并。


该derived_merge标志控制优化程序是否尝试合并派生表并将引用视为外部查询块，假设没有其他规则会阻止合并; 
    例如，ALGORITHM视图的 指令优先于该derived_merge 设置。
    默认情况下，该标志on用于启用合并。


有关更多信息，请参见 第8.2.2.3节“优化派生表和视图引用”。


引擎状况下推标志

engine_condition_pushdown（默认 on）

控制发动机状况下推。


有关更多信息，请参见 第8.2.1.4节“引擎状况下推优化”。


索引条件下推标志

index_condition_pushdown（默认 on）

控制索引条件下推。


有关更多信息，请参见 第8.2.1.5节“索引条件下推优化”。


索引扩展标志

use_index_extensions（默认 on）

控制索引扩展的使用。


有关更多信息，请参见 第8.3.9节“使用索引扩展”。


索引合并标志

index_merge（默认 on）

控制所有索引合并优化。


index_merge_intersection（默认 on）

控制索引合并相交访问优化。


index_merge_sort_union（默认 on）

控制索引合并排序 - 联合访问优化。


index_merge_union（默认 on）

控制索引合并联盟访问优化。


有关更多信息，请参见 第8.2.1.3节“索引合并优化”。


多范围读取标志

mrr（默认on）

控制多范围读取策略。


mrr_cost_based（默认 on）

控制使用基于成本的MRR mrr=on。


有关更多信息，请参见 第8.2.1.10节“多范围读取优化”。


半连接标志

semijoin（默认 on）

控制所有半连接策略。


duplicateweedout（默认 on）

控制半联合Duplicate Weedout策略。


firstmatch（默认 on）

控制半连接的FirstMatch策略。


loosescan（默认 on）

控制半连接LooseScan策略（不要与LooseScan混淆GROUP BY）。


在semijoin， firstmatch，loosescan，和duplicateweedout超过半连接策略的标志使能控制。
该semijoin 标志控制是否使用半连接。
如果它被设置为 on，在firstmatch和 loosescan标志启用了允许半连接策略更精细的控制。


如果duplicateweedout禁用半连接策略，则不会使用半连接策略，除非所有其他适用策略也被禁用。


如果semijoin和 materialization是两个 on，半连接也适用使用物化。
这些标志是on默认的。


有关更多信息，请参见第8.2.2.1节“使用半连接转换优化子查询，派生表和视图引用”。


子查询物化标志

materialization（默认 on）

控制实现（包括半连接实现）。


subquery_materialization_cost_based （默认on）

使用基于成本的物化选择。


该materialization标志控制是否使用子查询实现。
如果 semijoin和 materialization是两个 on，半连接也适用使用物化。
这些标志是on默认的。


该subquery_materialization_cost_based 标志使得能够在子查询物化和之间的选择控制 IN-到- EXISTS子查询变换。
如果该标志为on（默认值），优化器进行子查询物化和之间的基于成本的选择 IN-到- EXISTS子查询变换如果可以使用任一方法。
如果标志是off，优化器选择了子查询物化 IN至- EXISTS子查询的转变。


有关更多信息，请参见 第8.2.2节“优化子查询，派生表和视图引用”。


当您为其赋值时 optimizer_switch，未提及的标志会保留其当前值。
这样可以在单个语句中启用或禁用特定的优化器行为，而不会影响其他行为。
该语句不依赖于其他优化器标志存在以及它们的值是什么。
假设启用了所有索引合并优化：

MySQL的&gt; SELECT @@optimizer_switch\G
*************************** 1. row ******************** *******
@@ optimizer_switch：index_merge = on，index_merge_union = on，
                    index_merge_sort_union =开，
                    index_merge_intersection =开，
                    engine_condition_pushdown =开，
                    index_condition_pushdown =开，
                    MRR =开，上mrr_cost_based =，
                    block_nested_loop =开，batched_key_access =关，
                    物化=开，半连接=上，loosescan =开，
                    firstmatch =开，
                    subquery_materialization_cost_based =开，
                    use_index_extensions =开，
                    condition_fanout_filter =上
如果服务器对某些查询使用索引合并联合或索引合并排序联合访问方法，并且您希望检查优化程序在没有它们的情况下是否会更好地执行，请设置变量值，如下所示：

MySQL的&gt; SET optimizer_switch='index_merge_union=off,index_merge_sort_union=off';

MySQL的&gt; SELECT @@optimizer_switch\G
*************************** 1. row ******************** *******
@@ optimizer_switch：index_merge = on，index_merge_union = off，
                    index_merge_sort_union =关，
                    index_merge_intersection =开，
                    engine_condition_pushdown =开，
                    index_condition_pushdown =开，
                    MRR =开，上mrr_cost_based =，
                    block_nested_loop =开，batched_key_access =关，
                    物化=开，半连接=上，loosescan =开，
                    firstmatch =开，
                    subquery_materialization_cost_based =开，
                    use_index_extensions =开，
                    condition_fanout_filter =上
                    
</code></pre>

<p>8.9.4索引提示</p>

<pre><code>

索引提示为优化程序提供有关如何在查询处理期间选择索引的信息。
这里描述的索引提示与第8.9.2节“优化器提示”中描述的 优化器提示不同。
索引和优化器提示可以单独使用或一起使用。


索引提示是按照表名指定的。
（有关在语句中指定表的一般语法 SELECT，请参见 第13.2.9.2节“JOIN语法”。
）引用单个表（包括索引提示）的语法如下所示：

tbl_name[[AS] alias] [ index_hint_list]

index_hint_list：
     index_hint[ index_hint] ...

index_hint：
    USE {INDEX | KEY}
      [FOR {JOIN | ORDER BY | GROUP BY}]（[ index_list]）
  | IGNORE {INDEX | KEY}
      [FOR {JOIN | ORDER BY | GROUP BY}]（index_list）
  | FORCE {INDEX | KEY}
      [FOR {JOIN | ORDER BY | GROUP BY}]（index_list）

index_list：
     index_name[，index_name] ...
该提示告诉MySQL只使用其中一个命名索引来查找表中的行。
另一种语法告诉MySQL不要使用某些特定的索引或索引。
如果显示MySQL使用可能索引列表中的错误索引，这些提示很有用。
 USE INDEX (index_list)IGNORE INDEX (index_list)EXPLAIN

这个FORCE INDEX提示的作用就像，另外一个表扫描被认为是 非常昂贵的。
换句话说，只有在无法使用某个指定索引在表中查找行时才使用表扫描。
 USE INDEX (index_list)

每个提示都需要索引名称，而不是列名。
要引用主键，请使用该名称PRIMARY。
要查看表的索引名称，请使用该SHOW INDEX语句或 INFORMATION_SCHEMA.STATISTICS 表。


一个index_name值不一定是一个完整的索引名称。
它可以是索引名称的明确前缀。
如果前缀不明确，则会发生错误。


例子：

SELECT * FROM table1 USE INDEX（col1_index，col2_index）
  WH1 col1 = 1 AND col2 = 2 AND col3 = 3;

SELECT * FROM table1 IGNORE INDEX（col3_index）
  WH1 col1 = 1 AND col2 = 2 AND col3 = 3;
索引提示的语法具有以下特征：

它在语法上是有效的，省略 index_list了USE INDEX，这意味着“ 不使用索引。
” 省略index_list的 FORCE INDEX或者IGNORE INDEX是一个语法错误。


您可以通过向提示添加FOR子句来指定索引提示的范围 。
这提供了对查询处理的各个阶段的执行计划的优化器选择的更细粒度的控制。
要仅影响MySQL决定如何在表中查找行以及如何处理连接时使用的索引，请使用FOR JOIN。
要影响用于排序或分组行的索引使用情况，请使用FOR ORDER BY或 FOR GROUP BY。


您可以指定多个索引提示：

SELECT * FROM t1 USE INDEX（i1）IGNORE INDEX FOR ORDER BY（i2）ORDER BY a;
在几个提示中命名相同的索引（即使在相同的提示中）也不是错误的：

SELECT * FROM t1 USE INDEX（i1）USE INDEX（i1，i1）;
但是，它是混合错误USE INDEX 和FORCE INDEX同一个表：

SELECT * FROM t1 USE INDEX FOR JOIN（i1）FORCE INDEX FOR JOIN（i2）;
如果索引提示不包含FOR子句，则提示的范围将应用于语句的所有部分。
例如，这个提示：

IGNORE INDEX（i1）
相当于这种提示的组合：

IGNORE索引加入（i1）
IGNORE索引（ORDER BY）（i1）
IGNORE INDEX FOR GROUP BY（i1）
在MySQL 5.0中，不带FOR子句的提示范围仅适用于行检索。
当不存在FOR子句时，要使服务器使用此旧行为，请old在服务器启动时启用系统变量。
注意在复制设置中启用此变量。
使用基于语句的二进制日志记录时，主服务器和从服务器使用不同的模式可能会导致复制错误。


当索引提示进行处理，它们是由式（收集在一个单一的列表USE，FORCE， IGNORE）和范围（FOR JOIN，FOR ORDER BY，FOR GROUP BY）。
例如：

SELECT * FROM t1
  USE INDEX（）IGNORE INDEX（i2）USE INDEX（i1）USE INDEX（i2）;
相当于：

SELECT * FROM t1
   USE INDEX（i1，i2）IGNORE INDEX（i2）;
索引提示然后按以下顺序应用于每个范围：

{USE|FORCE} INDEX如果存在，则应用。
（如果不是，则使用优化程序确定的一组索引。
）

IGNORE INDEX应用于上一步的结果。
例如，以下两个查询是等同的：

SELECT * FROM t1 USE INDEX（i1）IGNORE INDEX（i2）USE INDEX（i2）;

SELECT * FROM t1 USE INDEX（i1）;
对于FULLTEXT搜索，索引提示的工作如下：

对于自然语言模式搜索，索引提示将被忽略。
例如，IGNORE INDEX(i1)在没有警告的情况下被忽略，索引仍然被使用。


对于布尔模式搜索，带有FOR ORDER BY或者的索引提示FOR GROUP BY默默忽略。
带有FOR JOIN或不带FOR修饰符的索引提示将得到遵守。
与提示如何应用于非FULLTEXT搜索相反，该提示用于查询执行的所有阶段（查找行和检索，分组和排序）。
即使给出非FULLTEXT索引的提示，也是如此。


例如，以下两个查询是等同的：

SELECT * FROM t
  USE INDEX（index1）
  IGNORE INDEX（index1）用于ORDER BY
  IGNORE INDEX（index1）适用于GROUP BY
  在......布尔模式中......;

SELECT * FROM t
  USE INDEX（index1）
  在......布尔模式中......;
  
</code></pre>

<p>8.9.5优化器成本模型</p>

<pre><code>
为了生成执行计划，优化器使用基于对查询执行期间发生的各种操作的成本进行估计的成本模型。
优化器具有一组可编辑的默认“ 成本常量 ”，可用于制定有关执行计划的决策。


优化器还具有执行计划构建过程中使用的成本估算数据库。
这些估计值存储在中server_cost和 engine_cost在表 mysql系统数据库中，随时可配置的。
这些表的目的是使它能够轻松调整优化器在尝试到达查询执行计划时使用的成本估计。


成本模型一般操作

成本模型数据库

对成本模型数据库进行更改

成本模型一般操作
可配置的优化器成本模型如下所示：

服务器在启动时将成本模型表读入内存，并在运行时使用内存中的值。
NULL表中指定的任何非成本估算优先于相应的编译缺省成本常数。
任何NULL 估计都会向优化器指示使用编译的默认值。


在运行时，服务器可能重新读取成本表。
当存储引擎动态加载或FLUSH OPTIMIZER_COSTS 执行语句时会发生这种情况。


成本表使服务器管理员能够通过更改表中的条目来轻松调整成本估算。
通过将条目的成本设置为，也很容易恢复为默认值NULL。
优化程序使用内存中的开销值，因此对表的更改应随后FLUSH OPTIMIZER_COSTS生效。


当客户端会话开始时，当前内存中的成本估算适用于整个会话，直到它结束。
特别是，如果服务器重新读取成本表格，则任何更改的估算值仅适用于随后开始的会话。
现有会话不受影响。


成本表特定于给定的服务器实例。
服务器不会将成本表更改复制到复制从服务器。


成本模型数据库
优化器成本模型数据库由mysql系统数据库中的两个表组成，其中包含查询执行期间发生的操作的成本估算信息：

server_cost：一般服务器操作的优化器成本估算

engine_cost：特定于特定存储引擎的操作的优化器成本估算

该server_cost表包含这些列：

cost_name

成本模型中使用的成本估算的名称。
名称不区分大小写。
如果服务器在读取此表时未识别成本名称，则会向错误日志写入警告。


cost_value

成本估算值。
如果该值不是NULL，则服务器将其用作成本。
否则，它使用默认估计值（编译值）。
DBA可以通过更新此列来更改成本估算。
如果服务器在读取此表时发现成本值无效（非正确），则会向错误日志写入警告。


要覆盖默认成本估算（对于指定的条目NULL），请将成本设置为非NULL值。
要恢复为默认值，请将该值设置为NULL。
然后执行FLUSH OPTIMIZER_COSTS以通知服务器重新读取成本表。


last_update

最后一行更新的时间。


comment

与成本估算相关的描述性评论。
DBA可以使用此列来提供有关成本估算行为何存储特定值的信息。


该server_cost表的主键是cost_name列，因此不可能为任何成本估算创建多个条目。


服务器识别这些表的cost_name 值server_cost：

disk_temptable_create_cost（默认40.0），disk_temptable_row_cost（默认1.0）

存储在基于磁盘的存储引擎（InnoDB或者MyISAM）中的内部创建的临时表的成本估算 。
增加这些值会增加使用内部临时表的成本估计值，并使优化程序偏好使用较少的查询计划。
有关这些表的信息，请参见 第8.4.4节“MySQL中的内部临时表使用”。


与相应内存参数（memory_temptable_create_cost， memory_temptable_row_cost）的默认值相比，
    这些磁盘参数的较大默认值反映了处理基于磁盘的表的较高成本。


key_compare_cost （默认0.1）

比较记录密钥的成本。
增加此值会导致查询计划比较许多密钥变得更加昂贵。
例如，filesort与避免使用索引进行排序的查询计划相比，执行a的查询计划 变得相对昂贵。


memory_temptable_create_cost（默认2.0），memory_temptable_row_cost （默认0.2）

存储在MEMORY存储引擎中的内部创建的临时表的成本估算。
增加这些值会增加使用内部临时表的成本估计值，并使优化程序偏好使用较少的查询计划。
有关这些表的信息，请参见 第8.4.4节“MySQL中的内部临时表使用”。


与相应磁盘参数（disk_temptable_create_cost， disk_temptable_row_cost）的默认值相比，
    这些内存参数的较小默认值反映了处理基于内存的表的较低成本。


row_evaluate_cost （默认0.2）

评估记录条件的成本。
与查询更少行的查询计划相比，增加此值会导致查询计划检查许多行变得更加昂贵。
例如，与读取较少行的范围扫描相比，表扫描变得相对昂贵。


该engine_cost表包含这些列：

engine_name

此成本估算适用的存储引擎的名称。
名称不区分大小写。
如果值是 default，则它适用于所有没有自己的命名条目的存储引擎。
如果服务器在读取此表时未识别引擎名称，则会向错误日志写入警告。


device_type

此成本估算适用的设备类型。
该列旨在为不同的存储设备类型指定不同的成本估算，例如硬盘驱动器与固态驱动器。
目前，该信息未被使用，0是唯一允许的值。


cost_name

与server_cost表中相同。


cost_value

与server_cost表中相同。


last_update

与server_cost表中相同。


comment

与server_cost表中相同。


对于主键engine_cost表是包含（一个元组cost_name， engine_name， device_type）个列，所以它不可能在这些列中的值的任意组合来创建多个条目。


服务器识别这些表的cost_name 值engine_cost：

io_block_read_cost （默认1.0）

从磁盘读取索引或数据块的成本。
与增加此值的查询计划相比，读取许多磁盘块的查询计划与读取更少磁盘块的查询计划相比变得更加昂贵。
例如，与读取较少块的范围扫描相比，表扫描变得相对昂贵。


memory_block_read_cost （默认1.0）

与io_block_read_cost内存数据库缓冲区中的索引或数据块的读取相似，但代表了其成本。


如果io_block_read_cost和 memory_block_read_cost值不同，则执行计划可能会在相同查询的两次运行之间更改。
假设内存访问的成本低于磁盘访问的成本。
在这种情况下，在数据读入缓冲池之前的服务器启动时，您可能会得到与查询运行后不同的计划，因为这样数据将存储在内存中。


对成本模型数据库进行更改
对于希望从其默认值更改成本模型参数的DBA，请尝试将值加倍或减半并测量结果。


对参数io_block_read_cost和 memory_block_read_cost参数的更改最有可能产生有价值的结果。
这些参数值使数据访问方法的成本模型能够考虑从不同来源读取信息的成本; 即从磁盘读取信息与读取存储器缓冲区中已有信息的成本。
例如，所有其他条件相同，将io_block_read_cost值设置 为大于memory_block_read_cost优先级的值 
    会使优化器更喜欢查询计划，该计划将内存中已保存的信息读取到必须从磁盘读取的计划中。


此示例显示如何更改以下内容的默认值 io_block_read_cost：

更新mysql.engine_cost
  SET cost_value = 2.0
  WHERE cost_name ='io_block_read_cost';
FLUSH OPTIMIZER_COSTS;
此示例显示如何io_block_read_cost仅 更改InnoDB存储引擎的值 ：

INSERT INTO mysql.engine_cost
  VALUES（'InnoDB'，0，'io_block_read_cost'，3.0，
  CURRENT_TIMESTAMP，'为InnoDB使用较慢的磁盘'）;
FLUSH OPTIMIZER_COSTS;
</code></pre>
<ul class="pa0">
  
   <li class="list">
     
     <a href="/tags/sql%E4%BC%98%E5%8C%96" style="color:#FFFFFF " class="link db f6 pa2 br3 bg-mid-gray white dim w4 tc">SQL优化</a>
   </li>
  
</ul>
<div class="mt6"></div>


<div id="SOHUCS" sid="/blog/mysql/optimization-sql-selector-2/" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cytHkUEmA';
        var conf = 'prod_6e7b7d38e80b8603d4192a4d85f24774';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>


    </main>

    <aside class="w-30-l mt6-l">





  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">相关文章</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-system/">SQL优化【服务器优化】</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-lock/">SQL优化【锁优化】</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-innodb/">SQL优化【InnoDB-表优化】</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-myisam/">SQL优化【MyISAM-表优化】</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-selector-1/">SQL优化【查询器优化·一】</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-total-2/">常见MYSQL调优策略</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-indexes/">SQL优化【SQL索引】</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-performance-measurement/">SQL优化【绩效衡量】</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-data-structure/">SQL优化【数据结构】</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-cached/">SQL优化【缓存优化】</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-sentence/">SQL优化【SQL语句】</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-thread/">SQL优化【线程信息检查】</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/mysql/optimization-sql-total/">SQL优化【总方向】</a>
        </li>
	    
    </ul>
</div>


<iframe frameborder="no" border="0" marginwidth="0" marginheight="0"  width=300 height=400
        src="//music.163.com/outchain/player?type=0&id=2269118953&auto=0&height=430"></iframe>



</aside>

  </article>

    </main>
    
<footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://wuxinvip.github.io/" >
    &copy; 2018 京ICP备18026588号
    
  </a>
  



  <a href="https://twitter.com/huoyan403" class="link-transition twitter link dib z-999 pt3 pt0-l mr2" title="Twitter link">
    <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

  </a>




  <a href="http://www.linkedin.com/in/%e9%95%bf-%e8%bf%9e-05215b142/" class="link-transition linkedin link dib z-999 pt3 pt0-l mr2" title="LinkedIn link">
    <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

  </a>


  <a href="https://github.com/wuxinvip" class="link-transition github link dib z-999 pt3 pt0-l mr2" title="Github link">
    <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

  </a>


  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="/friends-chain/" >
    友情链接
  </a>
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="/contact/" >
   联系站长
  </a>

  </div>


</footer>

    



<div style="display:none">
  <script src="https://s22.cnzz.com/z_stat.php?id=1273992689&web_id=1273992689" language="JavaScript"></script>
</div>
  </body>
